
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Athlete
 * 
 */
export type Athlete = $Result.DefaultSelection<Prisma.$AthletePayload>
/**
 * Model AthleteActivity
 * 
 */
export type AthleteActivity = $Result.DefaultSelection<Prisma.$AthleteActivityPayload>
/**
 * Model RunCrew
 * 
 */
export type RunCrew = $Result.DefaultSelection<Prisma.$RunCrewPayload>
/**
 * Model RunCrewMembership
 * 
 */
export type RunCrewMembership = $Result.DefaultSelection<Prisma.$RunCrewMembershipPayload>
/**
 * Model RunCrewPost
 * 
 */
export type RunCrewPost = $Result.DefaultSelection<Prisma.$RunCrewPostPayload>
/**
 * Model RunCrewPostComment
 * 
 */
export type RunCrewPostComment = $Result.DefaultSelection<Prisma.$RunCrewPostCommentPayload>
/**
 * Model RunCrewLeaderboard
 * 
 */
export type RunCrewLeaderboard = $Result.DefaultSelection<Prisma.$RunCrewLeaderboardPayload>
/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model TrainingPlan
 * 
 */
export type TrainingPlan = $Result.DefaultSelection<Prisma.$TrainingPlanPayload>
/**
 * Model TrainingDayPlanned
 * 
 */
export type TrainingDayPlanned = $Result.DefaultSelection<Prisma.$TrainingDayPlannedPayload>
/**
 * Model TrainingPlanExecution
 * 
 */
export type TrainingPlanExecution = $Result.DefaultSelection<Prisma.$TrainingPlanExecutionPayload>
/**
 * Model TrainingDayExecuted
 * 
 */
export type TrainingDayExecuted = $Result.DefaultSelection<Prisma.$TrainingDayExecutedPayload>
/**
 * Model Founder
 * 
 */
export type Founder = $Result.DefaultSelection<Prisma.$FounderPayload>
/**
 * Model FounderTask
 * 
 */
export type FounderTask = $Result.DefaultSelection<Prisma.$FounderTaskPayload>
/**
 * Model CrmContact
 * 
 */
export type CrmContact = $Result.DefaultSelection<Prisma.$CrmContactPayload>
/**
 * Model RoadmapItem
 * 
 */
export type RoadmapItem = $Result.DefaultSelection<Prisma.$RoadmapItemPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Athletes
 * const athletes = await prisma.athlete.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Athletes
   * const athletes = await prisma.athlete.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.athlete`: Exposes CRUD operations for the **Athlete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Athletes
    * const athletes = await prisma.athlete.findMany()
    * ```
    */
  get athlete(): Prisma.AthleteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.athleteActivity`: Exposes CRUD operations for the **AthleteActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AthleteActivities
    * const athleteActivities = await prisma.athleteActivity.findMany()
    * ```
    */
  get athleteActivity(): Prisma.AthleteActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrew`: Exposes CRUD operations for the **RunCrew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrews
    * const runCrews = await prisma.runCrew.findMany()
    * ```
    */
  get runCrew(): Prisma.RunCrewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewMembership`: Exposes CRUD operations for the **RunCrewMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewMemberships
    * const runCrewMemberships = await prisma.runCrewMembership.findMany()
    * ```
    */
  get runCrewMembership(): Prisma.RunCrewMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewPost`: Exposes CRUD operations for the **RunCrewPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewPosts
    * const runCrewPosts = await prisma.runCrewPost.findMany()
    * ```
    */
  get runCrewPost(): Prisma.RunCrewPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewPostComment`: Exposes CRUD operations for the **RunCrewPostComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewPostComments
    * const runCrewPostComments = await prisma.runCrewPostComment.findMany()
    * ```
    */
  get runCrewPostComment(): Prisma.RunCrewPostCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewLeaderboard`: Exposes CRUD operations for the **RunCrewLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewLeaderboards
    * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany()
    * ```
    */
  get runCrewLeaderboard(): Prisma.RunCrewLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPlan`: Exposes CRUD operations for the **TrainingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPlans
    * const trainingPlans = await prisma.trainingPlan.findMany()
    * ```
    */
  get trainingPlan(): Prisma.TrainingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDayPlanned`: Exposes CRUD operations for the **TrainingDayPlanned** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDayPlanneds
    * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany()
    * ```
    */
  get trainingDayPlanned(): Prisma.TrainingDayPlannedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPlanExecution`: Exposes CRUD operations for the **TrainingPlanExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPlanExecutions
    * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany()
    * ```
    */
  get trainingPlanExecution(): Prisma.TrainingPlanExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDayExecuted`: Exposes CRUD operations for the **TrainingDayExecuted** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDayExecuteds
    * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany()
    * ```
    */
  get trainingDayExecuted(): Prisma.TrainingDayExecutedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.founder`: Exposes CRUD operations for the **Founder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Founders
    * const founders = await prisma.founder.findMany()
    * ```
    */
  get founder(): Prisma.FounderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.founderTask`: Exposes CRUD operations for the **FounderTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FounderTasks
    * const founderTasks = await prisma.founderTask.findMany()
    * ```
    */
  get founderTask(): Prisma.FounderTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crmContact`: Exposes CRUD operations for the **CrmContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmContacts
    * const crmContacts = await prisma.crmContact.findMany()
    * ```
    */
  get crmContact(): Prisma.CrmContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapItem`: Exposes CRUD operations for the **RoadmapItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapItems
    * const roadmapItems = await prisma.roadmapItem.findMany()
    * ```
    */
  get roadmapItem(): Prisma.RoadmapItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Athlete: 'Athlete',
    AthleteActivity: 'AthleteActivity',
    RunCrew: 'RunCrew',
    RunCrewMembership: 'RunCrewMembership',
    RunCrewPost: 'RunCrewPost',
    RunCrewPostComment: 'RunCrewPostComment',
    RunCrewLeaderboard: 'RunCrewLeaderboard',
    Race: 'Race',
    TrainingPlan: 'TrainingPlan',
    TrainingDayPlanned: 'TrainingDayPlanned',
    TrainingPlanExecution: 'TrainingPlanExecution',
    TrainingDayExecuted: 'TrainingDayExecuted',
    Founder: 'Founder',
    FounderTask: 'FounderTask',
    CrmContact: 'CrmContact',
    RoadmapItem: 'RoadmapItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "athlete" | "athleteActivity" | "runCrew" | "runCrewMembership" | "runCrewPost" | "runCrewPostComment" | "runCrewLeaderboard" | "race" | "trainingPlan" | "trainingDayPlanned" | "trainingPlanExecution" | "trainingDayExecuted" | "founder" | "founderTask" | "crmContact" | "roadmapItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Athlete: {
        payload: Prisma.$AthletePayload<ExtArgs>
        fields: Prisma.AthleteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findFirst: {
            args: Prisma.AthleteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findMany: {
            args: Prisma.AthleteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          create: {
            args: Prisma.AthleteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          createMany: {
            args: Prisma.AthleteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AthleteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          delete: {
            args: Prisma.AthleteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          update: {
            args: Prisma.AthleteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          deleteMany: {
            args: Prisma.AthleteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AthleteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AthleteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          upsert: {
            args: Prisma.AthleteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          aggregate: {
            args: Prisma.AthleteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAthlete>
          }
          groupBy: {
            args: Prisma.AthleteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AthleteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleteCountArgs<ExtArgs>
            result: $Utils.Optional<AthleteCountAggregateOutputType> | number
          }
        }
      }
      AthleteActivity: {
        payload: Prisma.$AthleteActivityPayload<ExtArgs>
        fields: Prisma.AthleteActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleteActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleteActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          findFirst: {
            args: Prisma.AthleteActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleteActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          findMany: {
            args: Prisma.AthleteActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          create: {
            args: Prisma.AthleteActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          createMany: {
            args: Prisma.AthleteActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AthleteActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          delete: {
            args: Prisma.AthleteActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          update: {
            args: Prisma.AthleteActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          deleteMany: {
            args: Prisma.AthleteActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AthleteActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AthleteActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          upsert: {
            args: Prisma.AthleteActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          aggregate: {
            args: Prisma.AthleteActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAthleteActivity>
          }
          groupBy: {
            args: Prisma.AthleteActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AthleteActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleteActivityCountArgs<ExtArgs>
            result: $Utils.Optional<AthleteActivityCountAggregateOutputType> | number
          }
        }
      }
      RunCrew: {
        payload: Prisma.$RunCrewPayload<ExtArgs>
        fields: Prisma.RunCrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          findFirst: {
            args: Prisma.RunCrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          findMany: {
            args: Prisma.RunCrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          create: {
            args: Prisma.RunCrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          createMany: {
            args: Prisma.RunCrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          delete: {
            args: Prisma.RunCrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          update: {
            args: Prisma.RunCrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          aggregate: {
            args: Prisma.RunCrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrew>
          }
          groupBy: {
            args: Prisma.RunCrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewCountAggregateOutputType> | number
          }
        }
      }
      RunCrewMembership: {
        payload: Prisma.$RunCrewMembershipPayload<ExtArgs>
        fields: Prisma.RunCrewMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          findFirst: {
            args: Prisma.RunCrewMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          findMany: {
            args: Prisma.RunCrewMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          create: {
            args: Prisma.RunCrewMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          createMany: {
            args: Prisma.RunCrewMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          delete: {
            args: Prisma.RunCrewMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          update: {
            args: Prisma.RunCrewMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          aggregate: {
            args: Prisma.RunCrewMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewMembership>
          }
          groupBy: {
            args: Prisma.RunCrewMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMembershipCountAggregateOutputType> | number
          }
        }
      }
      RunCrewPost: {
        payload: Prisma.$RunCrewPostPayload<ExtArgs>
        fields: Prisma.RunCrewPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          findFirst: {
            args: Prisma.RunCrewPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          findMany: {
            args: Prisma.RunCrewPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>[]
          }
          create: {
            args: Prisma.RunCrewPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          createMany: {
            args: Prisma.RunCrewPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>[]
          }
          delete: {
            args: Prisma.RunCrewPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          update: {
            args: Prisma.RunCrewPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostPayload>
          }
          aggregate: {
            args: Prisma.RunCrewPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewPost>
          }
          groupBy: {
            args: Prisma.RunCrewPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewPostCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewPostCountAggregateOutputType> | number
          }
        }
      }
      RunCrewPostComment: {
        payload: Prisma.$RunCrewPostCommentPayload<ExtArgs>
        fields: Prisma.RunCrewPostCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewPostCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewPostCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          findFirst: {
            args: Prisma.RunCrewPostCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewPostCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          findMany: {
            args: Prisma.RunCrewPostCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>[]
          }
          create: {
            args: Prisma.RunCrewPostCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          createMany: {
            args: Prisma.RunCrewPostCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewPostCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>[]
          }
          delete: {
            args: Prisma.RunCrewPostCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          update: {
            args: Prisma.RunCrewPostCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewPostCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewPostCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewPostCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewPostCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPostCommentPayload>
          }
          aggregate: {
            args: Prisma.RunCrewPostCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewPostComment>
          }
          groupBy: {
            args: Prisma.RunCrewPostCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewPostCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewPostCommentCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewPostCommentCountAggregateOutputType> | number
          }
        }
      }
      RunCrewLeaderboard: {
        payload: Prisma.$RunCrewLeaderboardPayload<ExtArgs>
        fields: Prisma.RunCrewLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.RunCrewLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          findMany: {
            args: Prisma.RunCrewLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          create: {
            args: Prisma.RunCrewLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          createMany: {
            args: Prisma.RunCrewLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.RunCrewLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          update: {
            args: Prisma.RunCrewLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.RunCrewLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewLeaderboard>
          }
          groupBy: {
            args: Prisma.RunCrewLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      TrainingPlan: {
        payload: Prisma.$TrainingPlanPayload<ExtArgs>
        fields: Prisma.TrainingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          findFirst: {
            args: Prisma.TrainingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          findMany: {
            args: Prisma.TrainingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          create: {
            args: Prisma.TrainingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          createMany: {
            args: Prisma.TrainingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          delete: {
            args: Prisma.TrainingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          update: {
            args: Prisma.TrainingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          aggregate: {
            args: Prisma.TrainingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPlan>
          }
          groupBy: {
            args: Prisma.TrainingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanCountAggregateOutputType> | number
          }
        }
      }
      TrainingDayPlanned: {
        payload: Prisma.$TrainingDayPlannedPayload<ExtArgs>
        fields: Prisma.TrainingDayPlannedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDayPlannedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          findFirst: {
            args: Prisma.TrainingDayPlannedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          findMany: {
            args: Prisma.TrainingDayPlannedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          create: {
            args: Prisma.TrainingDayPlannedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          createMany: {
            args: Prisma.TrainingDayPlannedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          delete: {
            args: Prisma.TrainingDayPlannedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          update: {
            args: Prisma.TrainingDayPlannedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDayPlannedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDayPlannedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDayPlannedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          aggregate: {
            args: Prisma.TrainingDayPlannedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDayPlanned>
          }
          groupBy: {
            args: Prisma.TrainingDayPlannedGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayPlannedGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDayPlannedCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayPlannedCountAggregateOutputType> | number
          }
        }
      }
      TrainingPlanExecution: {
        payload: Prisma.$TrainingPlanExecutionPayload<ExtArgs>
        fields: Prisma.TrainingPlanExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPlanExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          findFirst: {
            args: Prisma.TrainingPlanExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          findMany: {
            args: Prisma.TrainingPlanExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          create: {
            args: Prisma.TrainingPlanExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          createMany: {
            args: Prisma.TrainingPlanExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          delete: {
            args: Prisma.TrainingPlanExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          update: {
            args: Prisma.TrainingPlanExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPlanExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPlanExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPlanExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          aggregate: {
            args: Prisma.TrainingPlanExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPlanExecution>
          }
          groupBy: {
            args: Prisma.TrainingPlanExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPlanExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanExecutionCountAggregateOutputType> | number
          }
        }
      }
      TrainingDayExecuted: {
        payload: Prisma.$TrainingDayExecutedPayload<ExtArgs>
        fields: Prisma.TrainingDayExecutedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDayExecutedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          findFirst: {
            args: Prisma.TrainingDayExecutedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          findMany: {
            args: Prisma.TrainingDayExecutedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          create: {
            args: Prisma.TrainingDayExecutedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          createMany: {
            args: Prisma.TrainingDayExecutedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          delete: {
            args: Prisma.TrainingDayExecutedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          update: {
            args: Prisma.TrainingDayExecutedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDayExecutedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDayExecutedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDayExecutedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          aggregate: {
            args: Prisma.TrainingDayExecutedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDayExecuted>
          }
          groupBy: {
            args: Prisma.TrainingDayExecutedGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayExecutedGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDayExecutedCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayExecutedCountAggregateOutputType> | number
          }
        }
      }
      Founder: {
        payload: Prisma.$FounderPayload<ExtArgs>
        fields: Prisma.FounderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FounderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FounderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          findFirst: {
            args: Prisma.FounderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FounderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          findMany: {
            args: Prisma.FounderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          create: {
            args: Prisma.FounderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          createMany: {
            args: Prisma.FounderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FounderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          delete: {
            args: Prisma.FounderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          update: {
            args: Prisma.FounderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          deleteMany: {
            args: Prisma.FounderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FounderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FounderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          upsert: {
            args: Prisma.FounderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          aggregate: {
            args: Prisma.FounderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFounder>
          }
          groupBy: {
            args: Prisma.FounderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FounderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FounderCountArgs<ExtArgs>
            result: $Utils.Optional<FounderCountAggregateOutputType> | number
          }
        }
      }
      FounderTask: {
        payload: Prisma.$FounderTaskPayload<ExtArgs>
        fields: Prisma.FounderTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FounderTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FounderTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          findFirst: {
            args: Prisma.FounderTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FounderTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          findMany: {
            args: Prisma.FounderTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          create: {
            args: Prisma.FounderTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          createMany: {
            args: Prisma.FounderTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FounderTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          delete: {
            args: Prisma.FounderTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          update: {
            args: Prisma.FounderTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          deleteMany: {
            args: Prisma.FounderTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FounderTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FounderTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          upsert: {
            args: Prisma.FounderTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          aggregate: {
            args: Prisma.FounderTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFounderTask>
          }
          groupBy: {
            args: Prisma.FounderTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<FounderTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.FounderTaskCountArgs<ExtArgs>
            result: $Utils.Optional<FounderTaskCountAggregateOutputType> | number
          }
        }
      }
      CrmContact: {
        payload: Prisma.$CrmContactPayload<ExtArgs>
        fields: Prisma.CrmContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findFirst: {
            args: Prisma.CrmContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findMany: {
            args: Prisma.CrmContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          create: {
            args: Prisma.CrmContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          createMany: {
            args: Prisma.CrmContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          delete: {
            args: Prisma.CrmContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          update: {
            args: Prisma.CrmContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          deleteMany: {
            args: Prisma.CrmContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrmContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          upsert: {
            args: Prisma.CrmContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          aggregate: {
            args: Prisma.CrmContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmContact>
          }
          groupBy: {
            args: Prisma.CrmContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmContactCountArgs<ExtArgs>
            result: $Utils.Optional<CrmContactCountAggregateOutputType> | number
          }
        }
      }
      RoadmapItem: {
        payload: Prisma.$RoadmapItemPayload<ExtArgs>
        fields: Prisma.RoadmapItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findFirst: {
            args: Prisma.RoadmapItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findMany: {
            args: Prisma.RoadmapItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          create: {
            args: Prisma.RoadmapItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          createMany: {
            args: Prisma.RoadmapItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          delete: {
            args: Prisma.RoadmapItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          update: {
            args: Prisma.RoadmapItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          aggregate: {
            args: Prisma.RoadmapItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapItem>
          }
          groupBy: {
            args: Prisma.RoadmapItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapItemCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    athlete?: AthleteOmit
    athleteActivity?: AthleteActivityOmit
    runCrew?: RunCrewOmit
    runCrewMembership?: RunCrewMembershipOmit
    runCrewPost?: RunCrewPostOmit
    runCrewPostComment?: RunCrewPostCommentOmit
    runCrewLeaderboard?: RunCrewLeaderboardOmit
    race?: RaceOmit
    trainingPlan?: TrainingPlanOmit
    trainingDayPlanned?: TrainingDayPlannedOmit
    trainingPlanExecution?: TrainingPlanExecutionOmit
    trainingDayExecuted?: TrainingDayExecutedOmit
    founder?: FounderOmit
    founderTask?: FounderTaskOmit
    crmContact?: CrmContactOmit
    roadmapItem?: RoadmapItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AthleteCountOutputType
   */

  export type AthleteCountOutputType = {
    activities: number
    adminRunCrews: number
    runCrewMemberships: number
    runCrewPosts: number
    runCrewPostComments: number
    runCrewLeaderboards: number
    createdRaces: number
    trainingPlans: number
    plannedDays: number
    executedDays: number
  }

  export type AthleteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | AthleteCountOutputTypeCountActivitiesArgs
    adminRunCrews?: boolean | AthleteCountOutputTypeCountAdminRunCrewsArgs
    runCrewMemberships?: boolean | AthleteCountOutputTypeCountRunCrewMembershipsArgs
    runCrewPosts?: boolean | AthleteCountOutputTypeCountRunCrewPostsArgs
    runCrewPostComments?: boolean | AthleteCountOutputTypeCountRunCrewPostCommentsArgs
    runCrewLeaderboards?: boolean | AthleteCountOutputTypeCountRunCrewLeaderboardsArgs
    createdRaces?: boolean | AthleteCountOutputTypeCountCreatedRacesArgs
    trainingPlans?: boolean | AthleteCountOutputTypeCountTrainingPlansArgs
    plannedDays?: boolean | AthleteCountOutputTypeCountPlannedDaysArgs
    executedDays?: boolean | AthleteCountOutputTypeCountExecutedDaysArgs
  }

  // Custom InputTypes
  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteCountOutputType
     */
    select?: AthleteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteActivityWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountAdminRunCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewPostCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostCommentWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountCreatedRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountTrainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountPlannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountExecutedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
  }


  /**
   * Count Type RunCrewCountOutputType
   */

  export type RunCrewCountOutputType = {
    memberships: number
    posts: number
    leaderboardEntries: number
  }

  export type RunCrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | RunCrewCountOutputTypeCountMembershipsArgs
    posts?: boolean | RunCrewCountOutputTypeCountPostsArgs
    leaderboardEntries?: boolean | RunCrewCountOutputTypeCountLeaderboardEntriesArgs
  }

  // Custom InputTypes
  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewCountOutputType
     */
    select?: RunCrewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
  }


  /**
   * Count Type RunCrewPostCountOutputType
   */

  export type RunCrewPostCountOutputType = {
    comments: number
  }

  export type RunCrewPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | RunCrewPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * RunCrewPostCountOutputType without action
   */
  export type RunCrewPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostCountOutputType
     */
    select?: RunCrewPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCrewPostCountOutputType without action
   */
  export type RunCrewPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostCommentWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    trainingPlans: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlans?: boolean | RaceCountOutputTypeCountTrainingPlansArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountTrainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
  }


  /**
   * Count Type TrainingPlanCountOutputType
   */

  export type TrainingPlanCountOutputType = {
    plannedDays: number
    executions: number
  }

  export type TrainingPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannedDays?: boolean | TrainingPlanCountOutputTypeCountPlannedDaysArgs
    executions?: boolean | TrainingPlanCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanCountOutputType
     */
    select?: TrainingPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeCountPlannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
  }

  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanExecutionWhereInput
  }


  /**
   * Count Type TrainingPlanExecutionCountOutputType
   */

  export type TrainingPlanExecutionCountOutputType = {
    executedDays: number
  }

  export type TrainingPlanExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executedDays?: boolean | TrainingPlanExecutionCountOutputTypeCountExecutedDaysArgs
  }

  // Custom InputTypes
  /**
   * TrainingPlanExecutionCountOutputType without action
   */
  export type TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecutionCountOutputType
     */
    select?: TrainingPlanExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingPlanExecutionCountOutputType without action
   */
  export type TrainingPlanExecutionCountOutputTypeCountExecutedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
  }


  /**
   * Count Type FounderCountOutputType
   */

  export type FounderCountOutputType = {
    tasks: number
    crmContacts: number
    roadmapItems: number
  }

  export type FounderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | FounderCountOutputTypeCountTasksArgs
    crmContacts?: boolean | FounderCountOutputTypeCountCrmContactsArgs
    roadmapItems?: boolean | FounderCountOutputTypeCountRoadmapItemsArgs
  }

  // Custom InputTypes
  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderCountOutputType
     */
    select?: FounderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderTaskWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountCrmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmContactWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountRoadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Athlete
   */

  export type AggregateAthlete = {
    _count: AthleteCountAggregateOutputType | null
    _avg: AthleteAvgAggregateOutputType | null
    _sum: AthleteSumAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  export type AthleteAvgAggregateOutputType = {
    weeklyMileage: number | null
    garmin_expires_in: number | null
    strava_id: number | null
    strava_expires_at: number | null
  }

  export type AthleteSumAggregateOutputType = {
    weeklyMileage: number | null
    garmin_expires_in: number | null
    strava_id: number | null
    strava_expires_at: number | null
  }

  export type AthleteMinAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_is_connected: boolean | null
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AthleteMaxAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_is_connected: boolean | null
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AthleteCountAggregateOutputType = {
    id: number
    firebaseId: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    gofastHandle: number
    birthday: number
    gender: number
    city: number
    state: number
    primarySport: number
    photoURL: number
    bio: number
    instagram: number
    currentPace: number
    weeklyMileage: number
    trainingGoal: number
    targetRace: number
    trainingStartDate: number
    preferredDistance: number
    timePreference: number
    paceRange: number
    runningGoals: number
    garmin_user_id: number
    garmin_access_token: number
    garmin_refresh_token: number
    garmin_expires_in: number
    garmin_scope: number
    garmin_connected_at: number
    garmin_last_sync_at: number
    garmin_permissions: number
    garmin_is_connected: number
    garmin_disconnected_at: number
    strava_id: number
    strava_access_token: number
    strava_refresh_token: number
    strava_expires_at: number
    garmin_user_profile: number
    garmin_user_sleep: number
    garmin_user_preferences: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AthleteAvgAggregateInputType = {
    weeklyMileage?: true
    garmin_expires_in?: true
    strava_id?: true
    strava_expires_at?: true
  }

  export type AthleteSumAggregateInputType = {
    weeklyMileage?: true
    garmin_expires_in?: true
    strava_id?: true
    strava_expires_at?: true
  }

  export type AthleteMinAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AthleteMaxAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AthleteCountAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_permissions?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    garmin_user_profile?: true
    garmin_user_sleep?: true
    garmin_user_preferences?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AthleteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athlete to aggregate.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Athletes
    **/
    _count?: true | AthleteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteMaxAggregateInputType
  }

  export type GetAthleteAggregateType<T extends AthleteAggregateArgs> = {
        [P in keyof T & keyof AggregateAthlete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthlete[P]>
      : GetScalarType<T[P], AggregateAthlete[P]>
  }




  export type AthleteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteWhereInput
    orderBy?: AthleteOrderByWithAggregationInput | AthleteOrderByWithAggregationInput[]
    by: AthleteScalarFieldEnum[] | AthleteScalarFieldEnum
    having?: AthleteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteCountAggregateInputType | true
    _avg?: AthleteAvgAggregateInputType
    _sum?: AthleteSumAggregateInputType
    _min?: AthleteMinAggregateInputType
    _max?: AthleteMaxAggregateInputType
  }

  export type AthleteGroupByOutputType = {
    id: string
    firebaseId: string
    firstName: string | null
    lastName: string | null
    email: string
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_permissions: JsonValue | null
    garmin_is_connected: boolean
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    garmin_user_profile: JsonValue | null
    garmin_user_sleep: JsonValue | null
    garmin_user_preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    status: string | null
    _count: AthleteCountAggregateOutputType | null
    _avg: AthleteAvgAggregateOutputType | null
    _sum: AthleteSumAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  type GetAthleteGroupByPayload<T extends AthleteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteGroupByOutputType[P]>
        }
      >
    >


  export type AthleteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    activities?: boolean | Athlete$activitiesArgs<ExtArgs>
    adminRunCrews?: boolean | Athlete$adminRunCrewsArgs<ExtArgs>
    runCrewMemberships?: boolean | Athlete$runCrewMembershipsArgs<ExtArgs>
    runCrewPosts?: boolean | Athlete$runCrewPostsArgs<ExtArgs>
    runCrewPostComments?: boolean | Athlete$runCrewPostCommentsArgs<ExtArgs>
    runCrewLeaderboards?: boolean | Athlete$runCrewLeaderboardsArgs<ExtArgs>
    createdRaces?: boolean | Athlete$createdRacesArgs<ExtArgs>
    trainingPlans?: boolean | Athlete$trainingPlansArgs<ExtArgs>
    plannedDays?: boolean | Athlete$plannedDaysArgs<ExtArgs>
    executedDays?: boolean | Athlete$executedDaysArgs<ExtArgs>
    founder?: boolean | Athlete$founderArgs<ExtArgs>
    _count?: boolean | AthleteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectScalar = {
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type AthleteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firebaseId" | "firstName" | "lastName" | "email" | "phoneNumber" | "gofastHandle" | "birthday" | "gender" | "city" | "state" | "primarySport" | "photoURL" | "bio" | "instagram" | "currentPace" | "weeklyMileage" | "trainingGoal" | "targetRace" | "trainingStartDate" | "preferredDistance" | "timePreference" | "paceRange" | "runningGoals" | "garmin_user_id" | "garmin_access_token" | "garmin_refresh_token" | "garmin_expires_in" | "garmin_scope" | "garmin_connected_at" | "garmin_last_sync_at" | "garmin_permissions" | "garmin_is_connected" | "garmin_disconnected_at" | "strava_id" | "strava_access_token" | "strava_refresh_token" | "strava_expires_at" | "garmin_user_profile" | "garmin_user_sleep" | "garmin_user_preferences" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["athlete"]>
  export type AthleteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Athlete$activitiesArgs<ExtArgs>
    adminRunCrews?: boolean | Athlete$adminRunCrewsArgs<ExtArgs>
    runCrewMemberships?: boolean | Athlete$runCrewMembershipsArgs<ExtArgs>
    runCrewPosts?: boolean | Athlete$runCrewPostsArgs<ExtArgs>
    runCrewPostComments?: boolean | Athlete$runCrewPostCommentsArgs<ExtArgs>
    runCrewLeaderboards?: boolean | Athlete$runCrewLeaderboardsArgs<ExtArgs>
    createdRaces?: boolean | Athlete$createdRacesArgs<ExtArgs>
    trainingPlans?: boolean | Athlete$trainingPlansArgs<ExtArgs>
    plannedDays?: boolean | Athlete$plannedDaysArgs<ExtArgs>
    executedDays?: boolean | Athlete$executedDaysArgs<ExtArgs>
    founder?: boolean | Athlete$founderArgs<ExtArgs>
    _count?: boolean | AthleteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AthleteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AthleteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AthletePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Athlete"
    objects: {
      activities: Prisma.$AthleteActivityPayload<ExtArgs>[]
      adminRunCrews: Prisma.$RunCrewPayload<ExtArgs>[]
      runCrewMemberships: Prisma.$RunCrewMembershipPayload<ExtArgs>[]
      runCrewPosts: Prisma.$RunCrewPostPayload<ExtArgs>[]
      runCrewPostComments: Prisma.$RunCrewPostCommentPayload<ExtArgs>[]
      runCrewLeaderboards: Prisma.$RunCrewLeaderboardPayload<ExtArgs>[]
      createdRaces: Prisma.$RacePayload<ExtArgs>[]
      trainingPlans: Prisma.$TrainingPlanPayload<ExtArgs>[]
      plannedDays: Prisma.$TrainingDayPlannedPayload<ExtArgs>[]
      executedDays: Prisma.$TrainingDayExecutedPayload<ExtArgs>[]
      founder: Prisma.$FounderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firebaseId: string
      firstName: string | null
      lastName: string | null
      email: string
      phoneNumber: string | null
      gofastHandle: string | null
      birthday: Date | null
      gender: string | null
      city: string | null
      state: string | null
      primarySport: string | null
      photoURL: string | null
      bio: string | null
      instagram: string | null
      currentPace: string | null
      weeklyMileage: number | null
      trainingGoal: string | null
      targetRace: string | null
      trainingStartDate: Date | null
      preferredDistance: string | null
      timePreference: string | null
      paceRange: string | null
      runningGoals: string | null
      garmin_user_id: string | null
      garmin_access_token: string | null
      garmin_refresh_token: string | null
      garmin_expires_in: number | null
      garmin_scope: string | null
      garmin_connected_at: Date | null
      garmin_last_sync_at: Date | null
      garmin_permissions: Prisma.JsonValue | null
      garmin_is_connected: boolean
      garmin_disconnected_at: Date | null
      strava_id: number | null
      strava_access_token: string | null
      strava_refresh_token: string | null
      strava_expires_at: number | null
      garmin_user_profile: Prisma.JsonValue | null
      garmin_user_sleep: Prisma.JsonValue | null
      garmin_user_preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      status: string | null
    }, ExtArgs["result"]["athlete"]>
    composites: {}
  }

  type AthleteGetPayload<S extends boolean | null | undefined | AthleteDefaultArgs> = $Result.GetResult<Prisma.$AthletePayload, S>

  type AthleteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AthleteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AthleteCountAggregateInputType | true
    }

  export interface AthleteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Athlete'], meta: { name: 'Athlete' } }
    /**
     * Find zero or one Athlete that matches the filter.
     * @param {AthleteFindUniqueArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AthleteFindUniqueArgs>(args: SelectSubset<T, AthleteFindUniqueArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Athlete that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AthleteFindUniqueOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AthleteFindUniqueOrThrowArgs>(args: SelectSubset<T, AthleteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Athlete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AthleteFindFirstArgs>(args?: SelectSubset<T, AthleteFindFirstArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Athlete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AthleteFindFirstOrThrowArgs>(args?: SelectSubset<T, AthleteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Athletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Athletes
     * const athletes = await prisma.athlete.findMany()
     * 
     * // Get first 10 Athletes
     * const athletes = await prisma.athlete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteWithIdOnly = await prisma.athlete.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AthleteFindManyArgs>(args?: SelectSubset<T, AthleteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Athlete.
     * @param {AthleteCreateArgs} args - Arguments to create a Athlete.
     * @example
     * // Create one Athlete
     * const Athlete = await prisma.athlete.create({
     *   data: {
     *     // ... data to create a Athlete
     *   }
     * })
     * 
     */
    create<T extends AthleteCreateArgs>(args: SelectSubset<T, AthleteCreateArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Athletes.
     * @param {AthleteCreateManyArgs} args - Arguments to create many Athletes.
     * @example
     * // Create many Athletes
     * const athlete = await prisma.athlete.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AthleteCreateManyArgs>(args?: SelectSubset<T, AthleteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Athletes and returns the data saved in the database.
     * @param {AthleteCreateManyAndReturnArgs} args - Arguments to create many Athletes.
     * @example
     * // Create many Athletes
     * const athlete = await prisma.athlete.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Athletes and only return the `id`
     * const athleteWithIdOnly = await prisma.athlete.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AthleteCreateManyAndReturnArgs>(args?: SelectSubset<T, AthleteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Athlete.
     * @param {AthleteDeleteArgs} args - Arguments to delete one Athlete.
     * @example
     * // Delete one Athlete
     * const Athlete = await prisma.athlete.delete({
     *   where: {
     *     // ... filter to delete one Athlete
     *   }
     * })
     * 
     */
    delete<T extends AthleteDeleteArgs>(args: SelectSubset<T, AthleteDeleteArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Athlete.
     * @param {AthleteUpdateArgs} args - Arguments to update one Athlete.
     * @example
     * // Update one Athlete
     * const athlete = await prisma.athlete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AthleteUpdateArgs>(args: SelectSubset<T, AthleteUpdateArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Athletes.
     * @param {AthleteDeleteManyArgs} args - Arguments to filter Athletes to delete.
     * @example
     * // Delete a few Athletes
     * const { count } = await prisma.athlete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AthleteDeleteManyArgs>(args?: SelectSubset<T, AthleteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Athletes
     * const athlete = await prisma.athlete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AthleteUpdateManyArgs>(args: SelectSubset<T, AthleteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Athletes and returns the data updated in the database.
     * @param {AthleteUpdateManyAndReturnArgs} args - Arguments to update many Athletes.
     * @example
     * // Update many Athletes
     * const athlete = await prisma.athlete.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Athletes and only return the `id`
     * const athleteWithIdOnly = await prisma.athlete.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AthleteUpdateManyAndReturnArgs>(args: SelectSubset<T, AthleteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Athlete.
     * @param {AthleteUpsertArgs} args - Arguments to update or create a Athlete.
     * @example
     * // Update or create a Athlete
     * const athlete = await prisma.athlete.upsert({
     *   create: {
     *     // ... data to create a Athlete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Athlete we want to update
     *   }
     * })
     */
    upsert<T extends AthleteUpsertArgs>(args: SelectSubset<T, AthleteUpsertArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCountArgs} args - Arguments to filter Athletes to count.
     * @example
     * // Count the number of Athletes
     * const count = await prisma.athlete.count({
     *   where: {
     *     // ... the filter for the Athletes we want to count
     *   }
     * })
    **/
    count<T extends AthleteCountArgs>(
      args?: Subset<T, AthleteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteAggregateArgs>(args: Subset<T, AthleteAggregateArgs>): Prisma.PrismaPromise<GetAthleteAggregateType<T>>

    /**
     * Group by Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteGroupByArgs['orderBy'] }
        : { orderBy?: AthleteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Athlete model
   */
  readonly fields: AthleteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Athlete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Athlete$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminRunCrews<T extends Athlete$adminRunCrewsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$adminRunCrewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewMemberships<T extends Athlete$runCrewMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewPosts<T extends Athlete$runCrewPostsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewPostComments<T extends Athlete$runCrewPostCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewPostCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewLeaderboards<T extends Athlete$runCrewLeaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewLeaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRaces<T extends Athlete$createdRacesArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$createdRacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingPlans<T extends Athlete$trainingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$trainingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannedDays<T extends Athlete$plannedDaysArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$plannedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executedDays<T extends Athlete$executedDaysArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$executedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    founder<T extends Athlete$founderArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$founderArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Athlete model
   */
  interface AthleteFieldRefs {
    readonly id: FieldRef<"Athlete", 'String'>
    readonly firebaseId: FieldRef<"Athlete", 'String'>
    readonly firstName: FieldRef<"Athlete", 'String'>
    readonly lastName: FieldRef<"Athlete", 'String'>
    readonly email: FieldRef<"Athlete", 'String'>
    readonly phoneNumber: FieldRef<"Athlete", 'String'>
    readonly gofastHandle: FieldRef<"Athlete", 'String'>
    readonly birthday: FieldRef<"Athlete", 'DateTime'>
    readonly gender: FieldRef<"Athlete", 'String'>
    readonly city: FieldRef<"Athlete", 'String'>
    readonly state: FieldRef<"Athlete", 'String'>
    readonly primarySport: FieldRef<"Athlete", 'String'>
    readonly photoURL: FieldRef<"Athlete", 'String'>
    readonly bio: FieldRef<"Athlete", 'String'>
    readonly instagram: FieldRef<"Athlete", 'String'>
    readonly currentPace: FieldRef<"Athlete", 'String'>
    readonly weeklyMileage: FieldRef<"Athlete", 'Int'>
    readonly trainingGoal: FieldRef<"Athlete", 'String'>
    readonly targetRace: FieldRef<"Athlete", 'String'>
    readonly trainingStartDate: FieldRef<"Athlete", 'DateTime'>
    readonly preferredDistance: FieldRef<"Athlete", 'String'>
    readonly timePreference: FieldRef<"Athlete", 'String'>
    readonly paceRange: FieldRef<"Athlete", 'String'>
    readonly runningGoals: FieldRef<"Athlete", 'String'>
    readonly garmin_user_id: FieldRef<"Athlete", 'String'>
    readonly garmin_access_token: FieldRef<"Athlete", 'String'>
    readonly garmin_refresh_token: FieldRef<"Athlete", 'String'>
    readonly garmin_expires_in: FieldRef<"Athlete", 'Int'>
    readonly garmin_scope: FieldRef<"Athlete", 'String'>
    readonly garmin_connected_at: FieldRef<"Athlete", 'DateTime'>
    readonly garmin_last_sync_at: FieldRef<"Athlete", 'DateTime'>
    readonly garmin_permissions: FieldRef<"Athlete", 'Json'>
    readonly garmin_is_connected: FieldRef<"Athlete", 'Boolean'>
    readonly garmin_disconnected_at: FieldRef<"Athlete", 'DateTime'>
    readonly strava_id: FieldRef<"Athlete", 'Int'>
    readonly strava_access_token: FieldRef<"Athlete", 'String'>
    readonly strava_refresh_token: FieldRef<"Athlete", 'String'>
    readonly strava_expires_at: FieldRef<"Athlete", 'Int'>
    readonly garmin_user_profile: FieldRef<"Athlete", 'Json'>
    readonly garmin_user_sleep: FieldRef<"Athlete", 'Json'>
    readonly garmin_user_preferences: FieldRef<"Athlete", 'Json'>
    readonly createdAt: FieldRef<"Athlete", 'DateTime'>
    readonly updatedAt: FieldRef<"Athlete", 'DateTime'>
    readonly status: FieldRef<"Athlete", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Athlete findUnique
   */
  export type AthleteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete findUniqueOrThrow
   */
  export type AthleteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete findFirst
   */
  export type AthleteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete findFirstOrThrow
   */
  export type AthleteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete findMany
   */
  export type AthleteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athletes to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete create
   */
  export type AthleteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The data needed to create a Athlete.
     */
    data: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
  }

  /**
   * Athlete createMany
   */
  export type AthleteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Athletes.
     */
    data: AthleteCreateManyInput | AthleteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Athlete createManyAndReturn
   */
  export type AthleteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * The data used to create many Athletes.
     */
    data: AthleteCreateManyInput | AthleteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Athlete update
   */
  export type AthleteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The data needed to update a Athlete.
     */
    data: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
    /**
     * Choose, which Athlete to update.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete updateMany
   */
  export type AthleteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Athletes.
     */
    data: XOR<AthleteUpdateManyMutationInput, AthleteUncheckedUpdateManyInput>
    /**
     * Filter which Athletes to update
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to update.
     */
    limit?: number
  }

  /**
   * Athlete updateManyAndReturn
   */
  export type AthleteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * The data used to update Athletes.
     */
    data: XOR<AthleteUpdateManyMutationInput, AthleteUncheckedUpdateManyInput>
    /**
     * Filter which Athletes to update
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to update.
     */
    limit?: number
  }

  /**
   * Athlete upsert
   */
  export type AthleteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The filter to search for the Athlete to update in case it exists.
     */
    where: AthleteWhereUniqueInput
    /**
     * In case the Athlete found by the `where` argument doesn't exist, create a new Athlete with this data.
     */
    create: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
    /**
     * In case the Athlete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
  }

  /**
   * Athlete delete
   */
  export type AthleteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter which Athlete to delete.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete deleteMany
   */
  export type AthleteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athletes to delete
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to delete.
     */
    limit?: number
  }

  /**
   * Athlete.activities
   */
  export type Athlete$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    where?: AthleteActivityWhereInput
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    cursor?: AthleteActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * Athlete.adminRunCrews
   */
  export type Athlete$adminRunCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    where?: RunCrewWhereInput
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    cursor?: RunCrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewMemberships
   */
  export type Athlete$runCrewMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    cursor?: RunCrewMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewPosts
   */
  export type Athlete$runCrewPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    where?: RunCrewPostWhereInput
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    cursor?: RunCrewPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewPostScalarFieldEnum | RunCrewPostScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewPostComments
   */
  export type Athlete$runCrewPostCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    where?: RunCrewPostCommentWhereInput
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    cursor?: RunCrewPostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewPostCommentScalarFieldEnum | RunCrewPostCommentScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewLeaderboards
   */
  export type Athlete$runCrewLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    cursor?: RunCrewLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * Athlete.createdRaces
   */
  export type Athlete$createdRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    cursor?: RaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Athlete.trainingPlans
   */
  export type Athlete$trainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    cursor?: TrainingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * Athlete.plannedDays
   */
  export type Athlete$plannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    cursor?: TrainingDayPlannedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * Athlete.executedDays
   */
  export type Athlete$executedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    cursor?: TrainingDayExecutedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * Athlete.founder
   */
  export type Athlete$founderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    where?: FounderWhereInput
  }

  /**
   * Athlete without action
   */
  export type AthleteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
  }


  /**
   * Model AthleteActivity
   */

  export type AggregateAthleteActivity = {
    _count: AthleteActivityCountAggregateOutputType | null
    _avg: AthleteActivityAvgAggregateOutputType | null
    _sum: AthleteActivitySumAggregateOutputType | null
    _min: AthleteActivityMinAggregateOutputType | null
    _max: AthleteActivityMaxAggregateOutputType | null
  }

  export type AthleteActivityAvgAggregateOutputType = {
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type AthleteActivitySumAggregateOutputType = {
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type AthleteActivityMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    sourceActivityId: string | null
    source: string | null
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    hydratedAt: Date | null
    syncedAt: Date | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteActivityMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    sourceActivityId: string | null
    source: string | null
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    hydratedAt: Date | null
    syncedAt: Date | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteActivityCountAggregateOutputType = {
    id: number
    athleteId: number
    sourceActivityId: number
    source: number
    activityType: number
    activityName: number
    startTime: number
    duration: number
    distance: number
    averageSpeed: number
    calories: number
    averageHeartRate: number
    maxHeartRate: number
    elevationGain: number
    steps: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    summaryPolyline: number
    deviceName: number
    garminUserId: number
    summaryData: number
    detailData: number
    hydratedAt: number
    syncedAt: number
    lastUpdatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AthleteActivityAvgAggregateInputType = {
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type AthleteActivitySumAggregateInputType = {
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type AthleteActivityMinAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteActivityMaxAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteActivityCountAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    summaryData?: true
    detailData?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AthleteActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleteActivity to aggregate.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AthleteActivities
    **/
    _count?: true | AthleteActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleteActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleteActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteActivityMaxAggregateInputType
  }

  export type GetAthleteActivityAggregateType<T extends AthleteActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateAthleteActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthleteActivity[P]>
      : GetScalarType<T[P], AggregateAthleteActivity[P]>
  }




  export type AthleteActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteActivityWhereInput
    orderBy?: AthleteActivityOrderByWithAggregationInput | AthleteActivityOrderByWithAggregationInput[]
    by: AthleteActivityScalarFieldEnum[] | AthleteActivityScalarFieldEnum
    having?: AthleteActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteActivityCountAggregateInputType | true
    _avg?: AthleteActivityAvgAggregateInputType
    _sum?: AthleteActivitySumAggregateInputType
    _min?: AthleteActivityMinAggregateInputType
    _max?: AthleteActivityMaxAggregateInputType
  }

  export type AthleteActivityGroupByOutputType = {
    id: string
    athleteId: string
    sourceActivityId: string
    source: string
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    summaryData: JsonValue | null
    detailData: JsonValue | null
    hydratedAt: Date | null
    syncedAt: Date
    lastUpdatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AthleteActivityCountAggregateOutputType | null
    _avg: AthleteActivityAvgAggregateOutputType | null
    _sum: AthleteActivitySumAggregateOutputType | null
    _min: AthleteActivityMinAggregateOutputType | null
    _max: AthleteActivityMaxAggregateOutputType | null
  }

  type GetAthleteActivityGroupByPayload<T extends AthleteActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleteActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteActivityGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteActivityGroupByOutputType[P]>
        }
      >
    >


  export type AthleteActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectScalar = {
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AthleteActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "sourceActivityId" | "source" | "activityType" | "activityName" | "startTime" | "duration" | "distance" | "averageSpeed" | "calories" | "averageHeartRate" | "maxHeartRate" | "elevationGain" | "steps" | "startLatitude" | "startLongitude" | "endLatitude" | "endLongitude" | "summaryPolyline" | "deviceName" | "garminUserId" | "summaryData" | "detailData" | "hydratedAt" | "syncedAt" | "lastUpdatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["athleteActivity"]>
  export type AthleteActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type AthleteActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type AthleteActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $AthleteActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AthleteActivity"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      sourceActivityId: string
      source: string
      activityType: string | null
      activityName: string | null
      startTime: Date | null
      duration: number | null
      distance: number | null
      averageSpeed: number | null
      calories: number | null
      averageHeartRate: number | null
      maxHeartRate: number | null
      elevationGain: number | null
      steps: number | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      summaryPolyline: string | null
      deviceName: string | null
      garminUserId: string | null
      summaryData: Prisma.JsonValue | null
      detailData: Prisma.JsonValue | null
      hydratedAt: Date | null
      syncedAt: Date
      lastUpdatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["athleteActivity"]>
    composites: {}
  }

  type AthleteActivityGetPayload<S extends boolean | null | undefined | AthleteActivityDefaultArgs> = $Result.GetResult<Prisma.$AthleteActivityPayload, S>

  type AthleteActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AthleteActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AthleteActivityCountAggregateInputType | true
    }

  export interface AthleteActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AthleteActivity'], meta: { name: 'AthleteActivity' } }
    /**
     * Find zero or one AthleteActivity that matches the filter.
     * @param {AthleteActivityFindUniqueArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AthleteActivityFindUniqueArgs>(args: SelectSubset<T, AthleteActivityFindUniqueArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AthleteActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AthleteActivityFindUniqueOrThrowArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AthleteActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, AthleteActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AthleteActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindFirstArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AthleteActivityFindFirstArgs>(args?: SelectSubset<T, AthleteActivityFindFirstArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AthleteActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindFirstOrThrowArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AthleteActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, AthleteActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AthleteActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AthleteActivities
     * const athleteActivities = await prisma.athleteActivity.findMany()
     * 
     * // Get first 10 AthleteActivities
     * const athleteActivities = await prisma.athleteActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AthleteActivityFindManyArgs>(args?: SelectSubset<T, AthleteActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AthleteActivity.
     * @param {AthleteActivityCreateArgs} args - Arguments to create a AthleteActivity.
     * @example
     * // Create one AthleteActivity
     * const AthleteActivity = await prisma.athleteActivity.create({
     *   data: {
     *     // ... data to create a AthleteActivity
     *   }
     * })
     * 
     */
    create<T extends AthleteActivityCreateArgs>(args: SelectSubset<T, AthleteActivityCreateArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AthleteActivities.
     * @param {AthleteActivityCreateManyArgs} args - Arguments to create many AthleteActivities.
     * @example
     * // Create many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AthleteActivityCreateManyArgs>(args?: SelectSubset<T, AthleteActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AthleteActivities and returns the data saved in the database.
     * @param {AthleteActivityCreateManyAndReturnArgs} args - Arguments to create many AthleteActivities.
     * @example
     * // Create many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AthleteActivities and only return the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AthleteActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, AthleteActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AthleteActivity.
     * @param {AthleteActivityDeleteArgs} args - Arguments to delete one AthleteActivity.
     * @example
     * // Delete one AthleteActivity
     * const AthleteActivity = await prisma.athleteActivity.delete({
     *   where: {
     *     // ... filter to delete one AthleteActivity
     *   }
     * })
     * 
     */
    delete<T extends AthleteActivityDeleteArgs>(args: SelectSubset<T, AthleteActivityDeleteArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AthleteActivity.
     * @param {AthleteActivityUpdateArgs} args - Arguments to update one AthleteActivity.
     * @example
     * // Update one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AthleteActivityUpdateArgs>(args: SelectSubset<T, AthleteActivityUpdateArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AthleteActivities.
     * @param {AthleteActivityDeleteManyArgs} args - Arguments to filter AthleteActivities to delete.
     * @example
     * // Delete a few AthleteActivities
     * const { count } = await prisma.athleteActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AthleteActivityDeleteManyArgs>(args?: SelectSubset<T, AthleteActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleteActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AthleteActivityUpdateManyArgs>(args: SelectSubset<T, AthleteActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleteActivities and returns the data updated in the database.
     * @param {AthleteActivityUpdateManyAndReturnArgs} args - Arguments to update many AthleteActivities.
     * @example
     * // Update many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AthleteActivities and only return the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AthleteActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, AthleteActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AthleteActivity.
     * @param {AthleteActivityUpsertArgs} args - Arguments to update or create a AthleteActivity.
     * @example
     * // Update or create a AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.upsert({
     *   create: {
     *     // ... data to create a AthleteActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AthleteActivity we want to update
     *   }
     * })
     */
    upsert<T extends AthleteActivityUpsertArgs>(args: SelectSubset<T, AthleteActivityUpsertArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AthleteActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityCountArgs} args - Arguments to filter AthleteActivities to count.
     * @example
     * // Count the number of AthleteActivities
     * const count = await prisma.athleteActivity.count({
     *   where: {
     *     // ... the filter for the AthleteActivities we want to count
     *   }
     * })
    **/
    count<T extends AthleteActivityCountArgs>(
      args?: Subset<T, AthleteActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AthleteActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteActivityAggregateArgs>(args: Subset<T, AthleteActivityAggregateArgs>): Prisma.PrismaPromise<GetAthleteActivityAggregateType<T>>

    /**
     * Group by AthleteActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteActivityGroupByArgs['orderBy'] }
        : { orderBy?: AthleteActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AthleteActivity model
   */
  readonly fields: AthleteActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AthleteActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleteActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AthleteActivity model
   */
  interface AthleteActivityFieldRefs {
    readonly id: FieldRef<"AthleteActivity", 'String'>
    readonly athleteId: FieldRef<"AthleteActivity", 'String'>
    readonly sourceActivityId: FieldRef<"AthleteActivity", 'String'>
    readonly source: FieldRef<"AthleteActivity", 'String'>
    readonly activityType: FieldRef<"AthleteActivity", 'String'>
    readonly activityName: FieldRef<"AthleteActivity", 'String'>
    readonly startTime: FieldRef<"AthleteActivity", 'DateTime'>
    readonly duration: FieldRef<"AthleteActivity", 'Int'>
    readonly distance: FieldRef<"AthleteActivity", 'Float'>
    readonly averageSpeed: FieldRef<"AthleteActivity", 'Float'>
    readonly calories: FieldRef<"AthleteActivity", 'Int'>
    readonly averageHeartRate: FieldRef<"AthleteActivity", 'Int'>
    readonly maxHeartRate: FieldRef<"AthleteActivity", 'Int'>
    readonly elevationGain: FieldRef<"AthleteActivity", 'Float'>
    readonly steps: FieldRef<"AthleteActivity", 'Int'>
    readonly startLatitude: FieldRef<"AthleteActivity", 'Float'>
    readonly startLongitude: FieldRef<"AthleteActivity", 'Float'>
    readonly endLatitude: FieldRef<"AthleteActivity", 'Float'>
    readonly endLongitude: FieldRef<"AthleteActivity", 'Float'>
    readonly summaryPolyline: FieldRef<"AthleteActivity", 'String'>
    readonly deviceName: FieldRef<"AthleteActivity", 'String'>
    readonly garminUserId: FieldRef<"AthleteActivity", 'String'>
    readonly summaryData: FieldRef<"AthleteActivity", 'Json'>
    readonly detailData: FieldRef<"AthleteActivity", 'Json'>
    readonly hydratedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly syncedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly lastUpdatedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly createdAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"AthleteActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AthleteActivity findUnique
   */
  export type AthleteActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity findUniqueOrThrow
   */
  export type AthleteActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity findFirst
   */
  export type AthleteActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleteActivities.
     */
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity findFirstOrThrow
   */
  export type AthleteActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleteActivities.
     */
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity findMany
   */
  export type AthleteActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivities to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity create
   */
  export type AthleteActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a AthleteActivity.
     */
    data: XOR<AthleteActivityCreateInput, AthleteActivityUncheckedCreateInput>
  }

  /**
   * AthleteActivity createMany
   */
  export type AthleteActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AthleteActivities.
     */
    data: AthleteActivityCreateManyInput | AthleteActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AthleteActivity createManyAndReturn
   */
  export type AthleteActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * The data used to create many AthleteActivities.
     */
    data: AthleteActivityCreateManyInput | AthleteActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleteActivity update
   */
  export type AthleteActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a AthleteActivity.
     */
    data: XOR<AthleteActivityUpdateInput, AthleteActivityUncheckedUpdateInput>
    /**
     * Choose, which AthleteActivity to update.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity updateMany
   */
  export type AthleteActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AthleteActivities.
     */
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyInput>
    /**
     * Filter which AthleteActivities to update
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to update.
     */
    limit?: number
  }

  /**
   * AthleteActivity updateManyAndReturn
   */
  export type AthleteActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * The data used to update AthleteActivities.
     */
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyInput>
    /**
     * Filter which AthleteActivities to update
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleteActivity upsert
   */
  export type AthleteActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the AthleteActivity to update in case it exists.
     */
    where: AthleteActivityWhereUniqueInput
    /**
     * In case the AthleteActivity found by the `where` argument doesn't exist, create a new AthleteActivity with this data.
     */
    create: XOR<AthleteActivityCreateInput, AthleteActivityUncheckedCreateInput>
    /**
     * In case the AthleteActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleteActivityUpdateInput, AthleteActivityUncheckedUpdateInput>
  }

  /**
   * AthleteActivity delete
   */
  export type AthleteActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter which AthleteActivity to delete.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity deleteMany
   */
  export type AthleteActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleteActivities to delete
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to delete.
     */
    limit?: number
  }

  /**
   * AthleteActivity without action
   */
  export type AthleteActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
  }


  /**
   * Model RunCrew
   */

  export type AggregateRunCrew = {
    _count: RunCrewCountAggregateOutputType | null
    _min: RunCrewMinAggregateOutputType | null
    _max: RunCrewMaxAggregateOutputType | null
  }

  export type RunCrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    joinCode: string | null
    logo: string | null
    runcrewAdminId: string | null
    isArchived: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    joinCode: string | null
    logo: string | null
    runcrewAdminId: string | null
    isArchived: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewCountAggregateOutputType = {
    id: number
    name: number
    description: number
    joinCode: number
    logo: number
    runcrewAdminId: number
    isArchived: number
    archivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrew to aggregate.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrews
    **/
    _count?: true | RunCrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewMaxAggregateInputType
  }

  export type GetRunCrewAggregateType<T extends RunCrewAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrew[P]>
      : GetScalarType<T[P], AggregateRunCrew[P]>
  }




  export type RunCrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewWhereInput
    orderBy?: RunCrewOrderByWithAggregationInput | RunCrewOrderByWithAggregationInput[]
    by: RunCrewScalarFieldEnum[] | RunCrewScalarFieldEnum
    having?: RunCrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewCountAggregateInputType | true
    _min?: RunCrewMinAggregateInputType
    _max?: RunCrewMaxAggregateInputType
  }

  export type RunCrewGroupByOutputType = {
    id: string
    name: string
    description: string | null
    joinCode: string
    logo: string | null
    runcrewAdminId: string
    isArchived: boolean
    archivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RunCrewCountAggregateOutputType | null
    _min: RunCrewMinAggregateOutputType | null
    _max: RunCrewMaxAggregateOutputType | null
  }

  type GetRunCrewGroupByPayload<T extends RunCrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
    memberships?: boolean | RunCrew$membershipsArgs<ExtArgs>
    posts?: boolean | RunCrew$postsArgs<ExtArgs>
    leaderboardEntries?: boolean | RunCrew$leaderboardEntriesArgs<ExtArgs>
    _count?: boolean | RunCrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "joinCode" | "logo" | "runcrewAdminId" | "isArchived" | "archivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrew"]>
  export type RunCrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
    memberships?: boolean | RunCrew$membershipsArgs<ExtArgs>
    posts?: boolean | RunCrew$postsArgs<ExtArgs>
    leaderboardEntries?: boolean | RunCrew$leaderboardEntriesArgs<ExtArgs>
    _count?: boolean | RunCrewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunCrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrew"
    objects: {
      admin: Prisma.$AthletePayload<ExtArgs>
      memberships: Prisma.$RunCrewMembershipPayload<ExtArgs>[]
      posts: Prisma.$RunCrewPostPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$RunCrewLeaderboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      joinCode: string
      logo: string | null
      runcrewAdminId: string
      isArchived: boolean
      archivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrew"]>
    composites: {}
  }

  type RunCrewGetPayload<S extends boolean | null | undefined | RunCrewDefaultArgs> = $Result.GetResult<Prisma.$RunCrewPayload, S>

  type RunCrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewCountAggregateInputType | true
    }

  export interface RunCrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrew'], meta: { name: 'RunCrew' } }
    /**
     * Find zero or one RunCrew that matches the filter.
     * @param {RunCrewFindUniqueArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewFindUniqueArgs>(args: SelectSubset<T, RunCrewFindUniqueArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrew that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewFindUniqueOrThrowArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindFirstArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewFindFirstArgs>(args?: SelectSubset<T, RunCrewFindFirstArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindFirstOrThrowArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrews
     * const runCrews = await prisma.runCrew.findMany()
     * 
     * // Get first 10 RunCrews
     * const runCrews = await prisma.runCrew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewFindManyArgs>(args?: SelectSubset<T, RunCrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrew.
     * @param {RunCrewCreateArgs} args - Arguments to create a RunCrew.
     * @example
     * // Create one RunCrew
     * const RunCrew = await prisma.runCrew.create({
     *   data: {
     *     // ... data to create a RunCrew
     *   }
     * })
     * 
     */
    create<T extends RunCrewCreateArgs>(args: SelectSubset<T, RunCrewCreateArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrews.
     * @param {RunCrewCreateManyArgs} args - Arguments to create many RunCrews.
     * @example
     * // Create many RunCrews
     * const runCrew = await prisma.runCrew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewCreateManyArgs>(args?: SelectSubset<T, RunCrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrews and returns the data saved in the database.
     * @param {RunCrewCreateManyAndReturnArgs} args - Arguments to create many RunCrews.
     * @example
     * // Create many RunCrews
     * const runCrew = await prisma.runCrew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrews and only return the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrew.
     * @param {RunCrewDeleteArgs} args - Arguments to delete one RunCrew.
     * @example
     * // Delete one RunCrew
     * const RunCrew = await prisma.runCrew.delete({
     *   where: {
     *     // ... filter to delete one RunCrew
     *   }
     * })
     * 
     */
    delete<T extends RunCrewDeleteArgs>(args: SelectSubset<T, RunCrewDeleteArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrew.
     * @param {RunCrewUpdateArgs} args - Arguments to update one RunCrew.
     * @example
     * // Update one RunCrew
     * const runCrew = await prisma.runCrew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewUpdateArgs>(args: SelectSubset<T, RunCrewUpdateArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrews.
     * @param {RunCrewDeleteManyArgs} args - Arguments to filter RunCrews to delete.
     * @example
     * // Delete a few RunCrews
     * const { count } = await prisma.runCrew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewDeleteManyArgs>(args?: SelectSubset<T, RunCrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrews
     * const runCrew = await prisma.runCrew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewUpdateManyArgs>(args: SelectSubset<T, RunCrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrews and returns the data updated in the database.
     * @param {RunCrewUpdateManyAndReturnArgs} args - Arguments to update many RunCrews.
     * @example
     * // Update many RunCrews
     * const runCrew = await prisma.runCrew.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrews and only return the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrew.
     * @param {RunCrewUpsertArgs} args - Arguments to update or create a RunCrew.
     * @example
     * // Update or create a RunCrew
     * const runCrew = await prisma.runCrew.upsert({
     *   create: {
     *     // ... data to create a RunCrew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrew we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewUpsertArgs>(args: SelectSubset<T, RunCrewUpsertArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewCountArgs} args - Arguments to filter RunCrews to count.
     * @example
     * // Count the number of RunCrews
     * const count = await prisma.runCrew.count({
     *   where: {
     *     // ... the filter for the RunCrews we want to count
     *   }
     * })
    **/
    count<T extends RunCrewCountArgs>(
      args?: Subset<T, RunCrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewAggregateArgs>(args: Subset<T, RunCrewAggregateArgs>): Prisma.PrismaPromise<GetRunCrewAggregateType<T>>

    /**
     * Group by RunCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrew model
   */
  readonly fields: RunCrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    memberships<T extends RunCrew$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends RunCrew$postsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboardEntries<T extends RunCrew$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrew model
   */
  interface RunCrewFieldRefs {
    readonly id: FieldRef<"RunCrew", 'String'>
    readonly name: FieldRef<"RunCrew", 'String'>
    readonly description: FieldRef<"RunCrew", 'String'>
    readonly joinCode: FieldRef<"RunCrew", 'String'>
    readonly logo: FieldRef<"RunCrew", 'String'>
    readonly runcrewAdminId: FieldRef<"RunCrew", 'String'>
    readonly isArchived: FieldRef<"RunCrew", 'Boolean'>
    readonly archivedAt: FieldRef<"RunCrew", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrew", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrew", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrew findUnique
   */
  export type RunCrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew findUniqueOrThrow
   */
  export type RunCrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew findFirst
   */
  export type RunCrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrews.
     */
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew findFirstOrThrow
   */
  export type RunCrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrews.
     */
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew findMany
   */
  export type RunCrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrews to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew create
   */
  export type RunCrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrew.
     */
    data: XOR<RunCrewCreateInput, RunCrewUncheckedCreateInput>
  }

  /**
   * RunCrew createMany
   */
  export type RunCrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrews.
     */
    data: RunCrewCreateManyInput | RunCrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrew createManyAndReturn
   */
  export type RunCrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrews.
     */
    data: RunCrewCreateManyInput | RunCrewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrew update
   */
  export type RunCrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrew.
     */
    data: XOR<RunCrewUpdateInput, RunCrewUncheckedUpdateInput>
    /**
     * Choose, which RunCrew to update.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew updateMany
   */
  export type RunCrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrews.
     */
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyInput>
    /**
     * Filter which RunCrews to update
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to update.
     */
    limit?: number
  }

  /**
   * RunCrew updateManyAndReturn
   */
  export type RunCrewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * The data used to update RunCrews.
     */
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyInput>
    /**
     * Filter which RunCrews to update
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrew upsert
   */
  export type RunCrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrew to update in case it exists.
     */
    where: RunCrewWhereUniqueInput
    /**
     * In case the RunCrew found by the `where` argument doesn't exist, create a new RunCrew with this data.
     */
    create: XOR<RunCrewCreateInput, RunCrewUncheckedCreateInput>
    /**
     * In case the RunCrew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewUpdateInput, RunCrewUncheckedUpdateInput>
  }

  /**
   * RunCrew delete
   */
  export type RunCrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter which RunCrew to delete.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew deleteMany
   */
  export type RunCrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrews to delete
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to delete.
     */
    limit?: number
  }

  /**
   * RunCrew.memberships
   */
  export type RunCrew$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    cursor?: RunCrewMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrew.posts
   */
  export type RunCrew$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    where?: RunCrewPostWhereInput
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    cursor?: RunCrewPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewPostScalarFieldEnum | RunCrewPostScalarFieldEnum[]
  }

  /**
   * RunCrew.leaderboardEntries
   */
  export type RunCrew$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    cursor?: RunCrewLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrew without action
   */
  export type RunCrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewMembership
   */

  export type AggregateRunCrewMembership = {
    _count: RunCrewMembershipCountAggregateOutputType | null
    _min: RunCrewMembershipMinAggregateOutputType | null
    _max: RunCrewMembershipMaxAggregateOutputType | null
  }

  export type RunCrewMembershipMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMembershipMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMembershipCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewMembershipMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMembershipMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMembershipCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMembership to aggregate.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewMemberships
    **/
    _count?: true | RunCrewMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewMembershipMaxAggregateInputType
  }

  export type GetRunCrewMembershipAggregateType<T extends RunCrewMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewMembership[P]>
      : GetScalarType<T[P], AggregateRunCrewMembership[P]>
  }




  export type RunCrewMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithAggregationInput | RunCrewMembershipOrderByWithAggregationInput[]
    by: RunCrewMembershipScalarFieldEnum[] | RunCrewMembershipScalarFieldEnum
    having?: RunCrewMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewMembershipCountAggregateInputType | true
    _min?: RunCrewMembershipMinAggregateInputType
    _max?: RunCrewMembershipMaxAggregateInputType
  }

  export type RunCrewMembershipGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    joinedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RunCrewMembershipCountAggregateOutputType | null
    _min: RunCrewMembershipMinAggregateOutputType | null
    _max: RunCrewMembershipMaxAggregateOutputType | null
  }

  type GetRunCrewMembershipGroupByPayload<T extends RunCrewMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewMembershipGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "joinedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewMembership"]>
  export type RunCrewMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewMembership"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      joinedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewMembership"]>
    composites: {}
  }

  type RunCrewMembershipGetPayload<S extends boolean | null | undefined | RunCrewMembershipDefaultArgs> = $Result.GetResult<Prisma.$RunCrewMembershipPayload, S>

  type RunCrewMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewMembershipCountAggregateInputType | true
    }

  export interface RunCrewMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewMembership'], meta: { name: 'RunCrewMembership' } }
    /**
     * Find zero or one RunCrewMembership that matches the filter.
     * @param {RunCrewMembershipFindUniqueArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewMembershipFindUniqueArgs>(args: SelectSubset<T, RunCrewMembershipFindUniqueArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewMembershipFindUniqueOrThrowArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindFirstArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewMembershipFindFirstArgs>(args?: SelectSubset<T, RunCrewMembershipFindFirstArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindFirstOrThrowArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewMemberships
     * const runCrewMemberships = await prisma.runCrewMembership.findMany()
     * 
     * // Get first 10 RunCrewMemberships
     * const runCrewMemberships = await prisma.runCrewMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewMembershipFindManyArgs>(args?: SelectSubset<T, RunCrewMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewMembership.
     * @param {RunCrewMembershipCreateArgs} args - Arguments to create a RunCrewMembership.
     * @example
     * // Create one RunCrewMembership
     * const RunCrewMembership = await prisma.runCrewMembership.create({
     *   data: {
     *     // ... data to create a RunCrewMembership
     *   }
     * })
     * 
     */
    create<T extends RunCrewMembershipCreateArgs>(args: SelectSubset<T, RunCrewMembershipCreateArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewMemberships.
     * @param {RunCrewMembershipCreateManyArgs} args - Arguments to create many RunCrewMemberships.
     * @example
     * // Create many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewMembershipCreateManyArgs>(args?: SelectSubset<T, RunCrewMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewMemberships and returns the data saved in the database.
     * @param {RunCrewMembershipCreateManyAndReturnArgs} args - Arguments to create many RunCrewMemberships.
     * @example
     * // Create many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewMemberships and only return the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewMembership.
     * @param {RunCrewMembershipDeleteArgs} args - Arguments to delete one RunCrewMembership.
     * @example
     * // Delete one RunCrewMembership
     * const RunCrewMembership = await prisma.runCrewMembership.delete({
     *   where: {
     *     // ... filter to delete one RunCrewMembership
     *   }
     * })
     * 
     */
    delete<T extends RunCrewMembershipDeleteArgs>(args: SelectSubset<T, RunCrewMembershipDeleteArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewMembership.
     * @param {RunCrewMembershipUpdateArgs} args - Arguments to update one RunCrewMembership.
     * @example
     * // Update one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewMembershipUpdateArgs>(args: SelectSubset<T, RunCrewMembershipUpdateArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewMemberships.
     * @param {RunCrewMembershipDeleteManyArgs} args - Arguments to filter RunCrewMemberships to delete.
     * @example
     * // Delete a few RunCrewMemberships
     * const { count } = await prisma.runCrewMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewMembershipDeleteManyArgs>(args?: SelectSubset<T, RunCrewMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewMembershipUpdateManyArgs>(args: SelectSubset<T, RunCrewMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMemberships and returns the data updated in the database.
     * @param {RunCrewMembershipUpdateManyAndReturnArgs} args - Arguments to update many RunCrewMemberships.
     * @example
     * // Update many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewMemberships and only return the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewMembership.
     * @param {RunCrewMembershipUpsertArgs} args - Arguments to update or create a RunCrewMembership.
     * @example
     * // Update or create a RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.upsert({
     *   create: {
     *     // ... data to create a RunCrewMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewMembership we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewMembershipUpsertArgs>(args: SelectSubset<T, RunCrewMembershipUpsertArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipCountArgs} args - Arguments to filter RunCrewMemberships to count.
     * @example
     * // Count the number of RunCrewMemberships
     * const count = await prisma.runCrewMembership.count({
     *   where: {
     *     // ... the filter for the RunCrewMemberships we want to count
     *   }
     * })
    **/
    count<T extends RunCrewMembershipCountArgs>(
      args?: Subset<T, RunCrewMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewMembershipAggregateArgs>(args: Subset<T, RunCrewMembershipAggregateArgs>): Prisma.PrismaPromise<GetRunCrewMembershipAggregateType<T>>

    /**
     * Group by RunCrewMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewMembershipGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewMembership model
   */
  readonly fields: RunCrewMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewMembership model
   */
  interface RunCrewMembershipFieldRefs {
    readonly id: FieldRef<"RunCrewMembership", 'String'>
    readonly runCrewId: FieldRef<"RunCrewMembership", 'String'>
    readonly athleteId: FieldRef<"RunCrewMembership", 'String'>
    readonly joinedAt: FieldRef<"RunCrewMembership", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrewMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewMembership findUnique
   */
  export type RunCrewMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership findUniqueOrThrow
   */
  export type RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership findFirst
   */
  export type RunCrewMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMemberships.
     */
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership findFirstOrThrow
   */
  export type RunCrewMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMemberships.
     */
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership findMany
   */
  export type RunCrewMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMemberships to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership create
   */
  export type RunCrewMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewMembership.
     */
    data: XOR<RunCrewMembershipCreateInput, RunCrewMembershipUncheckedCreateInput>
  }

  /**
   * RunCrewMembership createMany
   */
  export type RunCrewMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewMemberships.
     */
    data: RunCrewMembershipCreateManyInput | RunCrewMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewMembership createManyAndReturn
   */
  export type RunCrewMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewMemberships.
     */
    data: RunCrewMembershipCreateManyInput | RunCrewMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMembership update
   */
  export type RunCrewMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewMembership.
     */
    data: XOR<RunCrewMembershipUpdateInput, RunCrewMembershipUncheckedUpdateInput>
    /**
     * Choose, which RunCrewMembership to update.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership updateMany
   */
  export type RunCrewMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewMemberships.
     */
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMemberships to update
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to update.
     */
    limit?: number
  }

  /**
   * RunCrewMembership updateManyAndReturn
   */
  export type RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewMemberships.
     */
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMemberships to update
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMembership upsert
   */
  export type RunCrewMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewMembership to update in case it exists.
     */
    where: RunCrewMembershipWhereUniqueInput
    /**
     * In case the RunCrewMembership found by the `where` argument doesn't exist, create a new RunCrewMembership with this data.
     */
    create: XOR<RunCrewMembershipCreateInput, RunCrewMembershipUncheckedCreateInput>
    /**
     * In case the RunCrewMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewMembershipUpdateInput, RunCrewMembershipUncheckedUpdateInput>
  }

  /**
   * RunCrewMembership delete
   */
  export type RunCrewMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter which RunCrewMembership to delete.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership deleteMany
   */
  export type RunCrewMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMemberships to delete
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to delete.
     */
    limit?: number
  }

  /**
   * RunCrewMembership without action
   */
  export type RunCrewMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewPost
   */

  export type AggregateRunCrewPost = {
    _count: RunCrewPostCountAggregateOutputType | null
    _avg: RunCrewPostAvgAggregateOutputType | null
    _sum: RunCrewPostSumAggregateOutputType | null
    _min: RunCrewPostMinAggregateOutputType | null
    _max: RunCrewPostMaxAggregateOutputType | null
  }

  export type RunCrewPostAvgAggregateOutputType = {
    likes: number | null
  }

  export type RunCrewPostSumAggregateOutputType = {
    likes: number | null
  }

  export type RunCrewPostMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    content: string | null
    imageUrl: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewPostMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    content: string | null
    imageUrl: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewPostCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    content: number
    imageUrl: number
    likes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewPostAvgAggregateInputType = {
    likes?: true
  }

  export type RunCrewPostSumAggregateInputType = {
    likes?: true
  }

  export type RunCrewPostMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    imageUrl?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewPostMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    imageUrl?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewPostCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    imageUrl?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewPost to aggregate.
     */
    where?: RunCrewPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPosts to fetch.
     */
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewPosts
    **/
    _count?: true | RunCrewPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RunCrewPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RunCrewPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewPostMaxAggregateInputType
  }

  export type GetRunCrewPostAggregateType<T extends RunCrewPostAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewPost[P]>
      : GetScalarType<T[P], AggregateRunCrewPost[P]>
  }




  export type RunCrewPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostWhereInput
    orderBy?: RunCrewPostOrderByWithAggregationInput | RunCrewPostOrderByWithAggregationInput[]
    by: RunCrewPostScalarFieldEnum[] | RunCrewPostScalarFieldEnum
    having?: RunCrewPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewPostCountAggregateInputType | true
    _avg?: RunCrewPostAvgAggregateInputType
    _sum?: RunCrewPostSumAggregateInputType
    _min?: RunCrewPostMinAggregateInputType
    _max?: RunCrewPostMaxAggregateInputType
  }

  export type RunCrewPostGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    content: string
    imageUrl: string | null
    likes: number
    createdAt: Date
    updatedAt: Date
    _count: RunCrewPostCountAggregateOutputType | null
    _avg: RunCrewPostAvgAggregateOutputType | null
    _sum: RunCrewPostSumAggregateOutputType | null
    _min: RunCrewPostMinAggregateOutputType | null
    _max: RunCrewPostMaxAggregateOutputType | null
  }

  type GetRunCrewPostGroupByPayload<T extends RunCrewPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewPostGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewPostGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    imageUrl?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    comments?: boolean | RunCrewPost$commentsArgs<ExtArgs>
    _count?: boolean | RunCrewPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPost"]>

  export type RunCrewPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    imageUrl?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPost"]>

  export type RunCrewPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    imageUrl?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPost"]>

  export type RunCrewPostSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    imageUrl?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "content" | "imageUrl" | "likes" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewPost"]>
  export type RunCrewPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    comments?: boolean | RunCrewPost$commentsArgs<ExtArgs>
    _count?: boolean | RunCrewPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunCrewPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewPost"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
      comments: Prisma.$RunCrewPostCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      content: string
      imageUrl: string | null
      likes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewPost"]>
    composites: {}
  }

  type RunCrewPostGetPayload<S extends boolean | null | undefined | RunCrewPostDefaultArgs> = $Result.GetResult<Prisma.$RunCrewPostPayload, S>

  type RunCrewPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewPostCountAggregateInputType | true
    }

  export interface RunCrewPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewPost'], meta: { name: 'RunCrewPost' } }
    /**
     * Find zero or one RunCrewPost that matches the filter.
     * @param {RunCrewPostFindUniqueArgs} args - Arguments to find a RunCrewPost
     * @example
     * // Get one RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewPostFindUniqueArgs>(args: SelectSubset<T, RunCrewPostFindUniqueArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewPostFindUniqueOrThrowArgs} args - Arguments to find a RunCrewPost
     * @example
     * // Get one RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewPostFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostFindFirstArgs} args - Arguments to find a RunCrewPost
     * @example
     * // Get one RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewPostFindFirstArgs>(args?: SelectSubset<T, RunCrewPostFindFirstArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostFindFirstOrThrowArgs} args - Arguments to find a RunCrewPost
     * @example
     * // Get one RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewPostFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewPosts
     * const runCrewPosts = await prisma.runCrewPost.findMany()
     * 
     * // Get first 10 RunCrewPosts
     * const runCrewPosts = await prisma.runCrewPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewPostWithIdOnly = await prisma.runCrewPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewPostFindManyArgs>(args?: SelectSubset<T, RunCrewPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewPost.
     * @param {RunCrewPostCreateArgs} args - Arguments to create a RunCrewPost.
     * @example
     * // Create one RunCrewPost
     * const RunCrewPost = await prisma.runCrewPost.create({
     *   data: {
     *     // ... data to create a RunCrewPost
     *   }
     * })
     * 
     */
    create<T extends RunCrewPostCreateArgs>(args: SelectSubset<T, RunCrewPostCreateArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewPosts.
     * @param {RunCrewPostCreateManyArgs} args - Arguments to create many RunCrewPosts.
     * @example
     * // Create many RunCrewPosts
     * const runCrewPost = await prisma.runCrewPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewPostCreateManyArgs>(args?: SelectSubset<T, RunCrewPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewPosts and returns the data saved in the database.
     * @param {RunCrewPostCreateManyAndReturnArgs} args - Arguments to create many RunCrewPosts.
     * @example
     * // Create many RunCrewPosts
     * const runCrewPost = await prisma.runCrewPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewPosts and only return the `id`
     * const runCrewPostWithIdOnly = await prisma.runCrewPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewPostCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewPost.
     * @param {RunCrewPostDeleteArgs} args - Arguments to delete one RunCrewPost.
     * @example
     * // Delete one RunCrewPost
     * const RunCrewPost = await prisma.runCrewPost.delete({
     *   where: {
     *     // ... filter to delete one RunCrewPost
     *   }
     * })
     * 
     */
    delete<T extends RunCrewPostDeleteArgs>(args: SelectSubset<T, RunCrewPostDeleteArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewPost.
     * @param {RunCrewPostUpdateArgs} args - Arguments to update one RunCrewPost.
     * @example
     * // Update one RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewPostUpdateArgs>(args: SelectSubset<T, RunCrewPostUpdateArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewPosts.
     * @param {RunCrewPostDeleteManyArgs} args - Arguments to filter RunCrewPosts to delete.
     * @example
     * // Delete a few RunCrewPosts
     * const { count } = await prisma.runCrewPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewPostDeleteManyArgs>(args?: SelectSubset<T, RunCrewPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewPosts
     * const runCrewPost = await prisma.runCrewPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewPostUpdateManyArgs>(args: SelectSubset<T, RunCrewPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewPosts and returns the data updated in the database.
     * @param {RunCrewPostUpdateManyAndReturnArgs} args - Arguments to update many RunCrewPosts.
     * @example
     * // Update many RunCrewPosts
     * const runCrewPost = await prisma.runCrewPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewPosts and only return the `id`
     * const runCrewPostWithIdOnly = await prisma.runCrewPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewPostUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewPost.
     * @param {RunCrewPostUpsertArgs} args - Arguments to update or create a RunCrewPost.
     * @example
     * // Update or create a RunCrewPost
     * const runCrewPost = await prisma.runCrewPost.upsert({
     *   create: {
     *     // ... data to create a RunCrewPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewPost we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewPostUpsertArgs>(args: SelectSubset<T, RunCrewPostUpsertArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCountArgs} args - Arguments to filter RunCrewPosts to count.
     * @example
     * // Count the number of RunCrewPosts
     * const count = await prisma.runCrewPost.count({
     *   where: {
     *     // ... the filter for the RunCrewPosts we want to count
     *   }
     * })
    **/
    count<T extends RunCrewPostCountArgs>(
      args?: Subset<T, RunCrewPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewPostAggregateArgs>(args: Subset<T, RunCrewPostAggregateArgs>): Prisma.PrismaPromise<GetRunCrewPostAggregateType<T>>

    /**
     * Group by RunCrewPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewPostGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewPost model
   */
  readonly fields: RunCrewPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends RunCrewPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewPost model
   */
  interface RunCrewPostFieldRefs {
    readonly id: FieldRef<"RunCrewPost", 'String'>
    readonly runCrewId: FieldRef<"RunCrewPost", 'String'>
    readonly athleteId: FieldRef<"RunCrewPost", 'String'>
    readonly content: FieldRef<"RunCrewPost", 'String'>
    readonly imageUrl: FieldRef<"RunCrewPost", 'String'>
    readonly likes: FieldRef<"RunCrewPost", 'Int'>
    readonly createdAt: FieldRef<"RunCrewPost", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewPost findUnique
   */
  export type RunCrewPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPost to fetch.
     */
    where: RunCrewPostWhereUniqueInput
  }

  /**
   * RunCrewPost findUniqueOrThrow
   */
  export type RunCrewPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPost to fetch.
     */
    where: RunCrewPostWhereUniqueInput
  }

  /**
   * RunCrewPost findFirst
   */
  export type RunCrewPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPost to fetch.
     */
    where?: RunCrewPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPosts to fetch.
     */
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewPosts.
     */
    cursor?: RunCrewPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewPosts.
     */
    distinct?: RunCrewPostScalarFieldEnum | RunCrewPostScalarFieldEnum[]
  }

  /**
   * RunCrewPost findFirstOrThrow
   */
  export type RunCrewPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPost to fetch.
     */
    where?: RunCrewPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPosts to fetch.
     */
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewPosts.
     */
    cursor?: RunCrewPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewPosts.
     */
    distinct?: RunCrewPostScalarFieldEnum | RunCrewPostScalarFieldEnum[]
  }

  /**
   * RunCrewPost findMany
   */
  export type RunCrewPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPosts to fetch.
     */
    where?: RunCrewPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPosts to fetch.
     */
    orderBy?: RunCrewPostOrderByWithRelationInput | RunCrewPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewPosts.
     */
    cursor?: RunCrewPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPosts.
     */
    skip?: number
    distinct?: RunCrewPostScalarFieldEnum | RunCrewPostScalarFieldEnum[]
  }

  /**
   * RunCrewPost create
   */
  export type RunCrewPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewPost.
     */
    data: XOR<RunCrewPostCreateInput, RunCrewPostUncheckedCreateInput>
  }

  /**
   * RunCrewPost createMany
   */
  export type RunCrewPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewPosts.
     */
    data: RunCrewPostCreateManyInput | RunCrewPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewPost createManyAndReturn
   */
  export type RunCrewPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewPosts.
     */
    data: RunCrewPostCreateManyInput | RunCrewPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewPost update
   */
  export type RunCrewPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewPost.
     */
    data: XOR<RunCrewPostUpdateInput, RunCrewPostUncheckedUpdateInput>
    /**
     * Choose, which RunCrewPost to update.
     */
    where: RunCrewPostWhereUniqueInput
  }

  /**
   * RunCrewPost updateMany
   */
  export type RunCrewPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewPosts.
     */
    data: XOR<RunCrewPostUpdateManyMutationInput, RunCrewPostUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewPosts to update
     */
    where?: RunCrewPostWhereInput
    /**
     * Limit how many RunCrewPosts to update.
     */
    limit?: number
  }

  /**
   * RunCrewPost updateManyAndReturn
   */
  export type RunCrewPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewPosts.
     */
    data: XOR<RunCrewPostUpdateManyMutationInput, RunCrewPostUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewPosts to update
     */
    where?: RunCrewPostWhereInput
    /**
     * Limit how many RunCrewPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewPost upsert
   */
  export type RunCrewPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewPost to update in case it exists.
     */
    where: RunCrewPostWhereUniqueInput
    /**
     * In case the RunCrewPost found by the `where` argument doesn't exist, create a new RunCrewPost with this data.
     */
    create: XOR<RunCrewPostCreateInput, RunCrewPostUncheckedCreateInput>
    /**
     * In case the RunCrewPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewPostUpdateInput, RunCrewPostUncheckedUpdateInput>
  }

  /**
   * RunCrewPost delete
   */
  export type RunCrewPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
    /**
     * Filter which RunCrewPost to delete.
     */
    where: RunCrewPostWhereUniqueInput
  }

  /**
   * RunCrewPost deleteMany
   */
  export type RunCrewPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewPosts to delete
     */
    where?: RunCrewPostWhereInput
    /**
     * Limit how many RunCrewPosts to delete.
     */
    limit?: number
  }

  /**
   * RunCrewPost.comments
   */
  export type RunCrewPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    where?: RunCrewPostCommentWhereInput
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    cursor?: RunCrewPostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewPostCommentScalarFieldEnum | RunCrewPostCommentScalarFieldEnum[]
  }

  /**
   * RunCrewPost without action
   */
  export type RunCrewPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPost
     */
    select?: RunCrewPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPost
     */
    omit?: RunCrewPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewPostComment
   */

  export type AggregateRunCrewPostComment = {
    _count: RunCrewPostCommentCountAggregateOutputType | null
    _min: RunCrewPostCommentMinAggregateOutputType | null
    _max: RunCrewPostCommentMaxAggregateOutputType | null
  }

  export type RunCrewPostCommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    athleteId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewPostCommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    athleteId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewPostCommentCountAggregateOutputType = {
    id: number
    postId: number
    athleteId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewPostCommentMinAggregateInputType = {
    id?: true
    postId?: true
    athleteId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewPostCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    athleteId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewPostCommentCountAggregateInputType = {
    id?: true
    postId?: true
    athleteId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewPostCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewPostComment to aggregate.
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPostComments to fetch.
     */
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewPostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewPostComments
    **/
    _count?: true | RunCrewPostCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewPostCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewPostCommentMaxAggregateInputType
  }

  export type GetRunCrewPostCommentAggregateType<T extends RunCrewPostCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewPostComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewPostComment[P]>
      : GetScalarType<T[P], AggregateRunCrewPostComment[P]>
  }




  export type RunCrewPostCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewPostCommentWhereInput
    orderBy?: RunCrewPostCommentOrderByWithAggregationInput | RunCrewPostCommentOrderByWithAggregationInput[]
    by: RunCrewPostCommentScalarFieldEnum[] | RunCrewPostCommentScalarFieldEnum
    having?: RunCrewPostCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewPostCommentCountAggregateInputType | true
    _min?: RunCrewPostCommentMinAggregateInputType
    _max?: RunCrewPostCommentMaxAggregateInputType
  }

  export type RunCrewPostCommentGroupByOutputType = {
    id: string
    postId: string
    athleteId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: RunCrewPostCommentCountAggregateOutputType | null
    _min: RunCrewPostCommentMinAggregateOutputType | null
    _max: RunCrewPostCommentMaxAggregateOutputType | null
  }

  type GetRunCrewPostCommentGroupByPayload<T extends RunCrewPostCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewPostCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewPostCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewPostCommentGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewPostCommentGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewPostCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPostComment"]>

  export type RunCrewPostCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPostComment"]>

  export type RunCrewPostCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewPostComment"]>

  export type RunCrewPostCommentSelectScalar = {
    id?: boolean
    postId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewPostCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "athleteId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewPostComment"]>
  export type RunCrewPostCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewPostCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewPostCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | RunCrewPostDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewPostCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewPostComment"
    objects: {
      post: Prisma.$RunCrewPostPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      athleteId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewPostComment"]>
    composites: {}
  }

  type RunCrewPostCommentGetPayload<S extends boolean | null | undefined | RunCrewPostCommentDefaultArgs> = $Result.GetResult<Prisma.$RunCrewPostCommentPayload, S>

  type RunCrewPostCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewPostCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewPostCommentCountAggregateInputType | true
    }

  export interface RunCrewPostCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewPostComment'], meta: { name: 'RunCrewPostComment' } }
    /**
     * Find zero or one RunCrewPostComment that matches the filter.
     * @param {RunCrewPostCommentFindUniqueArgs} args - Arguments to find a RunCrewPostComment
     * @example
     * // Get one RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewPostCommentFindUniqueArgs>(args: SelectSubset<T, RunCrewPostCommentFindUniqueArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewPostComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewPostCommentFindUniqueOrThrowArgs} args - Arguments to find a RunCrewPostComment
     * @example
     * // Get one RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewPostCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewPostCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewPostComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentFindFirstArgs} args - Arguments to find a RunCrewPostComment
     * @example
     * // Get one RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewPostCommentFindFirstArgs>(args?: SelectSubset<T, RunCrewPostCommentFindFirstArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewPostComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentFindFirstOrThrowArgs} args - Arguments to find a RunCrewPostComment
     * @example
     * // Get one RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewPostCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewPostCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewPostComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewPostComments
     * const runCrewPostComments = await prisma.runCrewPostComment.findMany()
     * 
     * // Get first 10 RunCrewPostComments
     * const runCrewPostComments = await prisma.runCrewPostComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewPostCommentWithIdOnly = await prisma.runCrewPostComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewPostCommentFindManyArgs>(args?: SelectSubset<T, RunCrewPostCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewPostComment.
     * @param {RunCrewPostCommentCreateArgs} args - Arguments to create a RunCrewPostComment.
     * @example
     * // Create one RunCrewPostComment
     * const RunCrewPostComment = await prisma.runCrewPostComment.create({
     *   data: {
     *     // ... data to create a RunCrewPostComment
     *   }
     * })
     * 
     */
    create<T extends RunCrewPostCommentCreateArgs>(args: SelectSubset<T, RunCrewPostCommentCreateArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewPostComments.
     * @param {RunCrewPostCommentCreateManyArgs} args - Arguments to create many RunCrewPostComments.
     * @example
     * // Create many RunCrewPostComments
     * const runCrewPostComment = await prisma.runCrewPostComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewPostCommentCreateManyArgs>(args?: SelectSubset<T, RunCrewPostCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewPostComments and returns the data saved in the database.
     * @param {RunCrewPostCommentCreateManyAndReturnArgs} args - Arguments to create many RunCrewPostComments.
     * @example
     * // Create many RunCrewPostComments
     * const runCrewPostComment = await prisma.runCrewPostComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewPostComments and only return the `id`
     * const runCrewPostCommentWithIdOnly = await prisma.runCrewPostComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewPostCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewPostCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewPostComment.
     * @param {RunCrewPostCommentDeleteArgs} args - Arguments to delete one RunCrewPostComment.
     * @example
     * // Delete one RunCrewPostComment
     * const RunCrewPostComment = await prisma.runCrewPostComment.delete({
     *   where: {
     *     // ... filter to delete one RunCrewPostComment
     *   }
     * })
     * 
     */
    delete<T extends RunCrewPostCommentDeleteArgs>(args: SelectSubset<T, RunCrewPostCommentDeleteArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewPostComment.
     * @param {RunCrewPostCommentUpdateArgs} args - Arguments to update one RunCrewPostComment.
     * @example
     * // Update one RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewPostCommentUpdateArgs>(args: SelectSubset<T, RunCrewPostCommentUpdateArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewPostComments.
     * @param {RunCrewPostCommentDeleteManyArgs} args - Arguments to filter RunCrewPostComments to delete.
     * @example
     * // Delete a few RunCrewPostComments
     * const { count } = await prisma.runCrewPostComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewPostCommentDeleteManyArgs>(args?: SelectSubset<T, RunCrewPostCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewPostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewPostComments
     * const runCrewPostComment = await prisma.runCrewPostComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewPostCommentUpdateManyArgs>(args: SelectSubset<T, RunCrewPostCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewPostComments and returns the data updated in the database.
     * @param {RunCrewPostCommentUpdateManyAndReturnArgs} args - Arguments to update many RunCrewPostComments.
     * @example
     * // Update many RunCrewPostComments
     * const runCrewPostComment = await prisma.runCrewPostComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewPostComments and only return the `id`
     * const runCrewPostCommentWithIdOnly = await prisma.runCrewPostComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewPostCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewPostCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewPostComment.
     * @param {RunCrewPostCommentUpsertArgs} args - Arguments to update or create a RunCrewPostComment.
     * @example
     * // Update or create a RunCrewPostComment
     * const runCrewPostComment = await prisma.runCrewPostComment.upsert({
     *   create: {
     *     // ... data to create a RunCrewPostComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewPostComment we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewPostCommentUpsertArgs>(args: SelectSubset<T, RunCrewPostCommentUpsertArgs<ExtArgs>>): Prisma__RunCrewPostCommentClient<$Result.GetResult<Prisma.$RunCrewPostCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewPostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentCountArgs} args - Arguments to filter RunCrewPostComments to count.
     * @example
     * // Count the number of RunCrewPostComments
     * const count = await prisma.runCrewPostComment.count({
     *   where: {
     *     // ... the filter for the RunCrewPostComments we want to count
     *   }
     * })
    **/
    count<T extends RunCrewPostCommentCountArgs>(
      args?: Subset<T, RunCrewPostCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewPostCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewPostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewPostCommentAggregateArgs>(args: Subset<T, RunCrewPostCommentAggregateArgs>): Prisma.PrismaPromise<GetRunCrewPostCommentAggregateType<T>>

    /**
     * Group by RunCrewPostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewPostCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewPostCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewPostCommentGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewPostCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewPostCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewPostCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewPostComment model
   */
  readonly fields: RunCrewPostCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewPostComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewPostCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends RunCrewPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewPostDefaultArgs<ExtArgs>>): Prisma__RunCrewPostClient<$Result.GetResult<Prisma.$RunCrewPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewPostComment model
   */
  interface RunCrewPostCommentFieldRefs {
    readonly id: FieldRef<"RunCrewPostComment", 'String'>
    readonly postId: FieldRef<"RunCrewPostComment", 'String'>
    readonly athleteId: FieldRef<"RunCrewPostComment", 'String'>
    readonly content: FieldRef<"RunCrewPostComment", 'String'>
    readonly createdAt: FieldRef<"RunCrewPostComment", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewPostComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewPostComment findUnique
   */
  export type RunCrewPostCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPostComment to fetch.
     */
    where: RunCrewPostCommentWhereUniqueInput
  }

  /**
   * RunCrewPostComment findUniqueOrThrow
   */
  export type RunCrewPostCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPostComment to fetch.
     */
    where: RunCrewPostCommentWhereUniqueInput
  }

  /**
   * RunCrewPostComment findFirst
   */
  export type RunCrewPostCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPostComment to fetch.
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPostComments to fetch.
     */
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewPostComments.
     */
    cursor?: RunCrewPostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewPostComments.
     */
    distinct?: RunCrewPostCommentScalarFieldEnum | RunCrewPostCommentScalarFieldEnum[]
  }

  /**
   * RunCrewPostComment findFirstOrThrow
   */
  export type RunCrewPostCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPostComment to fetch.
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPostComments to fetch.
     */
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewPostComments.
     */
    cursor?: RunCrewPostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewPostComments.
     */
    distinct?: RunCrewPostCommentScalarFieldEnum | RunCrewPostCommentScalarFieldEnum[]
  }

  /**
   * RunCrewPostComment findMany
   */
  export type RunCrewPostCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewPostComments to fetch.
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewPostComments to fetch.
     */
    orderBy?: RunCrewPostCommentOrderByWithRelationInput | RunCrewPostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewPostComments.
     */
    cursor?: RunCrewPostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewPostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewPostComments.
     */
    skip?: number
    distinct?: RunCrewPostCommentScalarFieldEnum | RunCrewPostCommentScalarFieldEnum[]
  }

  /**
   * RunCrewPostComment create
   */
  export type RunCrewPostCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewPostComment.
     */
    data: XOR<RunCrewPostCommentCreateInput, RunCrewPostCommentUncheckedCreateInput>
  }

  /**
   * RunCrewPostComment createMany
   */
  export type RunCrewPostCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewPostComments.
     */
    data: RunCrewPostCommentCreateManyInput | RunCrewPostCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewPostComment createManyAndReturn
   */
  export type RunCrewPostCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewPostComments.
     */
    data: RunCrewPostCommentCreateManyInput | RunCrewPostCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewPostComment update
   */
  export type RunCrewPostCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewPostComment.
     */
    data: XOR<RunCrewPostCommentUpdateInput, RunCrewPostCommentUncheckedUpdateInput>
    /**
     * Choose, which RunCrewPostComment to update.
     */
    where: RunCrewPostCommentWhereUniqueInput
  }

  /**
   * RunCrewPostComment updateMany
   */
  export type RunCrewPostCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewPostComments.
     */
    data: XOR<RunCrewPostCommentUpdateManyMutationInput, RunCrewPostCommentUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewPostComments to update
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * Limit how many RunCrewPostComments to update.
     */
    limit?: number
  }

  /**
   * RunCrewPostComment updateManyAndReturn
   */
  export type RunCrewPostCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewPostComments.
     */
    data: XOR<RunCrewPostCommentUpdateManyMutationInput, RunCrewPostCommentUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewPostComments to update
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * Limit how many RunCrewPostComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewPostComment upsert
   */
  export type RunCrewPostCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewPostComment to update in case it exists.
     */
    where: RunCrewPostCommentWhereUniqueInput
    /**
     * In case the RunCrewPostComment found by the `where` argument doesn't exist, create a new RunCrewPostComment with this data.
     */
    create: XOR<RunCrewPostCommentCreateInput, RunCrewPostCommentUncheckedCreateInput>
    /**
     * In case the RunCrewPostComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewPostCommentUpdateInput, RunCrewPostCommentUncheckedUpdateInput>
  }

  /**
   * RunCrewPostComment delete
   */
  export type RunCrewPostCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
    /**
     * Filter which RunCrewPostComment to delete.
     */
    where: RunCrewPostCommentWhereUniqueInput
  }

  /**
   * RunCrewPostComment deleteMany
   */
  export type RunCrewPostCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewPostComments to delete
     */
    where?: RunCrewPostCommentWhereInput
    /**
     * Limit how many RunCrewPostComments to delete.
     */
    limit?: number
  }

  /**
   * RunCrewPostComment without action
   */
  export type RunCrewPostCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewPostComment
     */
    select?: RunCrewPostCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewPostComment
     */
    omit?: RunCrewPostCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewPostCommentInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewLeaderboard
   */

  export type AggregateRunCrewLeaderboard = {
    _count: RunCrewLeaderboardCountAggregateOutputType | null
    _avg: RunCrewLeaderboardAvgAggregateOutputType | null
    _sum: RunCrewLeaderboardSumAggregateOutputType | null
    _min: RunCrewLeaderboardMinAggregateOutputType | null
    _max: RunCrewLeaderboardMaxAggregateOutputType | null
  }

  export type RunCrewLeaderboardAvgAggregateOutputType = {
    totalMiles: number | null
    totalRuns: number | null
    totalCalories: number | null
    totalElevation: number | null
  }

  export type RunCrewLeaderboardSumAggregateOutputType = {
    totalMiles: number | null
    totalRuns: number | null
    totalCalories: number | null
    totalElevation: number | null
  }

  export type RunCrewLeaderboardMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalMiles: number | null
    totalRuns: number | null
    bestPace: string | null
    totalCalories: number | null
    totalElevation: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewLeaderboardMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalMiles: number | null
    totalRuns: number | null
    bestPace: string | null
    totalCalories: number | null
    totalElevation: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewLeaderboardCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    period: number
    periodStart: number
    periodEnd: number
    totalMiles: number
    totalRuns: number
    bestPace: number
    totalCalories: number
    totalElevation: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewLeaderboardAvgAggregateInputType = {
    totalMiles?: true
    totalRuns?: true
    totalCalories?: true
    totalElevation?: true
  }

  export type RunCrewLeaderboardSumAggregateInputType = {
    totalMiles?: true
    totalRuns?: true
    totalCalories?: true
    totalElevation?: true
  }

  export type RunCrewLeaderboardMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewLeaderboardMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewLeaderboardCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewLeaderboard to aggregate.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewLeaderboards
    **/
    _count?: true | RunCrewLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RunCrewLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RunCrewLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewLeaderboardMaxAggregateInputType
  }

  export type GetRunCrewLeaderboardAggregateType<T extends RunCrewLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewLeaderboard[P]>
      : GetScalarType<T[P], AggregateRunCrewLeaderboard[P]>
  }




  export type RunCrewLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithAggregationInput | RunCrewLeaderboardOrderByWithAggregationInput[]
    by: RunCrewLeaderboardScalarFieldEnum[] | RunCrewLeaderboardScalarFieldEnum
    having?: RunCrewLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewLeaderboardCountAggregateInputType | true
    _avg?: RunCrewLeaderboardAvgAggregateInputType
    _sum?: RunCrewLeaderboardSumAggregateInputType
    _min?: RunCrewLeaderboardMinAggregateInputType
    _max?: RunCrewLeaderboardMaxAggregateInputType
  }

  export type RunCrewLeaderboardGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date
    periodEnd: Date
    totalMiles: number
    totalRuns: number
    bestPace: string | null
    totalCalories: number
    totalElevation: number
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RunCrewLeaderboardCountAggregateOutputType | null
    _avg: RunCrewLeaderboardAvgAggregateOutputType | null
    _sum: RunCrewLeaderboardSumAggregateOutputType | null
    _min: RunCrewLeaderboardMinAggregateOutputType | null
    _max: RunCrewLeaderboardMaxAggregateOutputType | null
  }

  type GetRunCrewLeaderboardGroupByPayload<T extends RunCrewLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "period" | "periodStart" | "periodEnd" | "totalMiles" | "totalRuns" | "bestPace" | "totalCalories" | "totalElevation" | "calculatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewLeaderboard"]>
  export type RunCrewLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewLeaderboard"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      period: string
      periodStart: Date
      periodEnd: Date
      totalMiles: number
      totalRuns: number
      bestPace: string | null
      totalCalories: number
      totalElevation: number
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewLeaderboard"]>
    composites: {}
  }

  type RunCrewLeaderboardGetPayload<S extends boolean | null | undefined | RunCrewLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$RunCrewLeaderboardPayload, S>

  type RunCrewLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewLeaderboardCountAggregateInputType | true
    }

  export interface RunCrewLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewLeaderboard'], meta: { name: 'RunCrewLeaderboard' } }
    /**
     * Find zero or one RunCrewLeaderboard that matches the filter.
     * @param {RunCrewLeaderboardFindUniqueArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewLeaderboardFindUniqueArgs>(args: SelectSubset<T, RunCrewLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindFirstArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewLeaderboardFindFirstArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindFirstArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindFirstOrThrowArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewLeaderboards
     * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany()
     * 
     * // Get first 10 RunCrewLeaderboards
     * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewLeaderboardFindManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewLeaderboard.
     * @param {RunCrewLeaderboardCreateArgs} args - Arguments to create a RunCrewLeaderboard.
     * @example
     * // Create one RunCrewLeaderboard
     * const RunCrewLeaderboard = await prisma.runCrewLeaderboard.create({
     *   data: {
     *     // ... data to create a RunCrewLeaderboard
     *   }
     * })
     * 
     */
    create<T extends RunCrewLeaderboardCreateArgs>(args: SelectSubset<T, RunCrewLeaderboardCreateArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewLeaderboards.
     * @param {RunCrewLeaderboardCreateManyArgs} args - Arguments to create many RunCrewLeaderboards.
     * @example
     * // Create many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewLeaderboardCreateManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewLeaderboards and returns the data saved in the database.
     * @param {RunCrewLeaderboardCreateManyAndReturnArgs} args - Arguments to create many RunCrewLeaderboards.
     * @example
     * // Create many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewLeaderboards and only return the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewLeaderboard.
     * @param {RunCrewLeaderboardDeleteArgs} args - Arguments to delete one RunCrewLeaderboard.
     * @example
     * // Delete one RunCrewLeaderboard
     * const RunCrewLeaderboard = await prisma.runCrewLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one RunCrewLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends RunCrewLeaderboardDeleteArgs>(args: SelectSubset<T, RunCrewLeaderboardDeleteArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewLeaderboard.
     * @param {RunCrewLeaderboardUpdateArgs} args - Arguments to update one RunCrewLeaderboard.
     * @example
     * // Update one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewLeaderboardUpdateArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewLeaderboards.
     * @param {RunCrewLeaderboardDeleteManyArgs} args - Arguments to filter RunCrewLeaderboards to delete.
     * @example
     * // Delete a few RunCrewLeaderboards
     * const { count } = await prisma.runCrewLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewLeaderboardDeleteManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewLeaderboardUpdateManyArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewLeaderboards and returns the data updated in the database.
     * @param {RunCrewLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many RunCrewLeaderboards.
     * @example
     * // Update many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewLeaderboards and only return the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewLeaderboard.
     * @param {RunCrewLeaderboardUpsertArgs} args - Arguments to update or create a RunCrewLeaderboard.
     * @example
     * // Update or create a RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.upsert({
     *   create: {
     *     // ... data to create a RunCrewLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewLeaderboardUpsertArgs>(args: SelectSubset<T, RunCrewLeaderboardUpsertArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardCountArgs} args - Arguments to filter RunCrewLeaderboards to count.
     * @example
     * // Count the number of RunCrewLeaderboards
     * const count = await prisma.runCrewLeaderboard.count({
     *   where: {
     *     // ... the filter for the RunCrewLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends RunCrewLeaderboardCountArgs>(
      args?: Subset<T, RunCrewLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewLeaderboardAggregateArgs>(args: Subset<T, RunCrewLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetRunCrewLeaderboardAggregateType<T>>

    /**
     * Group by RunCrewLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewLeaderboard model
   */
  readonly fields: RunCrewLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewLeaderboard model
   */
  interface RunCrewLeaderboardFieldRefs {
    readonly id: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly runCrewId: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly athleteId: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly period: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly periodStart: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly periodEnd: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly totalMiles: FieldRef<"RunCrewLeaderboard", 'Float'>
    readonly totalRuns: FieldRef<"RunCrewLeaderboard", 'Int'>
    readonly bestPace: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly totalCalories: FieldRef<"RunCrewLeaderboard", 'Int'>
    readonly totalElevation: FieldRef<"RunCrewLeaderboard", 'Float'>
    readonly calculatedAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewLeaderboard findUnique
   */
  export type RunCrewLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard findUniqueOrThrow
   */
  export type RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard findFirst
   */
  export type RunCrewLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewLeaderboards.
     */
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard findFirstOrThrow
   */
  export type RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewLeaderboards.
     */
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard findMany
   */
  export type RunCrewLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboards to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard create
   */
  export type RunCrewLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewLeaderboard.
     */
    data: XOR<RunCrewLeaderboardCreateInput, RunCrewLeaderboardUncheckedCreateInput>
  }

  /**
   * RunCrewLeaderboard createMany
   */
  export type RunCrewLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewLeaderboards.
     */
    data: RunCrewLeaderboardCreateManyInput | RunCrewLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewLeaderboard createManyAndReturn
   */
  export type RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewLeaderboards.
     */
    data: RunCrewLeaderboardCreateManyInput | RunCrewLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewLeaderboard update
   */
  export type RunCrewLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewLeaderboard.
     */
    data: XOR<RunCrewLeaderboardUpdateInput, RunCrewLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which RunCrewLeaderboard to update.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard updateMany
   */
  export type RunCrewLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewLeaderboards.
     */
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewLeaderboards to update
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to update.
     */
    limit?: number
  }

  /**
   * RunCrewLeaderboard updateManyAndReturn
   */
  export type RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewLeaderboards.
     */
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewLeaderboards to update
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewLeaderboard upsert
   */
  export type RunCrewLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewLeaderboard to update in case it exists.
     */
    where: RunCrewLeaderboardWhereUniqueInput
    /**
     * In case the RunCrewLeaderboard found by the `where` argument doesn't exist, create a new RunCrewLeaderboard with this data.
     */
    create: XOR<RunCrewLeaderboardCreateInput, RunCrewLeaderboardUncheckedCreateInput>
    /**
     * In case the RunCrewLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewLeaderboardUpdateInput, RunCrewLeaderboardUncheckedUpdateInput>
  }

  /**
   * RunCrewLeaderboard delete
   */
  export type RunCrewLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which RunCrewLeaderboard to delete.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard deleteMany
   */
  export type RunCrewLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewLeaderboards to delete
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * RunCrewLeaderboard without action
   */
  export type RunCrewLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    distanceMiles: number | null
  }

  export type RaceSumAggregateOutputType = {
    distanceMiles: number | null
  }

  export type RaceMinAggregateOutputType = {
    id: string | null
    raceName: string | null
    raceType: string | null
    raceDate: Date | null
    location: string | null
    distanceMiles: number | null
    registrationUrl: string | null
    description: string | null
    createdByAthleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceMaxAggregateOutputType = {
    id: string | null
    raceName: string | null
    raceType: string | null
    raceDate: Date | null
    location: string | null
    distanceMiles: number | null
    registrationUrl: string | null
    description: string | null
    createdByAthleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    raceName: number
    raceType: number
    raceDate: number
    location: number
    distanceMiles: number
    registrationUrl: number
    description: number
    courseProfile: number
    createdByAthleteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    distanceMiles?: true
  }

  export type RaceSumAggregateInputType = {
    distanceMiles?: true
  }

  export type RaceMinAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    courseProfile?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: string
    raceName: string
    raceType: string
    raceDate: Date
    location: string | null
    distanceMiles: number
    registrationUrl: string | null
    description: string | null
    courseProfile: JsonValue | null
    createdByAthleteId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
    trainingPlans?: boolean | Race$trainingPlansArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raceName" | "raceType" | "raceDate" | "location" | "distanceMiles" | "registrationUrl" | "description" | "courseProfile" | "createdByAthleteId" | "createdAt" | "updatedAt", ExtArgs["result"]["race"]>
  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
    trainingPlans?: boolean | Race$trainingPlansArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }
  export type RaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      createdByAthlete: Prisma.$AthletePayload<ExtArgs> | null
      trainingPlans: Prisma.$TrainingPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      raceName: string
      raceType: string
      raceDate: Date
      location: string | null
      distanceMiles: number
      registrationUrl: string | null
      description: string | null
      courseProfile: Prisma.JsonValue | null
      createdByAthleteId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races and returns the data updated in the database.
     * @param {RaceUpdateManyAndReturnArgs} args - Arguments to update many Races.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByAthlete<T extends Race$createdByAthleteArgs<ExtArgs> = {}>(args?: Subset<T, Race$createdByAthleteArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trainingPlans<T extends Race$trainingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Race$trainingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'String'>
    readonly raceName: FieldRef<"Race", 'String'>
    readonly raceType: FieldRef<"Race", 'String'>
    readonly raceDate: FieldRef<"Race", 'DateTime'>
    readonly location: FieldRef<"Race", 'String'>
    readonly distanceMiles: FieldRef<"Race", 'Float'>
    readonly registrationUrl: FieldRef<"Race", 'String'>
    readonly description: FieldRef<"Race", 'String'>
    readonly courseProfile: FieldRef<"Race", 'Json'>
    readonly createdByAthleteId: FieldRef<"Race", 'String'>
    readonly createdAt: FieldRef<"Race", 'DateTime'>
    readonly updatedAt: FieldRef<"Race", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race updateManyAndReturn
   */
  export type RaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to delete.
     */
    limit?: number
  }

  /**
   * Race.createdByAthlete
   */
  export type Race$createdByAthleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    where?: AthleteWhereInput
  }

  /**
   * Race.trainingPlans
   */
  export type Race$trainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    cursor?: TrainingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPlan
   */

  export type AggregateTrainingPlan = {
    _count: TrainingPlanCountAggregateOutputType | null
    _avg: TrainingPlanAvgAggregateOutputType | null
    _sum: TrainingPlanSumAggregateOutputType | null
    _min: TrainingPlanMinAggregateOutputType | null
    _max: TrainingPlanMaxAggregateOutputType | null
  }

  export type TrainingPlanAvgAggregateOutputType = {
    baselineWeeklyMileage: number | null
    totalWeeks: number | null
  }

  export type TrainingPlanSumAggregateOutputType = {
    baselineWeeklyMileage: number | null
    totalWeeks: number | null
  }

  export type TrainingPlanMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    raceId: string | null
    goalTime: string | null
    goalPace: string | null
    baseline5k: string | null
    baselineWeeklyMileage: number | null
    startDate: Date | null
    totalWeeks: number | null
    adaptive5kTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    raceId: string | null
    goalTime: string | null
    goalPace: string | null
    baseline5k: string | null
    baselineWeeklyMileage: number | null
    startDate: Date | null
    totalWeeks: number | null
    adaptive5kTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanCountAggregateOutputType = {
    id: number
    athleteId: number
    raceId: number
    goalTime: number
    goalPace: number
    baseline5k: number
    baselineWeeklyMileage: number
    startDate: number
    totalWeeks: number
    phaseOverview: number
    weeklyMileagePlan: number
    weeks: number
    adaptive5kTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingPlanAvgAggregateInputType = {
    baselineWeeklyMileage?: true
    totalWeeks?: true
  }

  export type TrainingPlanSumAggregateInputType = {
    baselineWeeklyMileage?: true
    totalWeeks?: true
  }

  export type TrainingPlanMinAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanMaxAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanCountAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    phaseOverview?: true
    weeklyMileagePlan?: true
    weeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlan to aggregate.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPlans
    **/
    _count?: true | TrainingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPlanMaxAggregateInputType
  }

  export type GetTrainingPlanAggregateType<T extends TrainingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPlan[P]>
      : GetScalarType<T[P], AggregateTrainingPlan[P]>
  }




  export type TrainingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithAggregationInput | TrainingPlanOrderByWithAggregationInput[]
    by: TrainingPlanScalarFieldEnum[] | TrainingPlanScalarFieldEnum
    having?: TrainingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPlanCountAggregateInputType | true
    _avg?: TrainingPlanAvgAggregateInputType
    _sum?: TrainingPlanSumAggregateInputType
    _min?: TrainingPlanMinAggregateInputType
    _max?: TrainingPlanMaxAggregateInputType
  }

  export type TrainingPlanGroupByOutputType = {
    id: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace: string | null
    baseline5k: string
    baselineWeeklyMileage: number | null
    startDate: Date
    totalWeeks: number
    phaseOverview: JsonValue | null
    weeklyMileagePlan: JsonValue | null
    weeks: JsonValue | null
    adaptive5kTime: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingPlanCountAggregateOutputType | null
    _avg: TrainingPlanAvgAggregateOutputType | null
    _sum: TrainingPlanSumAggregateOutputType | null
    _min: TrainingPlanMinAggregateOutputType | null
    _max: TrainingPlanMaxAggregateOutputType | null
  }

  type GetTrainingPlanGroupByPayload<T extends TrainingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPlanGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    plannedDays?: boolean | TrainingPlan$plannedDaysArgs<ExtArgs>
    executions?: boolean | TrainingPlan$executionsArgs<ExtArgs>
    _count?: boolean | TrainingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectScalar = {
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "raceId" | "goalTime" | "goalPace" | "baseline5k" | "baselineWeeklyMileage" | "startDate" | "totalWeeks" | "phaseOverview" | "weeklyMileagePlan" | "weeks" | "adaptive5kTime" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingPlan"]>
  export type TrainingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    plannedDays?: boolean | TrainingPlan$plannedDaysArgs<ExtArgs>
    executions?: boolean | TrainingPlan$executionsArgs<ExtArgs>
    _count?: boolean | TrainingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type TrainingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $TrainingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPlan"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
      race: Prisma.$RacePayload<ExtArgs>
      plannedDays: Prisma.$TrainingDayPlannedPayload<ExtArgs>[]
      executions: Prisma.$TrainingPlanExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      raceId: string
      goalTime: string
      goalPace: string | null
      baseline5k: string
      baselineWeeklyMileage: number | null
      startDate: Date
      totalWeeks: number
      phaseOverview: Prisma.JsonValue | null
      weeklyMileagePlan: Prisma.JsonValue | null
      weeks: Prisma.JsonValue | null
      adaptive5kTime: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingPlan"]>
    composites: {}
  }

  type TrainingPlanGetPayload<S extends boolean | null | undefined | TrainingPlanDefaultArgs> = $Result.GetResult<Prisma.$TrainingPlanPayload, S>

  type TrainingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPlanCountAggregateInputType | true
    }

  export interface TrainingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPlan'], meta: { name: 'TrainingPlan' } }
    /**
     * Find zero or one TrainingPlan that matches the filter.
     * @param {TrainingPlanFindUniqueArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPlanFindUniqueArgs>(args: SelectSubset<T, TrainingPlanFindUniqueArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPlanFindUniqueOrThrowArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindFirstArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPlanFindFirstArgs>(args?: SelectSubset<T, TrainingPlanFindFirstArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindFirstOrThrowArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPlans
     * const trainingPlans = await prisma.trainingPlan.findMany()
     * 
     * // Get first 10 TrainingPlans
     * const trainingPlans = await prisma.trainingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPlanFindManyArgs>(args?: SelectSubset<T, TrainingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPlan.
     * @param {TrainingPlanCreateArgs} args - Arguments to create a TrainingPlan.
     * @example
     * // Create one TrainingPlan
     * const TrainingPlan = await prisma.trainingPlan.create({
     *   data: {
     *     // ... data to create a TrainingPlan
     *   }
     * })
     * 
     */
    create<T extends TrainingPlanCreateArgs>(args: SelectSubset<T, TrainingPlanCreateArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPlans.
     * @param {TrainingPlanCreateManyArgs} args - Arguments to create many TrainingPlans.
     * @example
     * // Create many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPlanCreateManyArgs>(args?: SelectSubset<T, TrainingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPlans and returns the data saved in the database.
     * @param {TrainingPlanCreateManyAndReturnArgs} args - Arguments to create many TrainingPlans.
     * @example
     * // Create many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPlans and only return the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPlan.
     * @param {TrainingPlanDeleteArgs} args - Arguments to delete one TrainingPlan.
     * @example
     * // Delete one TrainingPlan
     * const TrainingPlan = await prisma.trainingPlan.delete({
     *   where: {
     *     // ... filter to delete one TrainingPlan
     *   }
     * })
     * 
     */
    delete<T extends TrainingPlanDeleteArgs>(args: SelectSubset<T, TrainingPlanDeleteArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPlan.
     * @param {TrainingPlanUpdateArgs} args - Arguments to update one TrainingPlan.
     * @example
     * // Update one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPlanUpdateArgs>(args: SelectSubset<T, TrainingPlanUpdateArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPlans.
     * @param {TrainingPlanDeleteManyArgs} args - Arguments to filter TrainingPlans to delete.
     * @example
     * // Delete a few TrainingPlans
     * const { count } = await prisma.trainingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPlanDeleteManyArgs>(args?: SelectSubset<T, TrainingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPlanUpdateManyArgs>(args: SelectSubset<T, TrainingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlans and returns the data updated in the database.
     * @param {TrainingPlanUpdateManyAndReturnArgs} args - Arguments to update many TrainingPlans.
     * @example
     * // Update many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPlans and only return the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPlan.
     * @param {TrainingPlanUpsertArgs} args - Arguments to update or create a TrainingPlan.
     * @example
     * // Update or create a TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.upsert({
     *   create: {
     *     // ... data to create a TrainingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPlan we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPlanUpsertArgs>(args: SelectSubset<T, TrainingPlanUpsertArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanCountArgs} args - Arguments to filter TrainingPlans to count.
     * @example
     * // Count the number of TrainingPlans
     * const count = await prisma.trainingPlan.count({
     *   where: {
     *     // ... the filter for the TrainingPlans we want to count
     *   }
     * })
    **/
    count<T extends TrainingPlanCountArgs>(
      args?: Subset<T, TrainingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPlanAggregateArgs>(args: Subset<T, TrainingPlanAggregateArgs>): Prisma.PrismaPromise<GetTrainingPlanAggregateType<T>>

    /**
     * Group by TrainingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPlanGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPlan model
   */
  readonly fields: TrainingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plannedDays<T extends TrainingPlan$plannedDaysArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlan$plannedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executions<T extends TrainingPlan$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlan$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPlan model
   */
  interface TrainingPlanFieldRefs {
    readonly id: FieldRef<"TrainingPlan", 'String'>
    readonly athleteId: FieldRef<"TrainingPlan", 'String'>
    readonly raceId: FieldRef<"TrainingPlan", 'String'>
    readonly goalTime: FieldRef<"TrainingPlan", 'String'>
    readonly goalPace: FieldRef<"TrainingPlan", 'String'>
    readonly baseline5k: FieldRef<"TrainingPlan", 'String'>
    readonly baselineWeeklyMileage: FieldRef<"TrainingPlan", 'Int'>
    readonly startDate: FieldRef<"TrainingPlan", 'DateTime'>
    readonly totalWeeks: FieldRef<"TrainingPlan", 'Int'>
    readonly phaseOverview: FieldRef<"TrainingPlan", 'Json'>
    readonly weeklyMileagePlan: FieldRef<"TrainingPlan", 'Json'>
    readonly weeks: FieldRef<"TrainingPlan", 'Json'>
    readonly adaptive5kTime: FieldRef<"TrainingPlan", 'String'>
    readonly createdAt: FieldRef<"TrainingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPlan findUnique
   */
  export type TrainingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan findUniqueOrThrow
   */
  export type TrainingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan findFirst
   */
  export type TrainingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlans.
     */
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan findFirstOrThrow
   */
  export type TrainingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlans.
     */
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan findMany
   */
  export type TrainingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlans to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan create
   */
  export type TrainingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPlan.
     */
    data: XOR<TrainingPlanCreateInput, TrainingPlanUncheckedCreateInput>
  }

  /**
   * TrainingPlan createMany
   */
  export type TrainingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPlans.
     */
    data: TrainingPlanCreateManyInput | TrainingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPlan createManyAndReturn
   */
  export type TrainingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPlans.
     */
    data: TrainingPlanCreateManyInput | TrainingPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlan update
   */
  export type TrainingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPlan.
     */
    data: XOR<TrainingPlanUpdateInput, TrainingPlanUncheckedUpdateInput>
    /**
     * Choose, which TrainingPlan to update.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan updateMany
   */
  export type TrainingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPlans.
     */
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlans to update
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to update.
     */
    limit?: number
  }

  /**
   * TrainingPlan updateManyAndReturn
   */
  export type TrainingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPlans.
     */
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlans to update
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlan upsert
   */
  export type TrainingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPlan to update in case it exists.
     */
    where: TrainingPlanWhereUniqueInput
    /**
     * In case the TrainingPlan found by the `where` argument doesn't exist, create a new TrainingPlan with this data.
     */
    create: XOR<TrainingPlanCreateInput, TrainingPlanUncheckedCreateInput>
    /**
     * In case the TrainingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPlanUpdateInput, TrainingPlanUncheckedUpdateInput>
  }

  /**
   * TrainingPlan delete
   */
  export type TrainingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter which TrainingPlan to delete.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan deleteMany
   */
  export type TrainingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlans to delete
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to delete.
     */
    limit?: number
  }

  /**
   * TrainingPlan.plannedDays
   */
  export type TrainingPlan$plannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    cursor?: TrainingDayPlannedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingPlan.executions
   */
  export type TrainingPlan$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    where?: TrainingPlanExecutionWhereInput
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    cursor?: TrainingPlanExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlan without action
   */
  export type TrainingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDayPlanned
   */

  export type AggregateTrainingDayPlanned = {
    _count: TrainingDayPlannedCountAggregateOutputType | null
    _avg: TrainingDayPlannedAvgAggregateOutputType | null
    _sum: TrainingDayPlannedSumAggregateOutputType | null
    _min: TrainingDayPlannedMinAggregateOutputType | null
    _max: TrainingDayPlannedMaxAggregateOutputType | null
  }

  export type TrainingDayPlannedAvgAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayPlannedSumAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayPlannedMinAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    athleteId: string | null
    date: Date | null
    weekIndex: number | null
    dayIndex: number | null
    dayName: string | null
    phase: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayPlannedMaxAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    athleteId: string | null
    date: Date | null
    weekIndex: number | null
    dayIndex: number | null
    dayName: string | null
    phase: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayPlannedCountAggregateOutputType = {
    id: number
    trainingPlanId: number
    athleteId: number
    date: number
    weekIndex: number
    dayIndex: number
    dayName: number
    phase: number
    plannedData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDayPlannedAvgAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayPlannedSumAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayPlannedMinAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayPlannedMaxAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayPlannedCountAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    plannedData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDayPlannedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayPlanned to aggregate.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDayPlanneds
    **/
    _count?: true | TrainingDayPlannedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDayPlannedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDayPlannedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDayPlannedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDayPlannedMaxAggregateInputType
  }

  export type GetTrainingDayPlannedAggregateType<T extends TrainingDayPlannedAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDayPlanned]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDayPlanned[P]>
      : GetScalarType<T[P], AggregateTrainingDayPlanned[P]>
  }




  export type TrainingDayPlannedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithAggregationInput | TrainingDayPlannedOrderByWithAggregationInput[]
    by: TrainingDayPlannedScalarFieldEnum[] | TrainingDayPlannedScalarFieldEnum
    having?: TrainingDayPlannedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDayPlannedCountAggregateInputType | true
    _avg?: TrainingDayPlannedAvgAggregateInputType
    _sum?: TrainingDayPlannedSumAggregateInputType
    _min?: TrainingDayPlannedMinAggregateInputType
    _max?: TrainingDayPlannedMaxAggregateInputType
  }

  export type TrainingDayPlannedGroupByOutputType = {
    id: string
    trainingPlanId: string
    athleteId: string
    date: Date
    weekIndex: number
    dayIndex: number
    dayName: string | null
    phase: string
    plannedData: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TrainingDayPlannedCountAggregateOutputType | null
    _avg: TrainingDayPlannedAvgAggregateOutputType | null
    _sum: TrainingDayPlannedSumAggregateOutputType | null
    _min: TrainingDayPlannedMinAggregateOutputType | null
    _max: TrainingDayPlannedMaxAggregateOutputType | null
  }

  type GetTrainingDayPlannedGroupByPayload<T extends TrainingDayPlannedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDayPlannedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDayPlannedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDayPlannedGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDayPlannedGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDayPlannedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectScalar = {
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDayPlannedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingPlanId" | "athleteId" | "date" | "weekIndex" | "dayIndex" | "dayName" | "phase" | "plannedData" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDayPlanned"]>
  export type TrainingDayPlannedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayPlannedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayPlannedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $TrainingDayPlannedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDayPlanned"
    objects: {
      trainingPlan: Prisma.$TrainingPlanPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingPlanId: string
      athleteId: string
      date: Date
      weekIndex: number
      dayIndex: number
      dayName: string | null
      phase: string
      plannedData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDayPlanned"]>
    composites: {}
  }

  type TrainingDayPlannedGetPayload<S extends boolean | null | undefined | TrainingDayPlannedDefaultArgs> = $Result.GetResult<Prisma.$TrainingDayPlannedPayload, S>

  type TrainingDayPlannedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDayPlannedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDayPlannedCountAggregateInputType | true
    }

  export interface TrainingDayPlannedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDayPlanned'], meta: { name: 'TrainingDayPlanned' } }
    /**
     * Find zero or one TrainingDayPlanned that matches the filter.
     * @param {TrainingDayPlannedFindUniqueArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDayPlannedFindUniqueArgs>(args: SelectSubset<T, TrainingDayPlannedFindUniqueArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDayPlanned that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDayPlannedFindUniqueOrThrowArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDayPlannedFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayPlanned that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindFirstArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDayPlannedFindFirstArgs>(args?: SelectSubset<T, TrainingDayPlannedFindFirstArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayPlanned that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindFirstOrThrowArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDayPlannedFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDayPlanneds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDayPlanneds
     * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany()
     * 
     * // Get first 10 TrainingDayPlanneds
     * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDayPlannedFindManyArgs>(args?: SelectSubset<T, TrainingDayPlannedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDayPlanned.
     * @param {TrainingDayPlannedCreateArgs} args - Arguments to create a TrainingDayPlanned.
     * @example
     * // Create one TrainingDayPlanned
     * const TrainingDayPlanned = await prisma.trainingDayPlanned.create({
     *   data: {
     *     // ... data to create a TrainingDayPlanned
     *   }
     * })
     * 
     */
    create<T extends TrainingDayPlannedCreateArgs>(args: SelectSubset<T, TrainingDayPlannedCreateArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDayPlanneds.
     * @param {TrainingDayPlannedCreateManyArgs} args - Arguments to create many TrainingDayPlanneds.
     * @example
     * // Create many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDayPlannedCreateManyArgs>(args?: SelectSubset<T, TrainingDayPlannedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDayPlanneds and returns the data saved in the database.
     * @param {TrainingDayPlannedCreateManyAndReturnArgs} args - Arguments to create many TrainingDayPlanneds.
     * @example
     * // Create many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDayPlanneds and only return the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDayPlannedCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDayPlanned.
     * @param {TrainingDayPlannedDeleteArgs} args - Arguments to delete one TrainingDayPlanned.
     * @example
     * // Delete one TrainingDayPlanned
     * const TrainingDayPlanned = await prisma.trainingDayPlanned.delete({
     *   where: {
     *     // ... filter to delete one TrainingDayPlanned
     *   }
     * })
     * 
     */
    delete<T extends TrainingDayPlannedDeleteArgs>(args: SelectSubset<T, TrainingDayPlannedDeleteArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDayPlanned.
     * @param {TrainingDayPlannedUpdateArgs} args - Arguments to update one TrainingDayPlanned.
     * @example
     * // Update one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDayPlannedUpdateArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDayPlanneds.
     * @param {TrainingDayPlannedDeleteManyArgs} args - Arguments to filter TrainingDayPlanneds to delete.
     * @example
     * // Delete a few TrainingDayPlanneds
     * const { count } = await prisma.trainingDayPlanned.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDayPlannedDeleteManyArgs>(args?: SelectSubset<T, TrainingDayPlannedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayPlanneds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDayPlannedUpdateManyArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayPlanneds and returns the data updated in the database.
     * @param {TrainingDayPlannedUpdateManyAndReturnArgs} args - Arguments to update many TrainingDayPlanneds.
     * @example
     * // Update many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDayPlanneds and only return the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDayPlannedUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDayPlanned.
     * @param {TrainingDayPlannedUpsertArgs} args - Arguments to update or create a TrainingDayPlanned.
     * @example
     * // Update or create a TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.upsert({
     *   create: {
     *     // ... data to create a TrainingDayPlanned
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDayPlanned we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDayPlannedUpsertArgs>(args: SelectSubset<T, TrainingDayPlannedUpsertArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDayPlanneds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedCountArgs} args - Arguments to filter TrainingDayPlanneds to count.
     * @example
     * // Count the number of TrainingDayPlanneds
     * const count = await prisma.trainingDayPlanned.count({
     *   where: {
     *     // ... the filter for the TrainingDayPlanneds we want to count
     *   }
     * })
    **/
    count<T extends TrainingDayPlannedCountArgs>(
      args?: Subset<T, TrainingDayPlannedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDayPlannedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDayPlanned.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDayPlannedAggregateArgs>(args: Subset<T, TrainingDayPlannedAggregateArgs>): Prisma.PrismaPromise<GetTrainingDayPlannedAggregateType<T>>

    /**
     * Group by TrainingDayPlanned.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDayPlannedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDayPlannedGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDayPlannedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDayPlannedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDayPlannedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDayPlanned model
   */
  readonly fields: TrainingDayPlannedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDayPlanned.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDayPlannedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainingPlan<T extends TrainingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanDefaultArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDayPlanned model
   */
  interface TrainingDayPlannedFieldRefs {
    readonly id: FieldRef<"TrainingDayPlanned", 'String'>
    readonly trainingPlanId: FieldRef<"TrainingDayPlanned", 'String'>
    readonly athleteId: FieldRef<"TrainingDayPlanned", 'String'>
    readonly date: FieldRef<"TrainingDayPlanned", 'DateTime'>
    readonly weekIndex: FieldRef<"TrainingDayPlanned", 'Int'>
    readonly dayIndex: FieldRef<"TrainingDayPlanned", 'Int'>
    readonly dayName: FieldRef<"TrainingDayPlanned", 'String'>
    readonly phase: FieldRef<"TrainingDayPlanned", 'String'>
    readonly plannedData: FieldRef<"TrainingDayPlanned", 'Json'>
    readonly createdAt: FieldRef<"TrainingDayPlanned", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDayPlanned", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDayPlanned findUnique
   */
  export type TrainingDayPlannedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned findUniqueOrThrow
   */
  export type TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned findFirst
   */
  export type TrainingDayPlannedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayPlanneds.
     */
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned findFirstOrThrow
   */
  export type TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayPlanneds.
     */
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned findMany
   */
  export type TrainingDayPlannedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanneds to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned create
   */
  export type TrainingDayPlannedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDayPlanned.
     */
    data: XOR<TrainingDayPlannedCreateInput, TrainingDayPlannedUncheckedCreateInput>
  }

  /**
   * TrainingDayPlanned createMany
   */
  export type TrainingDayPlannedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDayPlanneds.
     */
    data: TrainingDayPlannedCreateManyInput | TrainingDayPlannedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDayPlanned createManyAndReturn
   */
  export type TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDayPlanneds.
     */
    data: TrainingDayPlannedCreateManyInput | TrainingDayPlannedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayPlanned update
   */
  export type TrainingDayPlannedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDayPlanned.
     */
    data: XOR<TrainingDayPlannedUpdateInput, TrainingDayPlannedUncheckedUpdateInput>
    /**
     * Choose, which TrainingDayPlanned to update.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned updateMany
   */
  export type TrainingDayPlannedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDayPlanneds.
     */
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayPlanneds to update
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to update.
     */
    limit?: number
  }

  /**
   * TrainingDayPlanned updateManyAndReturn
   */
  export type TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDayPlanneds.
     */
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayPlanneds to update
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayPlanned upsert
   */
  export type TrainingDayPlannedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDayPlanned to update in case it exists.
     */
    where: TrainingDayPlannedWhereUniqueInput
    /**
     * In case the TrainingDayPlanned found by the `where` argument doesn't exist, create a new TrainingDayPlanned with this data.
     */
    create: XOR<TrainingDayPlannedCreateInput, TrainingDayPlannedUncheckedCreateInput>
    /**
     * In case the TrainingDayPlanned was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDayPlannedUpdateInput, TrainingDayPlannedUncheckedUpdateInput>
  }

  /**
   * TrainingDayPlanned delete
   */
  export type TrainingDayPlannedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter which TrainingDayPlanned to delete.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned deleteMany
   */
  export type TrainingDayPlannedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayPlanneds to delete
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to delete.
     */
    limit?: number
  }

  /**
   * TrainingDayPlanned without action
   */
  export type TrainingDayPlannedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPlanExecution
   */

  export type AggregateTrainingPlanExecution = {
    _count: TrainingPlanExecutionCountAggregateOutputType | null
    _min: TrainingPlanExecutionMinAggregateOutputType | null
    _max: TrainingPlanExecutionMaxAggregateOutputType | null
  }

  export type TrainingPlanExecutionMinAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    startedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanExecutionMaxAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    startedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanExecutionCountAggregateOutputType = {
    id: number
    trainingPlanId: number
    startedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingPlanExecutionMinAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanExecutionMaxAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanExecutionCountAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingPlanExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlanExecution to aggregate.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPlanExecutions
    **/
    _count?: true | TrainingPlanExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPlanExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPlanExecutionMaxAggregateInputType
  }

  export type GetTrainingPlanExecutionAggregateType<T extends TrainingPlanExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPlanExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPlanExecution[P]>
      : GetScalarType<T[P], AggregateTrainingPlanExecution[P]>
  }




  export type TrainingPlanExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanExecutionWhereInput
    orderBy?: TrainingPlanExecutionOrderByWithAggregationInput | TrainingPlanExecutionOrderByWithAggregationInput[]
    by: TrainingPlanExecutionScalarFieldEnum[] | TrainingPlanExecutionScalarFieldEnum
    having?: TrainingPlanExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPlanExecutionCountAggregateInputType | true
    _min?: TrainingPlanExecutionMinAggregateInputType
    _max?: TrainingPlanExecutionMaxAggregateInputType
  }

  export type TrainingPlanExecutionGroupByOutputType = {
    id: string
    trainingPlanId: string
    startedAt: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingPlanExecutionCountAggregateOutputType | null
    _min: TrainingPlanExecutionMinAggregateOutputType | null
    _max: TrainingPlanExecutionMaxAggregateOutputType | null
  }

  type GetTrainingPlanExecutionGroupByPayload<T extends TrainingPlanExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPlanExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPlanExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPlanExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPlanExecutionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPlanExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    executedDays?: boolean | TrainingPlanExecution$executedDaysArgs<ExtArgs>
    _count?: boolean | TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectScalar = {
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingPlanExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingPlanId" | "startedAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingPlanExecution"]>
  export type TrainingPlanExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    executedDays?: boolean | TrainingPlanExecution$executedDaysArgs<ExtArgs>
    _count?: boolean | TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingPlanExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }
  export type TrainingPlanExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }

  export type $TrainingPlanExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPlanExecution"
    objects: {
      trainingPlan: Prisma.$TrainingPlanPayload<ExtArgs>
      executedDays: Prisma.$TrainingDayExecutedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingPlanId: string
      startedAt: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingPlanExecution"]>
    composites: {}
  }

  type TrainingPlanExecutionGetPayload<S extends boolean | null | undefined | TrainingPlanExecutionDefaultArgs> = $Result.GetResult<Prisma.$TrainingPlanExecutionPayload, S>

  type TrainingPlanExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPlanExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPlanExecutionCountAggregateInputType | true
    }

  export interface TrainingPlanExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPlanExecution'], meta: { name: 'TrainingPlanExecution' } }
    /**
     * Find zero or one TrainingPlanExecution that matches the filter.
     * @param {TrainingPlanExecutionFindUniqueArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPlanExecutionFindUniqueArgs>(args: SelectSubset<T, TrainingPlanExecutionFindUniqueArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPlanExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPlanExecutionFindUniqueOrThrowArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPlanExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlanExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindFirstArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPlanExecutionFindFirstArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindFirstArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlanExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindFirstOrThrowArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPlanExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPlanExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPlanExecutions
     * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany()
     * 
     * // Get first 10 TrainingPlanExecutions
     * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPlanExecutionFindManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPlanExecution.
     * @param {TrainingPlanExecutionCreateArgs} args - Arguments to create a TrainingPlanExecution.
     * @example
     * // Create one TrainingPlanExecution
     * const TrainingPlanExecution = await prisma.trainingPlanExecution.create({
     *   data: {
     *     // ... data to create a TrainingPlanExecution
     *   }
     * })
     * 
     */
    create<T extends TrainingPlanExecutionCreateArgs>(args: SelectSubset<T, TrainingPlanExecutionCreateArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPlanExecutions.
     * @param {TrainingPlanExecutionCreateManyArgs} args - Arguments to create many TrainingPlanExecutions.
     * @example
     * // Create many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPlanExecutionCreateManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPlanExecutions and returns the data saved in the database.
     * @param {TrainingPlanExecutionCreateManyAndReturnArgs} args - Arguments to create many TrainingPlanExecutions.
     * @example
     * // Create many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPlanExecutions and only return the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPlanExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPlanExecution.
     * @param {TrainingPlanExecutionDeleteArgs} args - Arguments to delete one TrainingPlanExecution.
     * @example
     * // Delete one TrainingPlanExecution
     * const TrainingPlanExecution = await prisma.trainingPlanExecution.delete({
     *   where: {
     *     // ... filter to delete one TrainingPlanExecution
     *   }
     * })
     * 
     */
    delete<T extends TrainingPlanExecutionDeleteArgs>(args: SelectSubset<T, TrainingPlanExecutionDeleteArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPlanExecution.
     * @param {TrainingPlanExecutionUpdateArgs} args - Arguments to update one TrainingPlanExecution.
     * @example
     * // Update one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPlanExecutionUpdateArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPlanExecutions.
     * @param {TrainingPlanExecutionDeleteManyArgs} args - Arguments to filter TrainingPlanExecutions to delete.
     * @example
     * // Delete a few TrainingPlanExecutions
     * const { count } = await prisma.trainingPlanExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPlanExecutionDeleteManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlanExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPlanExecutionUpdateManyArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlanExecutions and returns the data updated in the database.
     * @param {TrainingPlanExecutionUpdateManyAndReturnArgs} args - Arguments to update many TrainingPlanExecutions.
     * @example
     * // Update many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPlanExecutions and only return the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPlanExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPlanExecution.
     * @param {TrainingPlanExecutionUpsertArgs} args - Arguments to update or create a TrainingPlanExecution.
     * @example
     * // Update or create a TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.upsert({
     *   create: {
     *     // ... data to create a TrainingPlanExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPlanExecution we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPlanExecutionUpsertArgs>(args: SelectSubset<T, TrainingPlanExecutionUpsertArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPlanExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionCountArgs} args - Arguments to filter TrainingPlanExecutions to count.
     * @example
     * // Count the number of TrainingPlanExecutions
     * const count = await prisma.trainingPlanExecution.count({
     *   where: {
     *     // ... the filter for the TrainingPlanExecutions we want to count
     *   }
     * })
    **/
    count<T extends TrainingPlanExecutionCountArgs>(
      args?: Subset<T, TrainingPlanExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPlanExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPlanExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPlanExecutionAggregateArgs>(args: Subset<T, TrainingPlanExecutionAggregateArgs>): Prisma.PrismaPromise<GetTrainingPlanExecutionAggregateType<T>>

    /**
     * Group by TrainingPlanExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPlanExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPlanExecutionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPlanExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPlanExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPlanExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPlanExecution model
   */
  readonly fields: TrainingPlanExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPlanExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPlanExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainingPlan<T extends TrainingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanDefaultArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executedDays<T extends TrainingPlanExecution$executedDaysArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanExecution$executedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPlanExecution model
   */
  interface TrainingPlanExecutionFieldRefs {
    readonly id: FieldRef<"TrainingPlanExecution", 'String'>
    readonly trainingPlanId: FieldRef<"TrainingPlanExecution", 'String'>
    readonly startedAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
    readonly status: FieldRef<"TrainingPlanExecution", 'String'>
    readonly createdAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPlanExecution findUnique
   */
  export type TrainingPlanExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution findUniqueOrThrow
   */
  export type TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution findFirst
   */
  export type TrainingPlanExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlanExecutions.
     */
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution findFirstOrThrow
   */
  export type TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlanExecutions.
     */
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution findMany
   */
  export type TrainingPlanExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecutions to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution create
   */
  export type TrainingPlanExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPlanExecution.
     */
    data: XOR<TrainingPlanExecutionCreateInput, TrainingPlanExecutionUncheckedCreateInput>
  }

  /**
   * TrainingPlanExecution createMany
   */
  export type TrainingPlanExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPlanExecutions.
     */
    data: TrainingPlanExecutionCreateManyInput | TrainingPlanExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPlanExecution createManyAndReturn
   */
  export type TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPlanExecutions.
     */
    data: TrainingPlanExecutionCreateManyInput | TrainingPlanExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlanExecution update
   */
  export type TrainingPlanExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPlanExecution.
     */
    data: XOR<TrainingPlanExecutionUpdateInput, TrainingPlanExecutionUncheckedUpdateInput>
    /**
     * Choose, which TrainingPlanExecution to update.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution updateMany
   */
  export type TrainingPlanExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPlanExecutions.
     */
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlanExecutions to update
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to update.
     */
    limit?: number
  }

  /**
   * TrainingPlanExecution updateManyAndReturn
   */
  export type TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPlanExecutions.
     */
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlanExecutions to update
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlanExecution upsert
   */
  export type TrainingPlanExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPlanExecution to update in case it exists.
     */
    where: TrainingPlanExecutionWhereUniqueInput
    /**
     * In case the TrainingPlanExecution found by the `where` argument doesn't exist, create a new TrainingPlanExecution with this data.
     */
    create: XOR<TrainingPlanExecutionCreateInput, TrainingPlanExecutionUncheckedCreateInput>
    /**
     * In case the TrainingPlanExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPlanExecutionUpdateInput, TrainingPlanExecutionUncheckedUpdateInput>
  }

  /**
   * TrainingPlanExecution delete
   */
  export type TrainingPlanExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter which TrainingPlanExecution to delete.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution deleteMany
   */
  export type TrainingPlanExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlanExecutions to delete
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to delete.
     */
    limit?: number
  }

  /**
   * TrainingPlanExecution.executedDays
   */
  export type TrainingPlanExecution$executedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    cursor?: TrainingDayExecutedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution without action
   */
  export type TrainingPlanExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDayExecuted
   */

  export type AggregateTrainingDayExecuted = {
    _count: TrainingDayExecutedCountAggregateOutputType | null
    _avg: TrainingDayExecutedAvgAggregateOutputType | null
    _sum: TrainingDayExecutedSumAggregateOutputType | null
    _min: TrainingDayExecutedMinAggregateOutputType | null
    _max: TrainingDayExecutedMaxAggregateOutputType | null
  }

  export type TrainingDayExecutedAvgAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayExecutedSumAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayExecutedMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    athleteId: string | null
    activityId: string | null
    weekIndex: number | null
    dayIndex: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayExecutedMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    athleteId: string | null
    activityId: string | null
    weekIndex: number | null
    dayIndex: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayExecutedCountAggregateOutputType = {
    id: number
    executionId: number
    athleteId: number
    activityId: number
    weekIndex: number
    dayIndex: number
    date: number
    plannedData: number
    analysis: number
    feedback: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDayExecutedAvgAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayExecutedSumAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayExecutedMinAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayExecutedMaxAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayExecutedCountAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    plannedData?: true
    analysis?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDayExecutedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayExecuted to aggregate.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDayExecuteds
    **/
    _count?: true | TrainingDayExecutedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDayExecutedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDayExecutedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDayExecutedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDayExecutedMaxAggregateInputType
  }

  export type GetTrainingDayExecutedAggregateType<T extends TrainingDayExecutedAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDayExecuted]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDayExecuted[P]>
      : GetScalarType<T[P], AggregateTrainingDayExecuted[P]>
  }




  export type TrainingDayExecutedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithAggregationInput | TrainingDayExecutedOrderByWithAggregationInput[]
    by: TrainingDayExecutedScalarFieldEnum[] | TrainingDayExecutedScalarFieldEnum
    having?: TrainingDayExecutedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDayExecutedCountAggregateInputType | true
    _avg?: TrainingDayExecutedAvgAggregateInputType
    _sum?: TrainingDayExecutedSumAggregateInputType
    _min?: TrainingDayExecutedMinAggregateInputType
    _max?: TrainingDayExecutedMaxAggregateInputType
  }

  export type TrainingDayExecutedGroupByOutputType = {
    id: string
    executionId: string
    athleteId: string
    activityId: string | null
    weekIndex: number
    dayIndex: number
    date: Date
    plannedData: JsonValue | null
    analysis: JsonValue | null
    feedback: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingDayExecutedCountAggregateOutputType | null
    _avg: TrainingDayExecutedAvgAggregateOutputType | null
    _sum: TrainingDayExecutedSumAggregateOutputType | null
    _min: TrainingDayExecutedMinAggregateOutputType | null
    _max: TrainingDayExecutedMaxAggregateOutputType | null
  }

  type GetTrainingDayExecutedGroupByPayload<T extends TrainingDayExecutedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDayExecutedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDayExecutedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDayExecutedGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDayExecutedGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDayExecutedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectScalar = {
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDayExecutedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executionId" | "athleteId" | "activityId" | "weekIndex" | "dayIndex" | "date" | "plannedData" | "analysis" | "feedback" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDayExecuted"]>
  export type TrainingDayExecutedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayExecutedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayExecutedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $TrainingDayExecutedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDayExecuted"
    objects: {
      execution: Prisma.$TrainingPlanExecutionPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      athleteId: string
      activityId: string | null
      weekIndex: number
      dayIndex: number
      date: Date
      plannedData: Prisma.JsonValue | null
      analysis: Prisma.JsonValue | null
      feedback: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDayExecuted"]>
    composites: {}
  }

  type TrainingDayExecutedGetPayload<S extends boolean | null | undefined | TrainingDayExecutedDefaultArgs> = $Result.GetResult<Prisma.$TrainingDayExecutedPayload, S>

  type TrainingDayExecutedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDayExecutedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDayExecutedCountAggregateInputType | true
    }

  export interface TrainingDayExecutedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDayExecuted'], meta: { name: 'TrainingDayExecuted' } }
    /**
     * Find zero or one TrainingDayExecuted that matches the filter.
     * @param {TrainingDayExecutedFindUniqueArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDayExecutedFindUniqueArgs>(args: SelectSubset<T, TrainingDayExecutedFindUniqueArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDayExecuted that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDayExecutedFindUniqueOrThrowArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDayExecutedFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayExecuted that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindFirstArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDayExecutedFindFirstArgs>(args?: SelectSubset<T, TrainingDayExecutedFindFirstArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayExecuted that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindFirstOrThrowArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDayExecutedFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDayExecuteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDayExecuteds
     * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany()
     * 
     * // Get first 10 TrainingDayExecuteds
     * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDayExecutedFindManyArgs>(args?: SelectSubset<T, TrainingDayExecutedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDayExecuted.
     * @param {TrainingDayExecutedCreateArgs} args - Arguments to create a TrainingDayExecuted.
     * @example
     * // Create one TrainingDayExecuted
     * const TrainingDayExecuted = await prisma.trainingDayExecuted.create({
     *   data: {
     *     // ... data to create a TrainingDayExecuted
     *   }
     * })
     * 
     */
    create<T extends TrainingDayExecutedCreateArgs>(args: SelectSubset<T, TrainingDayExecutedCreateArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDayExecuteds.
     * @param {TrainingDayExecutedCreateManyArgs} args - Arguments to create many TrainingDayExecuteds.
     * @example
     * // Create many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDayExecutedCreateManyArgs>(args?: SelectSubset<T, TrainingDayExecutedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDayExecuteds and returns the data saved in the database.
     * @param {TrainingDayExecutedCreateManyAndReturnArgs} args - Arguments to create many TrainingDayExecuteds.
     * @example
     * // Create many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDayExecuteds and only return the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDayExecutedCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDayExecuted.
     * @param {TrainingDayExecutedDeleteArgs} args - Arguments to delete one TrainingDayExecuted.
     * @example
     * // Delete one TrainingDayExecuted
     * const TrainingDayExecuted = await prisma.trainingDayExecuted.delete({
     *   where: {
     *     // ... filter to delete one TrainingDayExecuted
     *   }
     * })
     * 
     */
    delete<T extends TrainingDayExecutedDeleteArgs>(args: SelectSubset<T, TrainingDayExecutedDeleteArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDayExecuted.
     * @param {TrainingDayExecutedUpdateArgs} args - Arguments to update one TrainingDayExecuted.
     * @example
     * // Update one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDayExecutedUpdateArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDayExecuteds.
     * @param {TrainingDayExecutedDeleteManyArgs} args - Arguments to filter TrainingDayExecuteds to delete.
     * @example
     * // Delete a few TrainingDayExecuteds
     * const { count } = await prisma.trainingDayExecuted.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDayExecutedDeleteManyArgs>(args?: SelectSubset<T, TrainingDayExecutedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayExecuteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDayExecutedUpdateManyArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayExecuteds and returns the data updated in the database.
     * @param {TrainingDayExecutedUpdateManyAndReturnArgs} args - Arguments to update many TrainingDayExecuteds.
     * @example
     * // Update many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDayExecuteds and only return the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDayExecutedUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDayExecuted.
     * @param {TrainingDayExecutedUpsertArgs} args - Arguments to update or create a TrainingDayExecuted.
     * @example
     * // Update or create a TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.upsert({
     *   create: {
     *     // ... data to create a TrainingDayExecuted
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDayExecuted we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDayExecutedUpsertArgs>(args: SelectSubset<T, TrainingDayExecutedUpsertArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDayExecuteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedCountArgs} args - Arguments to filter TrainingDayExecuteds to count.
     * @example
     * // Count the number of TrainingDayExecuteds
     * const count = await prisma.trainingDayExecuted.count({
     *   where: {
     *     // ... the filter for the TrainingDayExecuteds we want to count
     *   }
     * })
    **/
    count<T extends TrainingDayExecutedCountArgs>(
      args?: Subset<T, TrainingDayExecutedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDayExecutedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDayExecuted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDayExecutedAggregateArgs>(args: Subset<T, TrainingDayExecutedAggregateArgs>): Prisma.PrismaPromise<GetTrainingDayExecutedAggregateType<T>>

    /**
     * Group by TrainingDayExecuted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDayExecutedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDayExecutedGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDayExecutedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDayExecutedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDayExecutedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDayExecuted model
   */
  readonly fields: TrainingDayExecutedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDayExecuted.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDayExecutedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends TrainingPlanExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanExecutionDefaultArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDayExecuted model
   */
  interface TrainingDayExecutedFieldRefs {
    readonly id: FieldRef<"TrainingDayExecuted", 'String'>
    readonly executionId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly athleteId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly activityId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly weekIndex: FieldRef<"TrainingDayExecuted", 'Int'>
    readonly dayIndex: FieldRef<"TrainingDayExecuted", 'Int'>
    readonly date: FieldRef<"TrainingDayExecuted", 'DateTime'>
    readonly plannedData: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly analysis: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly feedback: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly createdAt: FieldRef<"TrainingDayExecuted", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDayExecuted", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDayExecuted findUnique
   */
  export type TrainingDayExecutedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted findUniqueOrThrow
   */
  export type TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted findFirst
   */
  export type TrainingDayExecutedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayExecuteds.
     */
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted findFirstOrThrow
   */
  export type TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayExecuteds.
     */
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted findMany
   */
  export type TrainingDayExecutedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuteds to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted create
   */
  export type TrainingDayExecutedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDayExecuted.
     */
    data: XOR<TrainingDayExecutedCreateInput, TrainingDayExecutedUncheckedCreateInput>
  }

  /**
   * TrainingDayExecuted createMany
   */
  export type TrainingDayExecutedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDayExecuteds.
     */
    data: TrainingDayExecutedCreateManyInput | TrainingDayExecutedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDayExecuted createManyAndReturn
   */
  export type TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDayExecuteds.
     */
    data: TrainingDayExecutedCreateManyInput | TrainingDayExecutedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayExecuted update
   */
  export type TrainingDayExecutedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDayExecuted.
     */
    data: XOR<TrainingDayExecutedUpdateInput, TrainingDayExecutedUncheckedUpdateInput>
    /**
     * Choose, which TrainingDayExecuted to update.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted updateMany
   */
  export type TrainingDayExecutedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDayExecuteds.
     */
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayExecuteds to update
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to update.
     */
    limit?: number
  }

  /**
   * TrainingDayExecuted updateManyAndReturn
   */
  export type TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDayExecuteds.
     */
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayExecuteds to update
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayExecuted upsert
   */
  export type TrainingDayExecutedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDayExecuted to update in case it exists.
     */
    where: TrainingDayExecutedWhereUniqueInput
    /**
     * In case the TrainingDayExecuted found by the `where` argument doesn't exist, create a new TrainingDayExecuted with this data.
     */
    create: XOR<TrainingDayExecutedCreateInput, TrainingDayExecutedUncheckedCreateInput>
    /**
     * In case the TrainingDayExecuted was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDayExecutedUpdateInput, TrainingDayExecutedUncheckedUpdateInput>
  }

  /**
   * TrainingDayExecuted delete
   */
  export type TrainingDayExecutedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter which TrainingDayExecuted to delete.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted deleteMany
   */
  export type TrainingDayExecutedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayExecuteds to delete
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to delete.
     */
    limit?: number
  }

  /**
   * TrainingDayExecuted without action
   */
  export type TrainingDayExecutedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
  }


  /**
   * Model Founder
   */

  export type AggregateFounder = {
    _count: FounderCountAggregateOutputType | null
    _min: FounderMinAggregateOutputType | null
    _max: FounderMaxAggregateOutputType | null
  }

  export type FounderMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderCountAggregateOutputType = {
    id: number
    athleteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FounderMinAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderMaxAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderCountAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FounderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Founder to aggregate.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Founders
    **/
    _count?: true | FounderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FounderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FounderMaxAggregateInputType
  }

  export type GetFounderAggregateType<T extends FounderAggregateArgs> = {
        [P in keyof T & keyof AggregateFounder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFounder[P]>
      : GetScalarType<T[P], AggregateFounder[P]>
  }




  export type FounderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderWhereInput
    orderBy?: FounderOrderByWithAggregationInput | FounderOrderByWithAggregationInput[]
    by: FounderScalarFieldEnum[] | FounderScalarFieldEnum
    having?: FounderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FounderCountAggregateInputType | true
    _min?: FounderMinAggregateInputType
    _max?: FounderMaxAggregateInputType
  }

  export type FounderGroupByOutputType = {
    id: string
    athleteId: string
    createdAt: Date
    updatedAt: Date
    _count: FounderCountAggregateOutputType | null
    _min: FounderMinAggregateOutputType | null
    _max: FounderMaxAggregateOutputType | null
  }

  type GetFounderGroupByPayload<T extends FounderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FounderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FounderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FounderGroupByOutputType[P]>
            : GetScalarType<T[P], FounderGroupByOutputType[P]>
        }
      >
    >


  export type FounderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    tasks?: boolean | Founder$tasksArgs<ExtArgs>
    crmContacts?: boolean | Founder$crmContactsArgs<ExtArgs>
    roadmapItems?: boolean | Founder$roadmapItemsArgs<ExtArgs>
    _count?: boolean | FounderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectScalar = {
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FounderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "createdAt" | "updatedAt", ExtArgs["result"]["founder"]>
  export type FounderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    tasks?: boolean | Founder$tasksArgs<ExtArgs>
    crmContacts?: boolean | Founder$crmContactsArgs<ExtArgs>
    roadmapItems?: boolean | Founder$roadmapItemsArgs<ExtArgs>
    _count?: boolean | FounderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FounderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type FounderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $FounderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Founder"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
      tasks: Prisma.$FounderTaskPayload<ExtArgs>[]
      crmContacts: Prisma.$CrmContactPayload<ExtArgs>[]
      roadmapItems: Prisma.$RoadmapItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["founder"]>
    composites: {}
  }

  type FounderGetPayload<S extends boolean | null | undefined | FounderDefaultArgs> = $Result.GetResult<Prisma.$FounderPayload, S>

  type FounderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FounderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FounderCountAggregateInputType | true
    }

  export interface FounderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Founder'], meta: { name: 'Founder' } }
    /**
     * Find zero or one Founder that matches the filter.
     * @param {FounderFindUniqueArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FounderFindUniqueArgs>(args: SelectSubset<T, FounderFindUniqueArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Founder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FounderFindUniqueOrThrowArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FounderFindUniqueOrThrowArgs>(args: SelectSubset<T, FounderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Founder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindFirstArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FounderFindFirstArgs>(args?: SelectSubset<T, FounderFindFirstArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Founder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindFirstOrThrowArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FounderFindFirstOrThrowArgs>(args?: SelectSubset<T, FounderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Founders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Founders
     * const founders = await prisma.founder.findMany()
     * 
     * // Get first 10 Founders
     * const founders = await prisma.founder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const founderWithIdOnly = await prisma.founder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FounderFindManyArgs>(args?: SelectSubset<T, FounderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Founder.
     * @param {FounderCreateArgs} args - Arguments to create a Founder.
     * @example
     * // Create one Founder
     * const Founder = await prisma.founder.create({
     *   data: {
     *     // ... data to create a Founder
     *   }
     * })
     * 
     */
    create<T extends FounderCreateArgs>(args: SelectSubset<T, FounderCreateArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Founders.
     * @param {FounderCreateManyArgs} args - Arguments to create many Founders.
     * @example
     * // Create many Founders
     * const founder = await prisma.founder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FounderCreateManyArgs>(args?: SelectSubset<T, FounderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Founders and returns the data saved in the database.
     * @param {FounderCreateManyAndReturnArgs} args - Arguments to create many Founders.
     * @example
     * // Create many Founders
     * const founder = await prisma.founder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Founders and only return the `id`
     * const founderWithIdOnly = await prisma.founder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FounderCreateManyAndReturnArgs>(args?: SelectSubset<T, FounderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Founder.
     * @param {FounderDeleteArgs} args - Arguments to delete one Founder.
     * @example
     * // Delete one Founder
     * const Founder = await prisma.founder.delete({
     *   where: {
     *     // ... filter to delete one Founder
     *   }
     * })
     * 
     */
    delete<T extends FounderDeleteArgs>(args: SelectSubset<T, FounderDeleteArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Founder.
     * @param {FounderUpdateArgs} args - Arguments to update one Founder.
     * @example
     * // Update one Founder
     * const founder = await prisma.founder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FounderUpdateArgs>(args: SelectSubset<T, FounderUpdateArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Founders.
     * @param {FounderDeleteManyArgs} args - Arguments to filter Founders to delete.
     * @example
     * // Delete a few Founders
     * const { count } = await prisma.founder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FounderDeleteManyArgs>(args?: SelectSubset<T, FounderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Founders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Founders
     * const founder = await prisma.founder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FounderUpdateManyArgs>(args: SelectSubset<T, FounderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Founders and returns the data updated in the database.
     * @param {FounderUpdateManyAndReturnArgs} args - Arguments to update many Founders.
     * @example
     * // Update many Founders
     * const founder = await prisma.founder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Founders and only return the `id`
     * const founderWithIdOnly = await prisma.founder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FounderUpdateManyAndReturnArgs>(args: SelectSubset<T, FounderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Founder.
     * @param {FounderUpsertArgs} args - Arguments to update or create a Founder.
     * @example
     * // Update or create a Founder
     * const founder = await prisma.founder.upsert({
     *   create: {
     *     // ... data to create a Founder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Founder we want to update
     *   }
     * })
     */
    upsert<T extends FounderUpsertArgs>(args: SelectSubset<T, FounderUpsertArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Founders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderCountArgs} args - Arguments to filter Founders to count.
     * @example
     * // Count the number of Founders
     * const count = await prisma.founder.count({
     *   where: {
     *     // ... the filter for the Founders we want to count
     *   }
     * })
    **/
    count<T extends FounderCountArgs>(
      args?: Subset<T, FounderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FounderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Founder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FounderAggregateArgs>(args: Subset<T, FounderAggregateArgs>): Prisma.PrismaPromise<GetFounderAggregateType<T>>

    /**
     * Group by Founder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FounderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FounderGroupByArgs['orderBy'] }
        : { orderBy?: FounderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FounderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFounderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Founder model
   */
  readonly fields: FounderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Founder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FounderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Founder$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Founder$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crmContacts<T extends Founder$crmContactsArgs<ExtArgs> = {}>(args?: Subset<T, Founder$crmContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapItems<T extends Founder$roadmapItemsArgs<ExtArgs> = {}>(args?: Subset<T, Founder$roadmapItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Founder model
   */
  interface FounderFieldRefs {
    readonly id: FieldRef<"Founder", 'String'>
    readonly athleteId: FieldRef<"Founder", 'String'>
    readonly createdAt: FieldRef<"Founder", 'DateTime'>
    readonly updatedAt: FieldRef<"Founder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Founder findUnique
   */
  export type FounderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder findUniqueOrThrow
   */
  export type FounderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder findFirst
   */
  export type FounderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Founders.
     */
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder findFirstOrThrow
   */
  export type FounderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Founders.
     */
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder findMany
   */
  export type FounderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founders to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder create
   */
  export type FounderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The data needed to create a Founder.
     */
    data: XOR<FounderCreateInput, FounderUncheckedCreateInput>
  }

  /**
   * Founder createMany
   */
  export type FounderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Founders.
     */
    data: FounderCreateManyInput | FounderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Founder createManyAndReturn
   */
  export type FounderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * The data used to create many Founders.
     */
    data: FounderCreateManyInput | FounderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Founder update
   */
  export type FounderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The data needed to update a Founder.
     */
    data: XOR<FounderUpdateInput, FounderUncheckedUpdateInput>
    /**
     * Choose, which Founder to update.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder updateMany
   */
  export type FounderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Founders.
     */
    data: XOR<FounderUpdateManyMutationInput, FounderUncheckedUpdateManyInput>
    /**
     * Filter which Founders to update
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to update.
     */
    limit?: number
  }

  /**
   * Founder updateManyAndReturn
   */
  export type FounderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * The data used to update Founders.
     */
    data: XOR<FounderUpdateManyMutationInput, FounderUncheckedUpdateManyInput>
    /**
     * Filter which Founders to update
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Founder upsert
   */
  export type FounderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The filter to search for the Founder to update in case it exists.
     */
    where: FounderWhereUniqueInput
    /**
     * In case the Founder found by the `where` argument doesn't exist, create a new Founder with this data.
     */
    create: XOR<FounderCreateInput, FounderUncheckedCreateInput>
    /**
     * In case the Founder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FounderUpdateInput, FounderUncheckedUpdateInput>
  }

  /**
   * Founder delete
   */
  export type FounderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter which Founder to delete.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder deleteMany
   */
  export type FounderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Founders to delete
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to delete.
     */
    limit?: number
  }

  /**
   * Founder.tasks
   */
  export type Founder$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    where?: FounderTaskWhereInput
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    cursor?: FounderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * Founder.crmContacts
   */
  export type Founder$crmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    where?: CrmContactWhereInput
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    cursor?: CrmContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * Founder.roadmapItems
   */
  export type Founder$roadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    cursor?: RoadmapItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * Founder without action
   */
  export type FounderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
  }


  /**
   * Model FounderTask
   */

  export type AggregateFounderTask = {
    _count: FounderTaskCountAggregateOutputType | null
    _min: FounderTaskMinAggregateOutputType | null
    _max: FounderTaskMaxAggregateOutputType | null
  }

  export type FounderTaskMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderTaskMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderTaskCountAggregateOutputType = {
    id: number
    founderId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FounderTaskMinAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderTaskMaxAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderTaskCountAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FounderTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderTask to aggregate.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FounderTasks
    **/
    _count?: true | FounderTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FounderTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FounderTaskMaxAggregateInputType
  }

  export type GetFounderTaskAggregateType<T extends FounderTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateFounderTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFounderTask[P]>
      : GetScalarType<T[P], AggregateFounderTask[P]>
  }




  export type FounderTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderTaskWhereInput
    orderBy?: FounderTaskOrderByWithAggregationInput | FounderTaskOrderByWithAggregationInput[]
    by: FounderTaskScalarFieldEnum[] | FounderTaskScalarFieldEnum
    having?: FounderTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FounderTaskCountAggregateInputType | true
    _min?: FounderTaskMinAggregateInputType
    _max?: FounderTaskMaxAggregateInputType
  }

  export type FounderTaskGroupByOutputType = {
    id: string
    founderId: string
    title: string
    description: string | null
    status: string
    priority: string
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FounderTaskCountAggregateOutputType | null
    _min: FounderTaskMinAggregateOutputType | null
    _max: FounderTaskMaxAggregateOutputType | null
  }

  type GetFounderTaskGroupByPayload<T extends FounderTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FounderTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FounderTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FounderTaskGroupByOutputType[P]>
            : GetScalarType<T[P], FounderTaskGroupByOutputType[P]>
        }
      >
    >


  export type FounderTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectScalar = {
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FounderTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "title" | "description" | "status" | "priority" | "dueDate" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["founderTask"]>
  export type FounderTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type FounderTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type FounderTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $FounderTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FounderTask"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      title: string
      description: string | null
      status: string
      priority: string
      dueDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["founderTask"]>
    composites: {}
  }

  type FounderTaskGetPayload<S extends boolean | null | undefined | FounderTaskDefaultArgs> = $Result.GetResult<Prisma.$FounderTaskPayload, S>

  type FounderTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FounderTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FounderTaskCountAggregateInputType | true
    }

  export interface FounderTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FounderTask'], meta: { name: 'FounderTask' } }
    /**
     * Find zero or one FounderTask that matches the filter.
     * @param {FounderTaskFindUniqueArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FounderTaskFindUniqueArgs>(args: SelectSubset<T, FounderTaskFindUniqueArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FounderTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FounderTaskFindUniqueOrThrowArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FounderTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, FounderTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FounderTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindFirstArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FounderTaskFindFirstArgs>(args?: SelectSubset<T, FounderTaskFindFirstArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FounderTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindFirstOrThrowArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FounderTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, FounderTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FounderTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FounderTasks
     * const founderTasks = await prisma.founderTask.findMany()
     * 
     * // Get first 10 FounderTasks
     * const founderTasks = await prisma.founderTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FounderTaskFindManyArgs>(args?: SelectSubset<T, FounderTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FounderTask.
     * @param {FounderTaskCreateArgs} args - Arguments to create a FounderTask.
     * @example
     * // Create one FounderTask
     * const FounderTask = await prisma.founderTask.create({
     *   data: {
     *     // ... data to create a FounderTask
     *   }
     * })
     * 
     */
    create<T extends FounderTaskCreateArgs>(args: SelectSubset<T, FounderTaskCreateArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FounderTasks.
     * @param {FounderTaskCreateManyArgs} args - Arguments to create many FounderTasks.
     * @example
     * // Create many FounderTasks
     * const founderTask = await prisma.founderTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FounderTaskCreateManyArgs>(args?: SelectSubset<T, FounderTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FounderTasks and returns the data saved in the database.
     * @param {FounderTaskCreateManyAndReturnArgs} args - Arguments to create many FounderTasks.
     * @example
     * // Create many FounderTasks
     * const founderTask = await prisma.founderTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FounderTasks and only return the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FounderTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, FounderTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FounderTask.
     * @param {FounderTaskDeleteArgs} args - Arguments to delete one FounderTask.
     * @example
     * // Delete one FounderTask
     * const FounderTask = await prisma.founderTask.delete({
     *   where: {
     *     // ... filter to delete one FounderTask
     *   }
     * })
     * 
     */
    delete<T extends FounderTaskDeleteArgs>(args: SelectSubset<T, FounderTaskDeleteArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FounderTask.
     * @param {FounderTaskUpdateArgs} args - Arguments to update one FounderTask.
     * @example
     * // Update one FounderTask
     * const founderTask = await prisma.founderTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FounderTaskUpdateArgs>(args: SelectSubset<T, FounderTaskUpdateArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FounderTasks.
     * @param {FounderTaskDeleteManyArgs} args - Arguments to filter FounderTasks to delete.
     * @example
     * // Delete a few FounderTasks
     * const { count } = await prisma.founderTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FounderTaskDeleteManyArgs>(args?: SelectSubset<T, FounderTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FounderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FounderTasks
     * const founderTask = await prisma.founderTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FounderTaskUpdateManyArgs>(args: SelectSubset<T, FounderTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FounderTasks and returns the data updated in the database.
     * @param {FounderTaskUpdateManyAndReturnArgs} args - Arguments to update many FounderTasks.
     * @example
     * // Update many FounderTasks
     * const founderTask = await prisma.founderTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FounderTasks and only return the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FounderTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, FounderTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FounderTask.
     * @param {FounderTaskUpsertArgs} args - Arguments to update or create a FounderTask.
     * @example
     * // Update or create a FounderTask
     * const founderTask = await prisma.founderTask.upsert({
     *   create: {
     *     // ... data to create a FounderTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FounderTask we want to update
     *   }
     * })
     */
    upsert<T extends FounderTaskUpsertArgs>(args: SelectSubset<T, FounderTaskUpsertArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FounderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskCountArgs} args - Arguments to filter FounderTasks to count.
     * @example
     * // Count the number of FounderTasks
     * const count = await prisma.founderTask.count({
     *   where: {
     *     // ... the filter for the FounderTasks we want to count
     *   }
     * })
    **/
    count<T extends FounderTaskCountArgs>(
      args?: Subset<T, FounderTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FounderTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FounderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FounderTaskAggregateArgs>(args: Subset<T, FounderTaskAggregateArgs>): Prisma.PrismaPromise<GetFounderTaskAggregateType<T>>

    /**
     * Group by FounderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FounderTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FounderTaskGroupByArgs['orderBy'] }
        : { orderBy?: FounderTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FounderTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFounderTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FounderTask model
   */
  readonly fields: FounderTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FounderTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FounderTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FounderTask model
   */
  interface FounderTaskFieldRefs {
    readonly id: FieldRef<"FounderTask", 'String'>
    readonly founderId: FieldRef<"FounderTask", 'String'>
    readonly title: FieldRef<"FounderTask", 'String'>
    readonly description: FieldRef<"FounderTask", 'String'>
    readonly status: FieldRef<"FounderTask", 'String'>
    readonly priority: FieldRef<"FounderTask", 'String'>
    readonly dueDate: FieldRef<"FounderTask", 'DateTime'>
    readonly completedAt: FieldRef<"FounderTask", 'DateTime'>
    readonly createdAt: FieldRef<"FounderTask", 'DateTime'>
    readonly updatedAt: FieldRef<"FounderTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FounderTask findUnique
   */
  export type FounderTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask findUniqueOrThrow
   */
  export type FounderTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask findFirst
   */
  export type FounderTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderTasks.
     */
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask findFirstOrThrow
   */
  export type FounderTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderTasks.
     */
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask findMany
   */
  export type FounderTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTasks to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask create
   */
  export type FounderTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a FounderTask.
     */
    data: XOR<FounderTaskCreateInput, FounderTaskUncheckedCreateInput>
  }

  /**
   * FounderTask createMany
   */
  export type FounderTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FounderTasks.
     */
    data: FounderTaskCreateManyInput | FounderTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FounderTask createManyAndReturn
   */
  export type FounderTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * The data used to create many FounderTasks.
     */
    data: FounderTaskCreateManyInput | FounderTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FounderTask update
   */
  export type FounderTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a FounderTask.
     */
    data: XOR<FounderTaskUpdateInput, FounderTaskUncheckedUpdateInput>
    /**
     * Choose, which FounderTask to update.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask updateMany
   */
  export type FounderTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FounderTasks.
     */
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyInput>
    /**
     * Filter which FounderTasks to update
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to update.
     */
    limit?: number
  }

  /**
   * FounderTask updateManyAndReturn
   */
  export type FounderTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * The data used to update FounderTasks.
     */
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyInput>
    /**
     * Filter which FounderTasks to update
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FounderTask upsert
   */
  export type FounderTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the FounderTask to update in case it exists.
     */
    where: FounderTaskWhereUniqueInput
    /**
     * In case the FounderTask found by the `where` argument doesn't exist, create a new FounderTask with this data.
     */
    create: XOR<FounderTaskCreateInput, FounderTaskUncheckedCreateInput>
    /**
     * In case the FounderTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FounderTaskUpdateInput, FounderTaskUncheckedUpdateInput>
  }

  /**
   * FounderTask delete
   */
  export type FounderTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter which FounderTask to delete.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask deleteMany
   */
  export type FounderTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderTasks to delete
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to delete.
     */
    limit?: number
  }

  /**
   * FounderTask without action
   */
  export type FounderTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
  }


  /**
   * Model CrmContact
   */

  export type AggregateCrmContact = {
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  export type CrmContactMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    name: string | null
    role: string | null
    email: string | null
    company: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    name: string | null
    role: string | null
    email: string | null
    company: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactCountAggregateOutputType = {
    id: number
    founderId: number
    name: number
    role: number
    email: number
    company: number
    pipeline: number
    status: number
    nextStep: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrmContactMinAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactMaxAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactCountAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrmContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContact to aggregate.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmContacts
    **/
    _count?: true | CrmContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmContactMaxAggregateInputType
  }

  export type GetCrmContactAggregateType<T extends CrmContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmContact[P]>
      : GetScalarType<T[P], AggregateCrmContact[P]>
  }




  export type CrmContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmContactWhereInput
    orderBy?: CrmContactOrderByWithAggregationInput | CrmContactOrderByWithAggregationInput[]
    by: CrmContactScalarFieldEnum[] | CrmContactScalarFieldEnum
    having?: CrmContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmContactCountAggregateInputType | true
    _min?: CrmContactMinAggregateInputType
    _max?: CrmContactMaxAggregateInputType
  }

  export type CrmContactGroupByOutputType = {
    id: string
    founderId: string
    name: string
    role: string | null
    email: string | null
    company: string | null
    pipeline: string
    status: string
    nextStep: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  type GetCrmContactGroupByPayload<T extends CrmContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
            : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
        }
      >
    >


  export type CrmContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectScalar = {
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrmContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "name" | "role" | "email" | "company" | "pipeline" | "status" | "nextStep" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["crmContact"]>
  export type CrmContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CrmContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CrmContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $CrmContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmContact"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      name: string
      role: string | null
      email: string | null
      company: string | null
      pipeline: string
      status: string
      nextStep: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crmContact"]>
    composites: {}
  }

  type CrmContactGetPayload<S extends boolean | null | undefined | CrmContactDefaultArgs> = $Result.GetResult<Prisma.$CrmContactPayload, S>

  type CrmContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrmContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrmContactCountAggregateInputType | true
    }

  export interface CrmContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmContact'], meta: { name: 'CrmContact' } }
    /**
     * Find zero or one CrmContact that matches the filter.
     * @param {CrmContactFindUniqueArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmContactFindUniqueArgs>(args: SelectSubset<T, CrmContactFindUniqueArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrmContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrmContactFindUniqueOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrmContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmContactFindFirstArgs>(args?: SelectSubset<T, CrmContactFindFirstArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrmContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrmContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmContacts
     * const crmContacts = await prisma.crmContact.findMany()
     * 
     * // Get first 10 CrmContacts
     * const crmContacts = await prisma.crmContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmContactFindManyArgs>(args?: SelectSubset<T, CrmContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrmContact.
     * @param {CrmContactCreateArgs} args - Arguments to create a CrmContact.
     * @example
     * // Create one CrmContact
     * const CrmContact = await prisma.crmContact.create({
     *   data: {
     *     // ... data to create a CrmContact
     *   }
     * })
     * 
     */
    create<T extends CrmContactCreateArgs>(args: SelectSubset<T, CrmContactCreateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrmContacts.
     * @param {CrmContactCreateManyArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmContactCreateManyArgs>(args?: SelectSubset<T, CrmContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmContacts and returns the data saved in the database.
     * @param {CrmContactCreateManyAndReturnArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmContacts and only return the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrmContact.
     * @param {CrmContactDeleteArgs} args - Arguments to delete one CrmContact.
     * @example
     * // Delete one CrmContact
     * const CrmContact = await prisma.crmContact.delete({
     *   where: {
     *     // ... filter to delete one CrmContact
     *   }
     * })
     * 
     */
    delete<T extends CrmContactDeleteArgs>(args: SelectSubset<T, CrmContactDeleteArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrmContact.
     * @param {CrmContactUpdateArgs} args - Arguments to update one CrmContact.
     * @example
     * // Update one CrmContact
     * const crmContact = await prisma.crmContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmContactUpdateArgs>(args: SelectSubset<T, CrmContactUpdateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrmContacts.
     * @param {CrmContactDeleteManyArgs} args - Arguments to filter CrmContacts to delete.
     * @example
     * // Delete a few CrmContacts
     * const { count } = await prisma.crmContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmContactDeleteManyArgs>(args?: SelectSubset<T, CrmContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmContacts
     * const crmContact = await prisma.crmContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmContactUpdateManyArgs>(args: SelectSubset<T, CrmContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmContacts and returns the data updated in the database.
     * @param {CrmContactUpdateManyAndReturnArgs} args - Arguments to update many CrmContacts.
     * @example
     * // Update many CrmContacts
     * const crmContact = await prisma.crmContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrmContacts and only return the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrmContactUpdateManyAndReturnArgs>(args: SelectSubset<T, CrmContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrmContact.
     * @param {CrmContactUpsertArgs} args - Arguments to update or create a CrmContact.
     * @example
     * // Update or create a CrmContact
     * const crmContact = await prisma.crmContact.upsert({
     *   create: {
     *     // ... data to create a CrmContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmContact we want to update
     *   }
     * })
     */
    upsert<T extends CrmContactUpsertArgs>(args: SelectSubset<T, CrmContactUpsertArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactCountArgs} args - Arguments to filter CrmContacts to count.
     * @example
     * // Count the number of CrmContacts
     * const count = await prisma.crmContact.count({
     *   where: {
     *     // ... the filter for the CrmContacts we want to count
     *   }
     * })
    **/
    count<T extends CrmContactCountArgs>(
      args?: Subset<T, CrmContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmContactAggregateArgs>(args: Subset<T, CrmContactAggregateArgs>): Prisma.PrismaPromise<GetCrmContactAggregateType<T>>

    /**
     * Group by CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmContactGroupByArgs['orderBy'] }
        : { orderBy?: CrmContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmContact model
   */
  readonly fields: CrmContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmContact model
   */
  interface CrmContactFieldRefs {
    readonly id: FieldRef<"CrmContact", 'String'>
    readonly founderId: FieldRef<"CrmContact", 'String'>
    readonly name: FieldRef<"CrmContact", 'String'>
    readonly role: FieldRef<"CrmContact", 'String'>
    readonly email: FieldRef<"CrmContact", 'String'>
    readonly company: FieldRef<"CrmContact", 'String'>
    readonly pipeline: FieldRef<"CrmContact", 'String'>
    readonly status: FieldRef<"CrmContact", 'String'>
    readonly nextStep: FieldRef<"CrmContact", 'String'>
    readonly notes: FieldRef<"CrmContact", 'String'>
    readonly createdAt: FieldRef<"CrmContact", 'DateTime'>
    readonly updatedAt: FieldRef<"CrmContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmContact findUnique
   */
  export type CrmContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findUniqueOrThrow
   */
  export type CrmContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findFirst
   */
  export type CrmContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findFirstOrThrow
   */
  export type CrmContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findMany
   */
  export type CrmContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContacts to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact create
   */
  export type CrmContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmContact.
     */
    data: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
  }

  /**
   * CrmContact createMany
   */
  export type CrmContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmContact createManyAndReturn
   */
  export type CrmContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmContact update
   */
  export type CrmContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmContact.
     */
    data: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
    /**
     * Choose, which CrmContact to update.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact updateMany
   */
  export type CrmContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmContacts.
     */
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CrmContacts to update
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to update.
     */
    limit?: number
  }

  /**
   * CrmContact updateManyAndReturn
   */
  export type CrmContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * The data used to update CrmContacts.
     */
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CrmContacts to update
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmContact upsert
   */
  export type CrmContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmContact to update in case it exists.
     */
    where: CrmContactWhereUniqueInput
    /**
     * In case the CrmContact found by the `where` argument doesn't exist, create a new CrmContact with this data.
     */
    create: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
    /**
     * In case the CrmContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
  }

  /**
   * CrmContact delete
   */
  export type CrmContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter which CrmContact to delete.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact deleteMany
   */
  export type CrmContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContacts to delete
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to delete.
     */
    limit?: number
  }

  /**
   * CrmContact without action
   */
  export type CrmContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapItem
   */

  export type AggregateRoadmapItem = {
    _count: RoadmapItemCountAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  export type RoadmapItemMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    roadmapType: string | null
    quarter: string | null
    category: string | null
    title: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    roadmapType: string | null
    quarter: string | null
    category: string | null
    title: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemCountAggregateOutputType = {
    id: number
    founderId: number
    roadmapType: number
    quarter: number
    category: number
    title: number
    description: number
    status: number
    dueDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapItemMinAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemMaxAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemCountAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItem to aggregate.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapItems
    **/
    _count?: true | RoadmapItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type GetRoadmapItemAggregateType<T extends RoadmapItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapItem[P]>
      : GetScalarType<T[P], AggregateRoadmapItem[P]>
  }




  export type RoadmapItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithAggregationInput | RoadmapItemOrderByWithAggregationInput[]
    by: RoadmapItemScalarFieldEnum[] | RoadmapItemScalarFieldEnum
    having?: RoadmapItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapItemCountAggregateInputType | true
    _min?: RoadmapItemMinAggregateInputType
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type RoadmapItemGroupByOutputType = {
    id: string
    founderId: string
    roadmapType: string
    quarter: string | null
    category: string | null
    title: string
    description: string | null
    status: string
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoadmapItemCountAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  type GetRoadmapItemGroupByPayload<T extends RoadmapItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectScalar = {
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "roadmapType" | "quarter" | "category" | "title" | "description" | "status" | "dueDate" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["roadmapItem"]>
  export type RoadmapItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type RoadmapItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type RoadmapItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $RoadmapItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapItem"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      roadmapType: string
      quarter: string | null
      category: string | null
      title: string
      description: string | null
      status: string
      dueDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapItem"]>
    composites: {}
  }

  type RoadmapItemGetPayload<S extends boolean | null | undefined | RoadmapItemDefaultArgs> = $Result.GetResult<Prisma.$RoadmapItemPayload, S>

  type RoadmapItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapItemCountAggregateInputType | true
    }

  export interface RoadmapItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapItem'], meta: { name: 'RoadmapItem' } }
    /**
     * Find zero or one RoadmapItem that matches the filter.
     * @param {RoadmapItemFindUniqueArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapItemFindUniqueArgs>(args: SelectSubset<T, RoadmapItemFindUniqueArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapItemFindUniqueOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapItemFindFirstArgs>(args?: SelectSubset<T, RoadmapItemFindFirstArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany()
     * 
     * // Get first 10 RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapItemFindManyArgs>(args?: SelectSubset<T, RoadmapItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapItem.
     * @param {RoadmapItemCreateArgs} args - Arguments to create a RoadmapItem.
     * @example
     * // Create one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.create({
     *   data: {
     *     // ... data to create a RoadmapItem
     *   }
     * })
     * 
     */
    create<T extends RoadmapItemCreateArgs>(args: SelectSubset<T, RoadmapItemCreateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapItems.
     * @param {RoadmapItemCreateManyArgs} args - Arguments to create many RoadmapItems.
     * @example
     * // Create many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapItemCreateManyArgs>(args?: SelectSubset<T, RoadmapItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapItems and returns the data saved in the database.
     * @param {RoadmapItemCreateManyAndReturnArgs} args - Arguments to create many RoadmapItems.
     * @example
     * // Create many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapItems and only return the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoadmapItem.
     * @param {RoadmapItemDeleteArgs} args - Arguments to delete one RoadmapItem.
     * @example
     * // Delete one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.delete({
     *   where: {
     *     // ... filter to delete one RoadmapItem
     *   }
     * })
     * 
     */
    delete<T extends RoadmapItemDeleteArgs>(args: SelectSubset<T, RoadmapItemDeleteArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapItem.
     * @param {RoadmapItemUpdateArgs} args - Arguments to update one RoadmapItem.
     * @example
     * // Update one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapItemUpdateArgs>(args: SelectSubset<T, RoadmapItemUpdateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapItems.
     * @param {RoadmapItemDeleteManyArgs} args - Arguments to filter RoadmapItems to delete.
     * @example
     * // Delete a few RoadmapItems
     * const { count } = await prisma.roadmapItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapItemDeleteManyArgs>(args?: SelectSubset<T, RoadmapItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapItemUpdateManyArgs>(args: SelectSubset<T, RoadmapItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapItems and returns the data updated in the database.
     * @param {RoadmapItemUpdateManyAndReturnArgs} args - Arguments to update many RoadmapItems.
     * @example
     * // Update many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoadmapItems and only return the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoadmapItem.
     * @param {RoadmapItemUpsertArgs} args - Arguments to update or create a RoadmapItem.
     * @example
     * // Update or create a RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.upsert({
     *   create: {
     *     // ... data to create a RoadmapItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapItem we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapItemUpsertArgs>(args: SelectSubset<T, RoadmapItemUpsertArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemCountArgs} args - Arguments to filter RoadmapItems to count.
     * @example
     * // Count the number of RoadmapItems
     * const count = await prisma.roadmapItem.count({
     *   where: {
     *     // ... the filter for the RoadmapItems we want to count
     *   }
     * })
    **/
    count<T extends RoadmapItemCountArgs>(
      args?: Subset<T, RoadmapItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapItemAggregateArgs>(args: Subset<T, RoadmapItemAggregateArgs>): Prisma.PrismaPromise<GetRoadmapItemAggregateType<T>>

    /**
     * Group by RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapItemGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapItem model
   */
  readonly fields: RoadmapItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapItem model
   */
  interface RoadmapItemFieldRefs {
    readonly id: FieldRef<"RoadmapItem", 'String'>
    readonly founderId: FieldRef<"RoadmapItem", 'String'>
    readonly roadmapType: FieldRef<"RoadmapItem", 'String'>
    readonly quarter: FieldRef<"RoadmapItem", 'String'>
    readonly category: FieldRef<"RoadmapItem", 'String'>
    readonly title: FieldRef<"RoadmapItem", 'String'>
    readonly description: FieldRef<"RoadmapItem", 'String'>
    readonly status: FieldRef<"RoadmapItem", 'String'>
    readonly dueDate: FieldRef<"RoadmapItem", 'DateTime'>
    readonly completedAt: FieldRef<"RoadmapItem", 'DateTime'>
    readonly createdAt: FieldRef<"RoadmapItem", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapItem findUnique
   */
  export type RoadmapItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findUniqueOrThrow
   */
  export type RoadmapItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findFirst
   */
  export type RoadmapItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findFirstOrThrow
   */
  export type RoadmapItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findMany
   */
  export type RoadmapItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItems to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem create
   */
  export type RoadmapItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapItem.
     */
    data: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
  }

  /**
   * RoadmapItem createMany
   */
  export type RoadmapItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapItems.
     */
    data: RoadmapItemCreateManyInput | RoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapItem createManyAndReturn
   */
  export type RoadmapItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to create many RoadmapItems.
     */
    data: RoadmapItemCreateManyInput | RoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapItem update
   */
  export type RoadmapItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapItem.
     */
    data: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
    /**
     * Choose, which RoadmapItem to update.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem updateMany
   */
  export type RoadmapItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapItems.
     */
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapItems to update
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to update.
     */
    limit?: number
  }

  /**
   * RoadmapItem updateManyAndReturn
   */
  export type RoadmapItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to update RoadmapItems.
     */
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapItems to update
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapItem upsert
   */
  export type RoadmapItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapItem to update in case it exists.
     */
    where: RoadmapItemWhereUniqueInput
    /**
     * In case the RoadmapItem found by the `where` argument doesn't exist, create a new RoadmapItem with this data.
     */
    create: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
    /**
     * In case the RoadmapItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
  }

  /**
   * RoadmapItem delete
   */
  export type RoadmapItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter which RoadmapItem to delete.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem deleteMany
   */
  export type RoadmapItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItems to delete
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to delete.
     */
    limit?: number
  }

  /**
   * RoadmapItem without action
   */
  export type RoadmapItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AthleteScalarFieldEnum: {
    id: 'id',
    firebaseId: 'firebaseId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    gofastHandle: 'gofastHandle',
    birthday: 'birthday',
    gender: 'gender',
    city: 'city',
    state: 'state',
    primarySport: 'primarySport',
    photoURL: 'photoURL',
    bio: 'bio',
    instagram: 'instagram',
    currentPace: 'currentPace',
    weeklyMileage: 'weeklyMileage',
    trainingGoal: 'trainingGoal',
    targetRace: 'targetRace',
    trainingStartDate: 'trainingStartDate',
    preferredDistance: 'preferredDistance',
    timePreference: 'timePreference',
    paceRange: 'paceRange',
    runningGoals: 'runningGoals',
    garmin_user_id: 'garmin_user_id',
    garmin_access_token: 'garmin_access_token',
    garmin_refresh_token: 'garmin_refresh_token',
    garmin_expires_in: 'garmin_expires_in',
    garmin_scope: 'garmin_scope',
    garmin_connected_at: 'garmin_connected_at',
    garmin_last_sync_at: 'garmin_last_sync_at',
    garmin_permissions: 'garmin_permissions',
    garmin_is_connected: 'garmin_is_connected',
    garmin_disconnected_at: 'garmin_disconnected_at',
    strava_id: 'strava_id',
    strava_access_token: 'strava_access_token',
    strava_refresh_token: 'strava_refresh_token',
    strava_expires_at: 'strava_expires_at',
    garmin_user_profile: 'garmin_user_profile',
    garmin_user_sleep: 'garmin_user_sleep',
    garmin_user_preferences: 'garmin_user_preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AthleteScalarFieldEnum = (typeof AthleteScalarFieldEnum)[keyof typeof AthleteScalarFieldEnum]


  export const AthleteActivityScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    sourceActivityId: 'sourceActivityId',
    source: 'source',
    activityType: 'activityType',
    activityName: 'activityName',
    startTime: 'startTime',
    duration: 'duration',
    distance: 'distance',
    averageSpeed: 'averageSpeed',
    calories: 'calories',
    averageHeartRate: 'averageHeartRate',
    maxHeartRate: 'maxHeartRate',
    elevationGain: 'elevationGain',
    steps: 'steps',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    summaryPolyline: 'summaryPolyline',
    deviceName: 'deviceName',
    garminUserId: 'garminUserId',
    summaryData: 'summaryData',
    detailData: 'detailData',
    hydratedAt: 'hydratedAt',
    syncedAt: 'syncedAt',
    lastUpdatedAt: 'lastUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AthleteActivityScalarFieldEnum = (typeof AthleteActivityScalarFieldEnum)[keyof typeof AthleteActivityScalarFieldEnum]


  export const RunCrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    joinCode: 'joinCode',
    logo: 'logo',
    runcrewAdminId: 'runcrewAdminId',
    isArchived: 'isArchived',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewScalarFieldEnum = (typeof RunCrewScalarFieldEnum)[keyof typeof RunCrewScalarFieldEnum]


  export const RunCrewMembershipScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewMembershipScalarFieldEnum = (typeof RunCrewMembershipScalarFieldEnum)[keyof typeof RunCrewMembershipScalarFieldEnum]


  export const RunCrewPostScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    content: 'content',
    imageUrl: 'imageUrl',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewPostScalarFieldEnum = (typeof RunCrewPostScalarFieldEnum)[keyof typeof RunCrewPostScalarFieldEnum]


  export const RunCrewPostCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    athleteId: 'athleteId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewPostCommentScalarFieldEnum = (typeof RunCrewPostCommentScalarFieldEnum)[keyof typeof RunCrewPostCommentScalarFieldEnum]


  export const RunCrewLeaderboardScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    totalMiles: 'totalMiles',
    totalRuns: 'totalRuns',
    bestPace: 'bestPace',
    totalCalories: 'totalCalories',
    totalElevation: 'totalElevation',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewLeaderboardScalarFieldEnum = (typeof RunCrewLeaderboardScalarFieldEnum)[keyof typeof RunCrewLeaderboardScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    id: 'id',
    raceName: 'raceName',
    raceType: 'raceType',
    raceDate: 'raceDate',
    location: 'location',
    distanceMiles: 'distanceMiles',
    registrationUrl: 'registrationUrl',
    description: 'description',
    courseProfile: 'courseProfile',
    createdByAthleteId: 'createdByAthleteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const TrainingPlanScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    raceId: 'raceId',
    goalTime: 'goalTime',
    goalPace: 'goalPace',
    baseline5k: 'baseline5k',
    baselineWeeklyMileage: 'baselineWeeklyMileage',
    startDate: 'startDate',
    totalWeeks: 'totalWeeks',
    phaseOverview: 'phaseOverview',
    weeklyMileagePlan: 'weeklyMileagePlan',
    weeks: 'weeks',
    adaptive5kTime: 'adaptive5kTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingPlanScalarFieldEnum = (typeof TrainingPlanScalarFieldEnum)[keyof typeof TrainingPlanScalarFieldEnum]


  export const TrainingDayPlannedScalarFieldEnum: {
    id: 'id',
    trainingPlanId: 'trainingPlanId',
    athleteId: 'athleteId',
    date: 'date',
    weekIndex: 'weekIndex',
    dayIndex: 'dayIndex',
    dayName: 'dayName',
    phase: 'phase',
    plannedData: 'plannedData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDayPlannedScalarFieldEnum = (typeof TrainingDayPlannedScalarFieldEnum)[keyof typeof TrainingDayPlannedScalarFieldEnum]


  export const TrainingPlanExecutionScalarFieldEnum: {
    id: 'id',
    trainingPlanId: 'trainingPlanId',
    startedAt: 'startedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingPlanExecutionScalarFieldEnum = (typeof TrainingPlanExecutionScalarFieldEnum)[keyof typeof TrainingPlanExecutionScalarFieldEnum]


  export const TrainingDayExecutedScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    athleteId: 'athleteId',
    activityId: 'activityId',
    weekIndex: 'weekIndex',
    dayIndex: 'dayIndex',
    date: 'date',
    plannedData: 'plannedData',
    analysis: 'analysis',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDayExecutedScalarFieldEnum = (typeof TrainingDayExecutedScalarFieldEnum)[keyof typeof TrainingDayExecutedScalarFieldEnum]


  export const FounderScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FounderScalarFieldEnum = (typeof FounderScalarFieldEnum)[keyof typeof FounderScalarFieldEnum]


  export const FounderTaskScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FounderTaskScalarFieldEnum = (typeof FounderTaskScalarFieldEnum)[keyof typeof FounderTaskScalarFieldEnum]


  export const CrmContactScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    name: 'name',
    role: 'role',
    email: 'email',
    company: 'company',
    pipeline: 'pipeline',
    status: 'status',
    nextStep: 'nextStep',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrmContactScalarFieldEnum = (typeof CrmContactScalarFieldEnum)[keyof typeof CrmContactScalarFieldEnum]


  export const RoadmapItemScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    roadmapType: 'roadmapType',
    quarter: 'quarter',
    category: 'category',
    title: 'title',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapItemScalarFieldEnum = (typeof RoadmapItemScalarFieldEnum)[keyof typeof RoadmapItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AthleteWhereInput = {
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    id?: StringFilter<"Athlete"> | string
    firebaseId?: StringFilter<"Athlete"> | string
    firstName?: StringNullableFilter<"Athlete"> | string | null
    lastName?: StringNullableFilter<"Athlete"> | string | null
    email?: StringFilter<"Athlete"> | string
    phoneNumber?: StringNullableFilter<"Athlete"> | string | null
    gofastHandle?: StringNullableFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    gender?: StringNullableFilter<"Athlete"> | string | null
    city?: StringNullableFilter<"Athlete"> | string | null
    state?: StringNullableFilter<"Athlete"> | string | null
    primarySport?: StringNullableFilter<"Athlete"> | string | null
    photoURL?: StringNullableFilter<"Athlete"> | string | null
    bio?: StringNullableFilter<"Athlete"> | string | null
    instagram?: StringNullableFilter<"Athlete"> | string | null
    currentPace?: StringNullableFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableFilter<"Athlete"> | string | null
    targetRace?: StringNullableFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableFilter<"Athlete"> | string | null
    timePreference?: StringNullableFilter<"Athlete"> | string | null
    paceRange?: StringNullableFilter<"Athlete"> | string | null
    runningGoals?: StringNullableFilter<"Athlete"> | string | null
    garmin_user_id?: StringNullableFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableFilter<"Athlete">
    garmin_is_connected?: BoolFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    strava_id?: IntNullableFilter<"Athlete"> | number | null
    strava_access_token?: StringNullableFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableFilter<"Athlete">
    garmin_user_sleep?: JsonNullableFilter<"Athlete">
    garmin_user_preferences?: JsonNullableFilter<"Athlete">
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeFilter<"Athlete"> | Date | string
    status?: StringNullableFilter<"Athlete"> | string | null
    activities?: AthleteActivityListRelationFilter
    adminRunCrews?: RunCrewListRelationFilter
    runCrewMemberships?: RunCrewMembershipListRelationFilter
    runCrewPosts?: RunCrewPostListRelationFilter
    runCrewPostComments?: RunCrewPostCommentListRelationFilter
    runCrewLeaderboards?: RunCrewLeaderboardListRelationFilter
    createdRaces?: RaceListRelationFilter
    trainingPlans?: TrainingPlanListRelationFilter
    plannedDays?: TrainingDayPlannedListRelationFilter
    executedDays?: TrainingDayExecutedListRelationFilter
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
  }

  export type AthleteOrderByWithRelationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    gofastHandle?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    primarySport?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    currentPace?: SortOrderInput | SortOrder
    weeklyMileage?: SortOrderInput | SortOrder
    trainingGoal?: SortOrderInput | SortOrder
    targetRace?: SortOrderInput | SortOrder
    trainingStartDate?: SortOrderInput | SortOrder
    preferredDistance?: SortOrderInput | SortOrder
    timePreference?: SortOrderInput | SortOrder
    paceRange?: SortOrderInput | SortOrder
    runningGoals?: SortOrderInput | SortOrder
    garmin_user_id?: SortOrderInput | SortOrder
    garmin_access_token?: SortOrderInput | SortOrder
    garmin_refresh_token?: SortOrderInput | SortOrder
    garmin_expires_in?: SortOrderInput | SortOrder
    garmin_scope?: SortOrderInput | SortOrder
    garmin_connected_at?: SortOrderInput | SortOrder
    garmin_last_sync_at?: SortOrderInput | SortOrder
    garmin_permissions?: SortOrderInput | SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrderInput | SortOrder
    strava_id?: SortOrderInput | SortOrder
    strava_access_token?: SortOrderInput | SortOrder
    strava_refresh_token?: SortOrderInput | SortOrder
    strava_expires_at?: SortOrderInput | SortOrder
    garmin_user_profile?: SortOrderInput | SortOrder
    garmin_user_sleep?: SortOrderInput | SortOrder
    garmin_user_preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    activities?: AthleteActivityOrderByRelationAggregateInput
    adminRunCrews?: RunCrewOrderByRelationAggregateInput
    runCrewMemberships?: RunCrewMembershipOrderByRelationAggregateInput
    runCrewPosts?: RunCrewPostOrderByRelationAggregateInput
    runCrewPostComments?: RunCrewPostCommentOrderByRelationAggregateInput
    runCrewLeaderboards?: RunCrewLeaderboardOrderByRelationAggregateInput
    createdRaces?: RaceOrderByRelationAggregateInput
    trainingPlans?: TrainingPlanOrderByRelationAggregateInput
    plannedDays?: TrainingDayPlannedOrderByRelationAggregateInput
    executedDays?: TrainingDayExecutedOrderByRelationAggregateInput
    founder?: FounderOrderByWithRelationInput
  }

  export type AthleteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firebaseId?: string
    email?: string
    gofastHandle?: string
    garmin_user_id?: string
    strava_id?: number
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    firstName?: StringNullableFilter<"Athlete"> | string | null
    lastName?: StringNullableFilter<"Athlete"> | string | null
    phoneNumber?: StringNullableFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    gender?: StringNullableFilter<"Athlete"> | string | null
    city?: StringNullableFilter<"Athlete"> | string | null
    state?: StringNullableFilter<"Athlete"> | string | null
    primarySport?: StringNullableFilter<"Athlete"> | string | null
    photoURL?: StringNullableFilter<"Athlete"> | string | null
    bio?: StringNullableFilter<"Athlete"> | string | null
    instagram?: StringNullableFilter<"Athlete"> | string | null
    currentPace?: StringNullableFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableFilter<"Athlete"> | string | null
    targetRace?: StringNullableFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableFilter<"Athlete"> | string | null
    timePreference?: StringNullableFilter<"Athlete"> | string | null
    paceRange?: StringNullableFilter<"Athlete"> | string | null
    runningGoals?: StringNullableFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableFilter<"Athlete">
    garmin_is_connected?: BoolFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    strava_access_token?: StringNullableFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableFilter<"Athlete">
    garmin_user_sleep?: JsonNullableFilter<"Athlete">
    garmin_user_preferences?: JsonNullableFilter<"Athlete">
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeFilter<"Athlete"> | Date | string
    status?: StringNullableFilter<"Athlete"> | string | null
    activities?: AthleteActivityListRelationFilter
    adminRunCrews?: RunCrewListRelationFilter
    runCrewMemberships?: RunCrewMembershipListRelationFilter
    runCrewPosts?: RunCrewPostListRelationFilter
    runCrewPostComments?: RunCrewPostCommentListRelationFilter
    runCrewLeaderboards?: RunCrewLeaderboardListRelationFilter
    createdRaces?: RaceListRelationFilter
    trainingPlans?: TrainingPlanListRelationFilter
    plannedDays?: TrainingDayPlannedListRelationFilter
    executedDays?: TrainingDayExecutedListRelationFilter
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
  }, "id" | "firebaseId" | "email" | "gofastHandle" | "garmin_user_id" | "strava_id">

  export type AthleteOrderByWithAggregationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    gofastHandle?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    primarySport?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    currentPace?: SortOrderInput | SortOrder
    weeklyMileage?: SortOrderInput | SortOrder
    trainingGoal?: SortOrderInput | SortOrder
    targetRace?: SortOrderInput | SortOrder
    trainingStartDate?: SortOrderInput | SortOrder
    preferredDistance?: SortOrderInput | SortOrder
    timePreference?: SortOrderInput | SortOrder
    paceRange?: SortOrderInput | SortOrder
    runningGoals?: SortOrderInput | SortOrder
    garmin_user_id?: SortOrderInput | SortOrder
    garmin_access_token?: SortOrderInput | SortOrder
    garmin_refresh_token?: SortOrderInput | SortOrder
    garmin_expires_in?: SortOrderInput | SortOrder
    garmin_scope?: SortOrderInput | SortOrder
    garmin_connected_at?: SortOrderInput | SortOrder
    garmin_last_sync_at?: SortOrderInput | SortOrder
    garmin_permissions?: SortOrderInput | SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrderInput | SortOrder
    strava_id?: SortOrderInput | SortOrder
    strava_access_token?: SortOrderInput | SortOrder
    strava_refresh_token?: SortOrderInput | SortOrder
    strava_expires_at?: SortOrderInput | SortOrder
    garmin_user_profile?: SortOrderInput | SortOrder
    garmin_user_sleep?: SortOrderInput | SortOrder
    garmin_user_preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: AthleteCountOrderByAggregateInput
    _avg?: AthleteAvgOrderByAggregateInput
    _max?: AthleteMaxOrderByAggregateInput
    _min?: AthleteMinOrderByAggregateInput
    _sum?: AthleteSumOrderByAggregateInput
  }

  export type AthleteScalarWhereWithAggregatesInput = {
    AND?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    OR?: AthleteScalarWhereWithAggregatesInput[]
    NOT?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Athlete"> | string
    firebaseId?: StringWithAggregatesFilter<"Athlete"> | string
    firstName?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    email?: StringWithAggregatesFilter<"Athlete"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    gofastHandle?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    city?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    state?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    primarySport?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    photoURL?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    currentPace?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    targetRace?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    timePreference?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    paceRange?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    runningGoals?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_user_id?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_is_connected?: BoolWithAggregatesFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    strava_id?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    strava_access_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_user_sleep?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_user_preferences?: JsonNullableWithAggregatesFilter<"Athlete">
    createdAt?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    status?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
  }

  export type AthleteActivityWhereInput = {
    AND?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    OR?: AthleteActivityWhereInput[]
    NOT?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    id?: StringFilter<"AthleteActivity"> | string
    athleteId?: StringFilter<"AthleteActivity"> | string
    sourceActivityId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type AthleteActivityOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrderInput | SortOrder
    activityName?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    averageHeartRate?: SortOrderInput | SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    elevationGain?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    summaryPolyline?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    garminUserId?: SortOrderInput | SortOrder
    summaryData?: SortOrderInput | SortOrder
    detailData?: SortOrderInput | SortOrder
    hydratedAt?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
  }

  export type AthleteActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceActivityId?: string
    AND?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    OR?: AthleteActivityWhereInput[]
    NOT?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    athleteId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "sourceActivityId">

  export type AthleteActivityOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrderInput | SortOrder
    activityName?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    averageHeartRate?: SortOrderInput | SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    elevationGain?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    summaryPolyline?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    garminUserId?: SortOrderInput | SortOrder
    summaryData?: SortOrderInput | SortOrder
    detailData?: SortOrderInput | SortOrder
    hydratedAt?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AthleteActivityCountOrderByAggregateInput
    _avg?: AthleteActivityAvgOrderByAggregateInput
    _max?: AthleteActivityMaxOrderByAggregateInput
    _min?: AthleteActivityMinOrderByAggregateInput
    _sum?: AthleteActivitySumOrderByAggregateInput
  }

  export type AthleteActivityScalarWhereWithAggregatesInput = {
    AND?: AthleteActivityScalarWhereWithAggregatesInput | AthleteActivityScalarWhereWithAggregatesInput[]
    OR?: AthleteActivityScalarWhereWithAggregatesInput[]
    NOT?: AthleteActivityScalarWhereWithAggregatesInput | AthleteActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AthleteActivity"> | string
    athleteId?: StringWithAggregatesFilter<"AthleteActivity"> | string
    sourceActivityId?: StringWithAggregatesFilter<"AthleteActivity"> | string
    source?: StringWithAggregatesFilter<"AthleteActivity"> | string
    activityType?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableWithAggregatesFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    calories?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    steps?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableWithAggregatesFilter<"AthleteActivity">
    detailData?: JsonNullableWithAggregatesFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableWithAggregatesFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
  }

  export type RunCrewWhereInput = {
    AND?: RunCrewWhereInput | RunCrewWhereInput[]
    OR?: RunCrewWhereInput[]
    NOT?: RunCrewWhereInput | RunCrewWhereInput[]
    id?: StringFilter<"RunCrew"> | string
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    joinCode?: StringFilter<"RunCrew"> | string
    logo?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringFilter<"RunCrew"> | string
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
    admin?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    memberships?: RunCrewMembershipListRelationFilter
    posts?: RunCrewPostListRelationFilter
    leaderboardEntries?: RunCrewLeaderboardListRelationFilter
  }

  export type RunCrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    joinCode?: SortOrder
    logo?: SortOrderInput | SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AthleteOrderByWithRelationInput
    memberships?: RunCrewMembershipOrderByRelationAggregateInput
    posts?: RunCrewPostOrderByRelationAggregateInput
    leaderboardEntries?: RunCrewLeaderboardOrderByRelationAggregateInput
  }

  export type RunCrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    joinCode?: string
    AND?: RunCrewWhereInput | RunCrewWhereInput[]
    OR?: RunCrewWhereInput[]
    NOT?: RunCrewWhereInput | RunCrewWhereInput[]
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    logo?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringFilter<"RunCrew"> | string
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
    admin?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    memberships?: RunCrewMembershipListRelationFilter
    posts?: RunCrewPostListRelationFilter
    leaderboardEntries?: RunCrewLeaderboardListRelationFilter
  }, "id" | "joinCode">

  export type RunCrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    joinCode?: SortOrder
    logo?: SortOrderInput | SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewCountOrderByAggregateInput
    _max?: RunCrewMaxOrderByAggregateInput
    _min?: RunCrewMinOrderByAggregateInput
  }

  export type RunCrewScalarWhereWithAggregatesInput = {
    AND?: RunCrewScalarWhereWithAggregatesInput | RunCrewScalarWhereWithAggregatesInput[]
    OR?: RunCrewScalarWhereWithAggregatesInput[]
    NOT?: RunCrewScalarWhereWithAggregatesInput | RunCrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrew"> | string
    name?: StringWithAggregatesFilter<"RunCrew"> | string
    description?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    joinCode?: StringWithAggregatesFilter<"RunCrew"> | string
    logo?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringWithAggregatesFilter<"RunCrew"> | string
    isArchived?: BoolWithAggregatesFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrew"> | Date | string
  }

  export type RunCrewMembershipWhereInput = {
    AND?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    OR?: RunCrewMembershipWhereInput[]
    NOT?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    id?: StringFilter<"RunCrewMembership"> | string
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewMembershipOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runCrewId_athleteId?: RunCrewMembershipRunCrewIdAthleteIdCompoundUniqueInput
    AND?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    OR?: RunCrewMembershipWhereInput[]
    NOT?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runCrewId_athleteId">

  export type RunCrewMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewMembershipCountOrderByAggregateInput
    _max?: RunCrewMembershipMaxOrderByAggregateInput
    _min?: RunCrewMembershipMinOrderByAggregateInput
  }

  export type RunCrewMembershipScalarWhereWithAggregatesInput = {
    AND?: RunCrewMembershipScalarWhereWithAggregatesInput | RunCrewMembershipScalarWhereWithAggregatesInput[]
    OR?: RunCrewMembershipScalarWhereWithAggregatesInput[]
    NOT?: RunCrewMembershipScalarWhereWithAggregatesInput | RunCrewMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
  }

  export type RunCrewPostWhereInput = {
    AND?: RunCrewPostWhereInput | RunCrewPostWhereInput[]
    OR?: RunCrewPostWhereInput[]
    NOT?: RunCrewPostWhereInput | RunCrewPostWhereInput[]
    id?: StringFilter<"RunCrewPost"> | string
    runCrewId?: StringFilter<"RunCrewPost"> | string
    athleteId?: StringFilter<"RunCrewPost"> | string
    content?: StringFilter<"RunCrewPost"> | string
    imageUrl?: StringNullableFilter<"RunCrewPost"> | string | null
    likes?: IntFilter<"RunCrewPost"> | number
    createdAt?: DateTimeFilter<"RunCrewPost"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPost"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    comments?: RunCrewPostCommentListRelationFilter
  }

  export type RunCrewPostOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
    comments?: RunCrewPostCommentOrderByRelationAggregateInput
  }

  export type RunCrewPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewPostWhereInput | RunCrewPostWhereInput[]
    OR?: RunCrewPostWhereInput[]
    NOT?: RunCrewPostWhereInput | RunCrewPostWhereInput[]
    runCrewId?: StringFilter<"RunCrewPost"> | string
    athleteId?: StringFilter<"RunCrewPost"> | string
    content?: StringFilter<"RunCrewPost"> | string
    imageUrl?: StringNullableFilter<"RunCrewPost"> | string | null
    likes?: IntFilter<"RunCrewPost"> | number
    createdAt?: DateTimeFilter<"RunCrewPost"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPost"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    comments?: RunCrewPostCommentListRelationFilter
  }, "id">

  export type RunCrewPostOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewPostCountOrderByAggregateInput
    _avg?: RunCrewPostAvgOrderByAggregateInput
    _max?: RunCrewPostMaxOrderByAggregateInput
    _min?: RunCrewPostMinOrderByAggregateInput
    _sum?: RunCrewPostSumOrderByAggregateInput
  }

  export type RunCrewPostScalarWhereWithAggregatesInput = {
    AND?: RunCrewPostScalarWhereWithAggregatesInput | RunCrewPostScalarWhereWithAggregatesInput[]
    OR?: RunCrewPostScalarWhereWithAggregatesInput[]
    NOT?: RunCrewPostScalarWhereWithAggregatesInput | RunCrewPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewPost"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewPost"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewPost"> | string
    content?: StringWithAggregatesFilter<"RunCrewPost"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"RunCrewPost"> | string | null
    likes?: IntWithAggregatesFilter<"RunCrewPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewPost"> | Date | string
  }

  export type RunCrewPostCommentWhereInput = {
    AND?: RunCrewPostCommentWhereInput | RunCrewPostCommentWhereInput[]
    OR?: RunCrewPostCommentWhereInput[]
    NOT?: RunCrewPostCommentWhereInput | RunCrewPostCommentWhereInput[]
    id?: StringFilter<"RunCrewPostComment"> | string
    postId?: StringFilter<"RunCrewPostComment"> | string
    athleteId?: StringFilter<"RunCrewPostComment"> | string
    content?: StringFilter<"RunCrewPostComment"> | string
    createdAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
    post?: XOR<RunCrewPostScalarRelationFilter, RunCrewPostWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewPostCommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: RunCrewPostOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewPostCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewPostCommentWhereInput | RunCrewPostCommentWhereInput[]
    OR?: RunCrewPostCommentWhereInput[]
    NOT?: RunCrewPostCommentWhereInput | RunCrewPostCommentWhereInput[]
    postId?: StringFilter<"RunCrewPostComment"> | string
    athleteId?: StringFilter<"RunCrewPostComment"> | string
    content?: StringFilter<"RunCrewPostComment"> | string
    createdAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
    post?: XOR<RunCrewPostScalarRelationFilter, RunCrewPostWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id">

  export type RunCrewPostCommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewPostCommentCountOrderByAggregateInput
    _max?: RunCrewPostCommentMaxOrderByAggregateInput
    _min?: RunCrewPostCommentMinOrderByAggregateInput
  }

  export type RunCrewPostCommentScalarWhereWithAggregatesInput = {
    AND?: RunCrewPostCommentScalarWhereWithAggregatesInput | RunCrewPostCommentScalarWhereWithAggregatesInput[]
    OR?: RunCrewPostCommentScalarWhereWithAggregatesInput[]
    NOT?: RunCrewPostCommentScalarWhereWithAggregatesInput | RunCrewPostCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewPostComment"> | string
    postId?: StringWithAggregatesFilter<"RunCrewPostComment"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewPostComment"> | string
    content?: StringWithAggregatesFilter<"RunCrewPostComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewPostComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewPostComment"> | Date | string
  }

  export type RunCrewLeaderboardWhereInput = {
    AND?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    OR?: RunCrewLeaderboardWhereInput[]
    NOT?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    id?: StringFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runCrewId_athleteId_period_periodStart?: RunCrewLeaderboardRunCrewIdAthleteIdPeriodPeriodStartCompoundUniqueInput
    AND?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    OR?: RunCrewLeaderboardWhereInput[]
    NOT?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runCrewId_athleteId_period_periodStart">

  export type RunCrewLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewLeaderboardCountOrderByAggregateInput
    _avg?: RunCrewLeaderboardAvgOrderByAggregateInput
    _max?: RunCrewLeaderboardMaxOrderByAggregateInput
    _min?: RunCrewLeaderboardMinOrderByAggregateInput
    _sum?: RunCrewLeaderboardSumOrderByAggregateInput
  }

  export type RunCrewLeaderboardScalarWhereWithAggregatesInput = {
    AND?: RunCrewLeaderboardScalarWhereWithAggregatesInput | RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    OR?: RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: RunCrewLeaderboardScalarWhereWithAggregatesInput | RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    period?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatWithAggregatesFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntWithAggregatesFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableWithAggregatesFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntWithAggregatesFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatWithAggregatesFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: StringFilter<"Race"> | string
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    createdByAthlete?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    trainingPlans?: TrainingPlanListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrderInput | SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    courseProfile?: SortOrderInput | SortOrder
    createdByAthleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByAthlete?: AthleteOrderByWithRelationInput
    trainingPlans?: TrainingPlanOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    createdByAthlete?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    trainingPlans?: TrainingPlanListRelationFilter
  }, "id">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrderInput | SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    courseProfile?: SortOrderInput | SortOrder
    createdByAthleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Race"> | string
    raceName?: StringWithAggregatesFilter<"Race"> | string
    raceType?: StringWithAggregatesFilter<"Race"> | string
    raceDate?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Race"> | string | null
    distanceMiles?: FloatWithAggregatesFilter<"Race"> | number
    registrationUrl?: StringNullableWithAggregatesFilter<"Race"> | string | null
    description?: StringNullableWithAggregatesFilter<"Race"> | string | null
    courseProfile?: JsonNullableWithAggregatesFilter<"Race">
    createdByAthleteId?: StringNullableWithAggregatesFilter<"Race"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
  }

  export type TrainingPlanWhereInput = {
    AND?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    OR?: TrainingPlanWhereInput[]
    NOT?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    id?: StringFilter<"TrainingPlan"> | string
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    plannedDays?: TrainingDayPlannedListRelationFilter
    executions?: TrainingPlanExecutionListRelationFilter
  }

  export type TrainingPlanOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrderInput | SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrderInput | SortOrder
    weeklyMileagePlan?: SortOrderInput | SortOrder
    weeks?: SortOrderInput | SortOrder
    adaptive5kTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
    race?: RaceOrderByWithRelationInput
    plannedDays?: TrainingDayPlannedOrderByRelationAggregateInput
    executions?: TrainingPlanExecutionOrderByRelationAggregateInput
  }

  export type TrainingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    OR?: TrainingPlanWhereInput[]
    NOT?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    plannedDays?: TrainingDayPlannedListRelationFilter
    executions?: TrainingPlanExecutionListRelationFilter
  }, "id">

  export type TrainingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrderInput | SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrderInput | SortOrder
    weeklyMileagePlan?: SortOrderInput | SortOrder
    weeks?: SortOrderInput | SortOrder
    adaptive5kTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingPlanCountOrderByAggregateInput
    _avg?: TrainingPlanAvgOrderByAggregateInput
    _max?: TrainingPlanMaxOrderByAggregateInput
    _min?: TrainingPlanMinOrderByAggregateInput
    _sum?: TrainingPlanSumOrderByAggregateInput
  }

  export type TrainingPlanScalarWhereWithAggregatesInput = {
    AND?: TrainingPlanScalarWhereWithAggregatesInput | TrainingPlanScalarWhereWithAggregatesInput[]
    OR?: TrainingPlanScalarWhereWithAggregatesInput[]
    NOT?: TrainingPlanScalarWhereWithAggregatesInput | TrainingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPlan"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingPlan"> | string
    raceId?: StringWithAggregatesFilter<"TrainingPlan"> | string
    goalTime?: StringWithAggregatesFilter<"TrainingPlan"> | string
    goalPace?: StringNullableWithAggregatesFilter<"TrainingPlan"> | string | null
    baseline5k?: StringWithAggregatesFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableWithAggregatesFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntWithAggregatesFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    weeks?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableWithAggregatesFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
  }

  export type TrainingDayPlannedWhereInput = {
    AND?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    OR?: TrainingDayPlannedWhereInput[]
    NOT?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    id?: StringFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type TrainingDayPlannedOrderByWithRelationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrderInput | SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingPlan?: TrainingPlanOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type TrainingDayPlannedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingPlanId_weekIndex_dayIndex?: TrainingDayPlannedTrainingPlanIdWeekIndexDayIndexCompoundUniqueInput
    AND?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    OR?: TrainingDayPlannedWhereInput[]
    NOT?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "trainingPlanId_weekIndex_dayIndex">

  export type TrainingDayPlannedOrderByWithAggregationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrderInput | SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDayPlannedCountOrderByAggregateInput
    _avg?: TrainingDayPlannedAvgOrderByAggregateInput
    _max?: TrainingDayPlannedMaxOrderByAggregateInput
    _min?: TrainingDayPlannedMinOrderByAggregateInput
    _sum?: TrainingDayPlannedSumOrderByAggregateInput
  }

  export type TrainingDayPlannedScalarWhereWithAggregatesInput = {
    AND?: TrainingDayPlannedScalarWhereWithAggregatesInput | TrainingDayPlannedScalarWhereWithAggregatesInput[]
    OR?: TrainingDayPlannedScalarWhereWithAggregatesInput[]
    NOT?: TrainingDayPlannedScalarWhereWithAggregatesInput | TrainingDayPlannedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    date?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntWithAggregatesFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntWithAggregatesFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableWithAggregatesFilter<"TrainingDayPlanned"> | string | null
    phase?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonWithAggregatesFilter<"TrainingDayPlanned">
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
  }

  export type TrainingPlanExecutionWhereInput = {
    AND?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    OR?: TrainingPlanExecutionWhereInput[]
    NOT?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    id?: StringFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    executedDays?: TrainingDayExecutedListRelationFilter
  }

  export type TrainingPlanExecutionOrderByWithRelationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingPlan?: TrainingPlanOrderByWithRelationInput
    executedDays?: TrainingDayExecutedOrderByRelationAggregateInput
  }

  export type TrainingPlanExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    OR?: TrainingPlanExecutionWhereInput[]
    NOT?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    executedDays?: TrainingDayExecutedListRelationFilter
  }, "id">

  export type TrainingPlanExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingPlanExecutionCountOrderByAggregateInput
    _max?: TrainingPlanExecutionMaxOrderByAggregateInput
    _min?: TrainingPlanExecutionMinOrderByAggregateInput
  }

  export type TrainingPlanExecutionScalarWhereWithAggregatesInput = {
    AND?: TrainingPlanExecutionScalarWhereWithAggregatesInput | TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    OR?: TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    NOT?: TrainingPlanExecutionScalarWhereWithAggregatesInput | TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
    status?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
  }

  export type TrainingDayExecutedWhereInput = {
    AND?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    OR?: TrainingDayExecutedWhereInput[]
    NOT?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    id?: StringFilter<"TrainingDayExecuted"> | string
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    execution?: XOR<TrainingPlanExecutionScalarRelationFilter, TrainingPlanExecutionWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type TrainingDayExecutedOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    execution?: TrainingPlanExecutionOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type TrainingDayExecutedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    activityId?: string
    executionId_date?: TrainingDayExecutedExecutionIdDateCompoundUniqueInput
    AND?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    OR?: TrainingDayExecutedWhereInput[]
    NOT?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    execution?: XOR<TrainingPlanExecutionScalarRelationFilter, TrainingPlanExecutionWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "activityId" | "executionId_date">

  export type TrainingDayExecutedOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDayExecutedCountOrderByAggregateInput
    _avg?: TrainingDayExecutedAvgOrderByAggregateInput
    _max?: TrainingDayExecutedMaxOrderByAggregateInput
    _min?: TrainingDayExecutedMinOrderByAggregateInput
    _sum?: TrainingDayExecutedSumOrderByAggregateInput
  }

  export type TrainingDayExecutedScalarWhereWithAggregatesInput = {
    AND?: TrainingDayExecutedScalarWhereWithAggregatesInput | TrainingDayExecutedScalarWhereWithAggregatesInput[]
    OR?: TrainingDayExecutedScalarWhereWithAggregatesInput[]
    NOT?: TrainingDayExecutedScalarWhereWithAggregatesInput | TrainingDayExecutedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    executionId?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableWithAggregatesFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntWithAggregatesFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntWithAggregatesFilter<"TrainingDayExecuted"> | number
    date?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    analysis?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    feedback?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
  }

  export type FounderWhereInput = {
    AND?: FounderWhereInput | FounderWhereInput[]
    OR?: FounderWhereInput[]
    NOT?: FounderWhereInput | FounderWhereInput[]
    id?: StringFilter<"Founder"> | string
    athleteId?: StringFilter<"Founder"> | string
    createdAt?: DateTimeFilter<"Founder"> | Date | string
    updatedAt?: DateTimeFilter<"Founder"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    tasks?: FounderTaskListRelationFilter
    crmContacts?: CrmContactListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
  }

  export type FounderOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
    tasks?: FounderTaskOrderByRelationAggregateInput
    crmContacts?: CrmContactOrderByRelationAggregateInput
    roadmapItems?: RoadmapItemOrderByRelationAggregateInput
  }

  export type FounderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    athleteId?: string
    AND?: FounderWhereInput | FounderWhereInput[]
    OR?: FounderWhereInput[]
    NOT?: FounderWhereInput | FounderWhereInput[]
    createdAt?: DateTimeFilter<"Founder"> | Date | string
    updatedAt?: DateTimeFilter<"Founder"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    tasks?: FounderTaskListRelationFilter
    crmContacts?: CrmContactListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
  }, "id" | "athleteId">

  export type FounderOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FounderCountOrderByAggregateInput
    _max?: FounderMaxOrderByAggregateInput
    _min?: FounderMinOrderByAggregateInput
  }

  export type FounderScalarWhereWithAggregatesInput = {
    AND?: FounderScalarWhereWithAggregatesInput | FounderScalarWhereWithAggregatesInput[]
    OR?: FounderScalarWhereWithAggregatesInput[]
    NOT?: FounderScalarWhereWithAggregatesInput | FounderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Founder"> | string
    athleteId?: StringWithAggregatesFilter<"Founder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Founder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Founder"> | Date | string
  }

  export type FounderTaskWhereInput = {
    AND?: FounderTaskWhereInput | FounderTaskWhereInput[]
    OR?: FounderTaskWhereInput[]
    NOT?: FounderTaskWhereInput | FounderTaskWhereInput[]
    id?: StringFilter<"FounderTask"> | string
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type FounderTaskOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type FounderTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FounderTaskWhereInput | FounderTaskWhereInput[]
    OR?: FounderTaskWhereInput[]
    NOT?: FounderTaskWhereInput | FounderTaskWhereInput[]
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type FounderTaskOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FounderTaskCountOrderByAggregateInput
    _max?: FounderTaskMaxOrderByAggregateInput
    _min?: FounderTaskMinOrderByAggregateInput
  }

  export type FounderTaskScalarWhereWithAggregatesInput = {
    AND?: FounderTaskScalarWhereWithAggregatesInput | FounderTaskScalarWhereWithAggregatesInput[]
    OR?: FounderTaskScalarWhereWithAggregatesInput[]
    NOT?: FounderTaskScalarWhereWithAggregatesInput | FounderTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FounderTask"> | string
    founderId?: StringWithAggregatesFilter<"FounderTask"> | string
    title?: StringWithAggregatesFilter<"FounderTask"> | string
    description?: StringNullableWithAggregatesFilter<"FounderTask"> | string | null
    status?: StringWithAggregatesFilter<"FounderTask"> | string
    priority?: StringWithAggregatesFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FounderTask"> | Date | string
  }

  export type CrmContactWhereInput = {
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    id?: StringFilter<"CrmContact"> | string
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type CrmContactOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type CrmContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type CrmContactOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrmContactCountOrderByAggregateInput
    _max?: CrmContactMaxOrderByAggregateInput
    _min?: CrmContactMinOrderByAggregateInput
  }

  export type CrmContactScalarWhereWithAggregatesInput = {
    AND?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    OR?: CrmContactScalarWhereWithAggregatesInput[]
    NOT?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmContact"> | string
    founderId?: StringWithAggregatesFilter<"CrmContact"> | string
    name?: StringWithAggregatesFilter<"CrmContact"> | string
    role?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    company?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    pipeline?: StringWithAggregatesFilter<"CrmContact"> | string
    status?: StringWithAggregatesFilter<"CrmContact"> | string
    nextStep?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
  }

  export type RoadmapItemWhereInput = {
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type RoadmapItemOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type RoadmapItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type RoadmapItemOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapItemCountOrderByAggregateInput
    _max?: RoadmapItemMaxOrderByAggregateInput
    _min?: RoadmapItemMinOrderByAggregateInput
  }

  export type RoadmapItemScalarWhereWithAggregatesInput = {
    AND?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    OR?: RoadmapItemScalarWhereWithAggregatesInput[]
    NOT?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapItem"> | string
    founderId?: StringWithAggregatesFilter<"RoadmapItem"> | string
    roadmapType?: StringWithAggregatesFilter<"RoadmapItem"> | string
    quarter?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    title?: StringWithAggregatesFilter<"RoadmapItem"> | string
    description?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    status?: StringWithAggregatesFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
  }

  export type AthleteCreateInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateManyInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
  }

  export type AthleteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AthleteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AthleteActivityCreateInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutActivitiesInput
  }

  export type AthleteActivityUncheckedCreateInput = {
    id?: string
    athleteId: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type AthleteActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityCreateManyInput = {
    id?: string
    athleteId: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewCreateInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    runcrewAdminId: string
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneRequiredWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    runcrewAdminId: string
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMembershipsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMembershipsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCreateInput = {
    id?: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutPostsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewPostsInput
    comments?: RunCrewPostCommentCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutPostsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewPostsNestedInput
    comments?: RunCrewPostCommentUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: RunCrewPostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: RunCrewPostCreateNestedOneWithoutCommentsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewPostCommentsInput
  }

  export type RunCrewPostCommentUncheckedCreateInput = {
    id?: string
    postId: string
    athleteId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: RunCrewPostUpdateOneRequiredWithoutCommentsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewPostCommentsNestedInput
  }

  export type RunCrewPostCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentCreateManyInput = {
    id?: string
    postId: string
    athleteId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutLeaderboardEntriesInput
    athlete: AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput
  }

  export type RunCrewLeaderboardUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceCreateInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAthlete?: AthleteCreateNestedOneWithoutCreatedRacesInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAthlete?: AthleteUpdateOneWithoutCreatedRacesNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanCreateInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanCreateManyInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutPlannedDaysInput
    athlete: AthleteCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateInput = {
    id?: string
    trainingPlanId: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateManyInput = {
    id?: string
    trainingPlanId: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionCreateInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutExecutionsInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUncheckedCreateInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionCreateManyInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput
    athlete: AthleteCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateInput = {
    id?: string
    executionId: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateManyInput = {
    id?: string
    executionId: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateManyInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutTasksInput
  }

  export type FounderTaskUncheckedCreateInput = {
    id?: string
    founderId: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutTasksNestedInput
  }

  export type FounderTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateManyInput = {
    id?: string
    founderId: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactCreateInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutCrmContactsInput
  }

  export type CrmContactUncheckedCreateInput = {
    id?: string
    founderId: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutCrmContactsNestedInput
  }

  export type CrmContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactCreateManyInput = {
    id?: string
    founderId: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutRoadmapItemsInput
  }

  export type RoadmapItemUncheckedCreateInput = {
    id?: string
    founderId: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutRoadmapItemsNestedInput
  }

  export type RoadmapItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateManyInput = {
    id?: string
    founderId: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AthleteActivityListRelationFilter = {
    every?: AthleteActivityWhereInput
    some?: AthleteActivityWhereInput
    none?: AthleteActivityWhereInput
  }

  export type RunCrewListRelationFilter = {
    every?: RunCrewWhereInput
    some?: RunCrewWhereInput
    none?: RunCrewWhereInput
  }

  export type RunCrewMembershipListRelationFilter = {
    every?: RunCrewMembershipWhereInput
    some?: RunCrewMembershipWhereInput
    none?: RunCrewMembershipWhereInput
  }

  export type RunCrewPostListRelationFilter = {
    every?: RunCrewPostWhereInput
    some?: RunCrewPostWhereInput
    none?: RunCrewPostWhereInput
  }

  export type RunCrewPostCommentListRelationFilter = {
    every?: RunCrewPostCommentWhereInput
    some?: RunCrewPostCommentWhereInput
    none?: RunCrewPostCommentWhereInput
  }

  export type RunCrewLeaderboardListRelationFilter = {
    every?: RunCrewLeaderboardWhereInput
    some?: RunCrewLeaderboardWhereInput
    none?: RunCrewLeaderboardWhereInput
  }

  export type RaceListRelationFilter = {
    every?: RaceWhereInput
    some?: RaceWhereInput
    none?: RaceWhereInput
  }

  export type TrainingPlanListRelationFilter = {
    every?: TrainingPlanWhereInput
    some?: TrainingPlanWhereInput
    none?: TrainingPlanWhereInput
  }

  export type TrainingDayPlannedListRelationFilter = {
    every?: TrainingDayPlannedWhereInput
    some?: TrainingDayPlannedWhereInput
    none?: TrainingDayPlannedWhereInput
  }

  export type TrainingDayExecutedListRelationFilter = {
    every?: TrainingDayExecutedWhereInput
    some?: TrainingDayExecutedWhereInput
    none?: TrainingDayExecutedWhereInput
  }

  export type FounderNullableScalarRelationFilter = {
    is?: FounderWhereInput | null
    isNot?: FounderWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AthleteActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewPostCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDayPlannedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDayExecutedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AthleteCountOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_permissions?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    garmin_user_profile?: SortOrder
    garmin_user_sleep?: SortOrder
    garmin_user_preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteAvgOrderByAggregateInput = {
    weeklyMileage?: SortOrder
    garmin_expires_in?: SortOrder
    strava_id?: SortOrder
    strava_expires_at?: SortOrder
  }

  export type AthleteMaxOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteMinOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteSumOrderByAggregateInput = {
    weeklyMileage?: SortOrder
    garmin_expires_in?: SortOrder
    strava_id?: SortOrder
    strava_expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AthleteScalarRelationFilter = {
    is?: AthleteWhereInput
    isNot?: AthleteWhereInput
  }

  export type AthleteActivityCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    summaryData?: SortOrder
    detailData?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type AthleteActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivitySumOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RunCrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewScalarRelationFilter = {
    is?: RunCrewWhereInput
    isNot?: RunCrewWhereInput
  }

  export type RunCrewMembershipRunCrewIdAthleteIdCompoundUniqueInput = {
    runCrewId: string
    athleteId: string
  }

  export type RunCrewMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RunCrewPostCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewPostAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type RunCrewPostMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewPostMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewPostSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RunCrewPostScalarRelationFilter = {
    is?: RunCrewPostWhereInput
    isNot?: RunCrewPostWhereInput
  }

  export type RunCrewPostCommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewPostCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewPostCommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RunCrewLeaderboardRunCrewIdAthleteIdPeriodPeriodStartCompoundUniqueInput = {
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
  }

  export type RunCrewLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardAvgOrderByAggregateInput = {
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
  }

  export type RunCrewLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardSumOrderByAggregateInput = {
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AthleteNullableScalarRelationFilter = {
    is?: AthleteWhereInput | null
    isNot?: AthleteWhereInput | null
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    courseProfile?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    distanceMiles?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    distanceMiles?: SortOrder
  }

  export type RaceScalarRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type TrainingPlanExecutionListRelationFilter = {
    every?: TrainingPlanExecutionWhereInput
    some?: TrainingPlanExecutionWhereInput
    none?: TrainingPlanExecutionWhereInput
  }

  export type TrainingPlanExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrder
    weeklyMileagePlan?: SortOrder
    weeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanAvgOrderByAggregateInput = {
    baselineWeeklyMileage?: SortOrder
    totalWeeks?: SortOrder
  }

  export type TrainingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanSumOrderByAggregateInput = {
    baselineWeeklyMileage?: SortOrder
    totalWeeks?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TrainingPlanScalarRelationFilter = {
    is?: TrainingPlanWhereInput
    isNot?: TrainingPlanWhereInput
  }

  export type TrainingDayPlannedTrainingPlanIdWeekIndexDayIndexCompoundUniqueInput = {
    trainingPlanId: string
    weekIndex: number
    dayIndex: number
  }

  export type TrainingDayPlannedCountOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedAvgOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type TrainingDayPlannedMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedMinOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedSumOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TrainingPlanExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionScalarRelationFilter = {
    is?: TrainingPlanExecutionWhereInput
    isNot?: TrainingPlanExecutionWhereInput
  }

  export type TrainingDayExecutedExecutionIdDateCompoundUniqueInput = {
    executionId: string
    date: Date | string
  }

  export type TrainingDayExecutedCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrder
    analysis?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedAvgOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type TrainingDayExecutedMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedSumOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type FounderTaskListRelationFilter = {
    every?: FounderTaskWhereInput
    some?: FounderTaskWhereInput
    none?: FounderTaskWhereInput
  }

  export type CrmContactListRelationFilter = {
    every?: CrmContactWhereInput
    some?: CrmContactWhereInput
    none?: CrmContactWhereInput
  }

  export type RoadmapItemListRelationFilter = {
    every?: RoadmapItemWhereInput
    some?: RoadmapItemWhereInput
    none?: RoadmapItemWhereInput
  }

  export type FounderTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrmContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FounderCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderScalarRelationFilter = {
    is?: FounderWhereInput
    isNot?: FounderWhereInput
  }

  export type FounderTaskCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderTaskMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityCreateNestedManyWithoutAthleteInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
  }

  export type RunCrewCreateNestedManyWithoutAdminInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
  }

  export type RunCrewMembershipCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewPostCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput> | RunCrewPostCreateWithoutAthleteInput[] | RunCrewPostUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutAthleteInput | RunCrewPostCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewPostCreateManyAthleteInputEnvelope
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
  }

  export type RunCrewPostCommentCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput> | RunCrewPostCommentCreateWithoutAthleteInput[] | RunCrewPostCommentUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutAthleteInput | RunCrewPostCommentCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewPostCommentCreateManyAthleteInputEnvelope
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
  }

  export type RunCrewLeaderboardCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RaceCreateNestedManyWithoutCreatedByAthleteInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type TrainingPlanCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingDayPlannedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingDayExecutedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type FounderCreateNestedOneWithoutAthleteInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    connect?: FounderWhereUniqueInput
  }

  export type AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
  }

  export type RunCrewUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
  }

  export type RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput> | RunCrewPostCreateWithoutAthleteInput[] | RunCrewPostUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutAthleteInput | RunCrewPostCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewPostCreateManyAthleteInputEnvelope
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
  }

  export type RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput> | RunCrewPostCommentCreateWithoutAthleteInput[] | RunCrewPostCommentUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutAthleteInput | RunCrewPostCommentCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewPostCommentCreateManyAthleteInputEnvelope
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
  }

  export type RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type FounderUncheckedCreateNestedOneWithoutAthleteInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    connect?: FounderWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AthleteActivityUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    upsert?: AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput | AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    set?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    disconnect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    delete?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    update?: AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput | AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: AthleteActivityUpdateManyWithWhereWithoutAthleteInput | AthleteActivityUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
  }

  export type RunCrewUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    upsert?: RunCrewUpsertWithWhereUniqueWithoutAdminInput | RunCrewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    set?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    disconnect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    delete?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    update?: RunCrewUpdateWithWhereUniqueWithoutAdminInput | RunCrewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RunCrewUpdateManyWithWhereWithoutAdminInput | RunCrewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
  }

  export type RunCrewMembershipUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput | RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewPostUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput> | RunCrewPostCreateWithoutAthleteInput[] | RunCrewPostUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutAthleteInput | RunCrewPostCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewPostUpsertWithWhereUniqueWithoutAthleteInput | RunCrewPostUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewPostCreateManyAthleteInputEnvelope
    set?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    disconnect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    delete?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    update?: RunCrewPostUpdateWithWhereUniqueWithoutAthleteInput | RunCrewPostUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewPostUpdateManyWithWhereWithoutAthleteInput | RunCrewPostUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
  }

  export type RunCrewPostCommentUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput> | RunCrewPostCommentCreateWithoutAthleteInput[] | RunCrewPostCommentUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutAthleteInput | RunCrewPostCommentCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewPostCommentUpsertWithWhereUniqueWithoutAthleteInput | RunCrewPostCommentUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewPostCommentCreateManyAthleteInputEnvelope
    set?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    disconnect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    delete?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    update?: RunCrewPostCommentUpdateWithWhereUniqueWithoutAthleteInput | RunCrewPostCommentUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewPostCommentUpdateManyWithWhereWithoutAthleteInput | RunCrewPostCommentUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
  }

  export type RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput | RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RaceUpdateManyWithoutCreatedByAthleteNestedInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutCreatedByAthleteInput | RaceUpdateManyWithWhereWithoutCreatedByAthleteInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type TrainingPlanUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput | TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput | TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutAthleteInput | TrainingPlanUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingDayPlannedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput | TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingDayExecutedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput | TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type FounderUpdateOneWithoutAthleteNestedInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    upsert?: FounderUpsertWithoutAthleteInput
    disconnect?: FounderWhereInput | boolean
    delete?: FounderWhereInput | boolean
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutAthleteInput, FounderUpdateWithoutAthleteInput>, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    upsert?: AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput | AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    set?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    disconnect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    delete?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    update?: AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput | AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: AthleteActivityUpdateManyWithWhereWithoutAthleteInput | AthleteActivityUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
  }

  export type RunCrewUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    upsert?: RunCrewUpsertWithWhereUniqueWithoutAdminInput | RunCrewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    set?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    disconnect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    delete?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    update?: RunCrewUpdateWithWhereUniqueWithoutAdminInput | RunCrewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RunCrewUpdateManyWithWhereWithoutAdminInput | RunCrewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput | RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput> | RunCrewPostCreateWithoutAthleteInput[] | RunCrewPostUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutAthleteInput | RunCrewPostCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewPostUpsertWithWhereUniqueWithoutAthleteInput | RunCrewPostUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewPostCreateManyAthleteInputEnvelope
    set?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    disconnect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    delete?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    update?: RunCrewPostUpdateWithWhereUniqueWithoutAthleteInput | RunCrewPostUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewPostUpdateManyWithWhereWithoutAthleteInput | RunCrewPostUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
  }

  export type RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput> | RunCrewPostCommentCreateWithoutAthleteInput[] | RunCrewPostCommentUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutAthleteInput | RunCrewPostCommentCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewPostCommentUpsertWithWhereUniqueWithoutAthleteInput | RunCrewPostCommentUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewPostCommentCreateManyAthleteInputEnvelope
    set?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    disconnect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    delete?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    update?: RunCrewPostCommentUpdateWithWhereUniqueWithoutAthleteInput | RunCrewPostCommentUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewPostCommentUpdateManyWithWhereWithoutAthleteInput | RunCrewPostCommentUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput | RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutCreatedByAthleteInput | RaceUpdateManyWithWhereWithoutCreatedByAthleteInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput | TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput | TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutAthleteInput | TrainingPlanUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput | TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput | TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type FounderUncheckedUpdateOneWithoutAthleteNestedInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    upsert?: FounderUpsertWithoutAthleteInput
    disconnect?: FounderWhereInput | boolean
    delete?: FounderWhereInput | boolean
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutAthleteInput, FounderUpdateWithoutAthleteInput>, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutActivitiesInput
    connect?: AthleteWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AthleteUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutActivitiesInput
    upsert?: AthleteUpsertWithoutActivitiesInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutActivitiesInput, AthleteUpdateWithoutActivitiesInput>, AthleteUncheckedUpdateWithoutActivitiesInput>
  }

  export type AthleteCreateNestedOneWithoutAdminRunCrewsInput = {
    create?: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutAdminRunCrewsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewMembershipCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewPostCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput> | RunCrewPostCreateWithoutRunCrewInput[] | RunCrewPostUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutRunCrewInput | RunCrewPostCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewPostCreateManyRunCrewInputEnvelope
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
  }

  export type RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewPostUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput> | RunCrewPostCreateWithoutRunCrewInput[] | RunCrewPostUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutRunCrewInput | RunCrewPostCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewPostCreateManyRunCrewInputEnvelope
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
  }

  export type RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type AthleteUpdateOneRequiredWithoutAdminRunCrewsNestedInput = {
    create?: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutAdminRunCrewsInput
    upsert?: AthleteUpsertWithoutAdminRunCrewsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutAdminRunCrewsInput, AthleteUpdateWithoutAdminRunCrewsInput>, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
  }

  export type RunCrewMembershipUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput | RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewPostUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput> | RunCrewPostCreateWithoutRunCrewInput[] | RunCrewPostUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutRunCrewInput | RunCrewPostCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewPostUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewPostUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewPostCreateManyRunCrewInputEnvelope
    set?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    disconnect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    delete?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    update?: RunCrewPostUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewPostUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewPostUpdateManyWithWhereWithoutRunCrewInput | RunCrewPostUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
  }

  export type RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput | RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput | RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewPostUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput> | RunCrewPostCreateWithoutRunCrewInput[] | RunCrewPostUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutRunCrewInput | RunCrewPostCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewPostUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewPostUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewPostCreateManyRunCrewInputEnvelope
    set?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    disconnect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    delete?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    connect?: RunCrewPostWhereUniqueInput | RunCrewPostWhereUniqueInput[]
    update?: RunCrewPostUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewPostUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewPostUpdateManyWithWhereWithoutRunCrewInput | RunCrewPostUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput | RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMembershipsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewMembershipsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMembershipsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMembershipsInput
    upsert?: RunCrewUpsertWithoutMembershipsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutMembershipsInput, RunCrewUpdateWithoutMembershipsInput>, RunCrewUncheckedUpdateWithoutMembershipsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMembershipsInput
    upsert?: AthleteUpsertWithoutRunCrewMembershipsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewMembershipsInput, AthleteUpdateWithoutRunCrewMembershipsInput>, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
  }

  export type RunCrewCreateNestedOneWithoutPostsInput = {
    create?: XOR<RunCrewCreateWithoutPostsInput, RunCrewUncheckedCreateWithoutPostsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutPostsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewPostsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewPostsInput, AthleteUncheckedCreateWithoutRunCrewPostsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewPostsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewPostCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput> | RunCrewPostCommentCreateWithoutPostInput[] | RunCrewPostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutPostInput | RunCrewPostCommentCreateOrConnectWithoutPostInput[]
    createMany?: RunCrewPostCommentCreateManyPostInputEnvelope
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
  }

  export type RunCrewPostCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput> | RunCrewPostCommentCreateWithoutPostInput[] | RunCrewPostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutPostInput | RunCrewPostCommentCreateOrConnectWithoutPostInput[]
    createMany?: RunCrewPostCommentCreateManyPostInputEnvelope
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RunCrewUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<RunCrewCreateWithoutPostsInput, RunCrewUncheckedCreateWithoutPostsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutPostsInput
    upsert?: RunCrewUpsertWithoutPostsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutPostsInput, RunCrewUpdateWithoutPostsInput>, RunCrewUncheckedUpdateWithoutPostsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewPostsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewPostsInput, AthleteUncheckedCreateWithoutRunCrewPostsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewPostsInput
    upsert?: AthleteUpsertWithoutRunCrewPostsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewPostsInput, AthleteUpdateWithoutRunCrewPostsInput>, AthleteUncheckedUpdateWithoutRunCrewPostsInput>
  }

  export type RunCrewPostCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput> | RunCrewPostCommentCreateWithoutPostInput[] | RunCrewPostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutPostInput | RunCrewPostCommentCreateOrConnectWithoutPostInput[]
    upsert?: RunCrewPostCommentUpsertWithWhereUniqueWithoutPostInput | RunCrewPostCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: RunCrewPostCommentCreateManyPostInputEnvelope
    set?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    disconnect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    delete?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    update?: RunCrewPostCommentUpdateWithWhereUniqueWithoutPostInput | RunCrewPostCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: RunCrewPostCommentUpdateManyWithWhereWithoutPostInput | RunCrewPostCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
  }

  export type RunCrewPostCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput> | RunCrewPostCommentCreateWithoutPostInput[] | RunCrewPostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: RunCrewPostCommentCreateOrConnectWithoutPostInput | RunCrewPostCommentCreateOrConnectWithoutPostInput[]
    upsert?: RunCrewPostCommentUpsertWithWhereUniqueWithoutPostInput | RunCrewPostCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: RunCrewPostCommentCreateManyPostInputEnvelope
    set?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    disconnect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    delete?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    connect?: RunCrewPostCommentWhereUniqueInput | RunCrewPostCommentWhereUniqueInput[]
    update?: RunCrewPostCommentUpdateWithWhereUniqueWithoutPostInput | RunCrewPostCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: RunCrewPostCommentUpdateManyWithWhereWithoutPostInput | RunCrewPostCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
  }

  export type RunCrewPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<RunCrewPostCreateWithoutCommentsInput, RunCrewPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutCommentsInput
    connect?: RunCrewPostWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewPostCommentsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewPostCommentsInput, AthleteUncheckedCreateWithoutRunCrewPostCommentsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewPostCommentsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<RunCrewPostCreateWithoutCommentsInput, RunCrewPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: RunCrewPostCreateOrConnectWithoutCommentsInput
    upsert?: RunCrewPostUpsertWithoutCommentsInput
    connect?: RunCrewPostWhereUniqueInput
    update?: XOR<XOR<RunCrewPostUpdateToOneWithWhereWithoutCommentsInput, RunCrewPostUpdateWithoutCommentsInput>, RunCrewPostUncheckedUpdateWithoutCommentsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewPostCommentsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewPostCommentsInput, AthleteUncheckedCreateWithoutRunCrewPostCommentsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewPostCommentsInput
    upsert?: AthleteUpsertWithoutRunCrewPostCommentsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewPostCommentsInput, AthleteUpdateWithoutRunCrewPostCommentsInput>, AthleteUncheckedUpdateWithoutRunCrewPostCommentsInput>
  }

  export type RunCrewCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput
    connect?: AthleteWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: RunCrewUpsertWithoutLeaderboardEntriesInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutLeaderboardEntriesInput, RunCrewUpdateWithoutLeaderboardEntriesInput>, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput
    upsert?: AthleteUpsertWithoutRunCrewLeaderboardsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewLeaderboardsInput, AthleteUpdateWithoutRunCrewLeaderboardsInput>, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
  }

  export type AthleteCreateNestedOneWithoutCreatedRacesInput = {
    create?: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutCreatedRacesInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanCreateNestedManyWithoutRaceInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingPlanUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type AthleteUpdateOneWithoutCreatedRacesNestedInput = {
    create?: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutCreatedRacesInput
    upsert?: AthleteUpsertWithoutCreatedRacesInput
    disconnect?: AthleteWhereInput | boolean
    delete?: AthleteWhereInput | boolean
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutCreatedRacesInput, AthleteUpdateWithoutCreatedRacesInput>, AthleteUncheckedUpdateWithoutCreatedRacesInput>
  }

  export type TrainingPlanUpdateManyWithoutRaceNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutRaceInput | TrainingPlanUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutRaceInput | TrainingPlanUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutRaceInput | TrainingPlanUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutRaceInput | TrainingPlanUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutRaceInput | TrainingPlanUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutRaceInput | TrainingPlanUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type AthleteCreateNestedOneWithoutTrainingPlansInput = {
    create?: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutTrainingPlansInput
    connect?: AthleteWhereUniqueInput
  }

  export type RaceCreateNestedOneWithoutTrainingPlansInput = {
    create?: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTrainingPlansInput
    connect?: RaceWhereUniqueInput
  }

  export type TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
  }

  export type TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
  }

  export type AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput = {
    create?: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutTrainingPlansInput
    upsert?: AthleteUpsertWithoutTrainingPlansInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutTrainingPlansInput, AthleteUpdateWithoutTrainingPlansInput>, AthleteUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type RaceUpdateOneRequiredWithoutTrainingPlansNestedInput = {
    create?: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTrainingPlansInput
    upsert?: RaceUpsertWithoutTrainingPlansInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutTrainingPlansInput, RaceUpdateWithoutTrainingPlansInput>, RaceUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput | TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    set?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    disconnect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    delete?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    update?: TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput | TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput | TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    set?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    disconnect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    delete?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    update?: TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput | TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
  }

  export type TrainingPlanCreateNestedOneWithoutPlannedDaysInput = {
    create?: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutPlannedDaysInput
    connect?: TrainingPlanWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutPlannedDaysInput = {
    create?: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutPlannedDaysInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutPlannedDaysInput
    upsert?: TrainingPlanUpsertWithoutPlannedDaysInput
    connect?: TrainingPlanWhereUniqueInput
    update?: XOR<XOR<TrainingPlanUpdateToOneWithWhereWithoutPlannedDaysInput, TrainingPlanUpdateWithoutPlannedDaysInput>, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput = {
    create?: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutPlannedDaysInput
    upsert?: AthleteUpsertWithoutPlannedDaysInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutPlannedDaysInput, AthleteUpdateWithoutPlannedDaysInput>, AthleteUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type TrainingPlanCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutExecutionsInput
    connect?: TrainingPlanWhereUniqueInput
  }

  export type TrainingDayExecutedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutExecutionsInput
    upsert?: TrainingPlanUpsertWithoutExecutionsInput
    connect?: TrainingPlanWhereUniqueInput
    update?: XOR<XOR<TrainingPlanUpdateToOneWithWhereWithoutExecutionsInput, TrainingPlanUpdateWithoutExecutionsInput>, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TrainingDayExecutedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput | TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput | TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput
    connect?: TrainingPlanExecutionWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutExecutedDaysInput = {
    create?: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutExecutedDaysInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput
    upsert?: TrainingPlanExecutionUpsertWithoutExecutedDaysInput
    connect?: TrainingPlanExecutionWhereUniqueInput
    update?: XOR<XOR<TrainingPlanExecutionUpdateToOneWithWhereWithoutExecutedDaysInput, TrainingPlanExecutionUpdateWithoutExecutedDaysInput>, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput = {
    create?: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutExecutedDaysInput
    upsert?: AthleteUpsertWithoutExecutedDaysInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutExecutedDaysInput, AthleteUpdateWithoutExecutedDaysInput>, AthleteUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteCreateNestedOneWithoutFounderInput = {
    create?: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutFounderInput
    connect?: AthleteWhereUniqueInput
  }

  export type FounderTaskCreateNestedManyWithoutFounderInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
  }

  export type CrmContactCreateNestedManyWithoutFounderInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
  }

  export type RoadmapItemCreateNestedManyWithoutFounderInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type FounderTaskUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
  }

  export type CrmContactUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
  }

  export type RoadmapItemUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type AthleteUpdateOneRequiredWithoutFounderNestedInput = {
    create?: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutFounderInput
    upsert?: AthleteUpsertWithoutFounderInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutFounderInput, AthleteUpdateWithoutFounderInput>, AthleteUncheckedUpdateWithoutFounderInput>
  }

  export type FounderTaskUpdateManyWithoutFounderNestedInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    upsert?: FounderTaskUpsertWithWhereUniqueWithoutFounderInput | FounderTaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    set?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    disconnect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    delete?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    update?: FounderTaskUpdateWithWhereUniqueWithoutFounderInput | FounderTaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: FounderTaskUpdateManyWithWhereWithoutFounderInput | FounderTaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
  }

  export type CrmContactUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    upsert?: CrmContactUpsertWithWhereUniqueWithoutFounderInput | CrmContactUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    set?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    disconnect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    delete?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    update?: CrmContactUpdateWithWhereUniqueWithoutFounderInput | CrmContactUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CrmContactUpdateManyWithWhereWithoutFounderInput | CrmContactUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
  }

  export type RoadmapItemUpdateManyWithoutFounderNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutFounderInput | RoadmapItemUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutFounderInput | RoadmapItemUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutFounderInput | RoadmapItemUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type FounderTaskUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    upsert?: FounderTaskUpsertWithWhereUniqueWithoutFounderInput | FounderTaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    set?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    disconnect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    delete?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    update?: FounderTaskUpdateWithWhereUniqueWithoutFounderInput | FounderTaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: FounderTaskUpdateManyWithWhereWithoutFounderInput | FounderTaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
  }

  export type CrmContactUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    upsert?: CrmContactUpsertWithWhereUniqueWithoutFounderInput | CrmContactUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    set?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    disconnect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    delete?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    update?: CrmContactUpdateWithWhereUniqueWithoutFounderInput | CrmContactUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CrmContactUpdateManyWithWhereWithoutFounderInput | CrmContactUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
  }

  export type RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutFounderInput | RoadmapItemUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutFounderInput | RoadmapItemUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutFounderInput | RoadmapItemUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type FounderCreateNestedOneWithoutTasksInput = {
    create?: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutTasksInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutTasksInput
    upsert?: FounderUpsertWithoutTasksInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutTasksInput, FounderUpdateWithoutTasksInput>, FounderUncheckedUpdateWithoutTasksInput>
  }

  export type FounderCreateNestedOneWithoutCrmContactsInput = {
    create?: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCrmContactsInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutCrmContactsNestedInput = {
    create?: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCrmContactsInput
    upsert?: FounderUpsertWithoutCrmContactsInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutCrmContactsInput, FounderUpdateWithoutCrmContactsInput>, FounderUncheckedUpdateWithoutCrmContactsInput>
  }

  export type FounderCreateNestedOneWithoutRoadmapItemsInput = {
    create?: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutRoadmapItemsInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutRoadmapItemsNestedInput = {
    create?: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutRoadmapItemsInput
    upsert?: FounderUpsertWithoutRoadmapItemsInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutRoadmapItemsInput, FounderUpdateWithoutRoadmapItemsInput>, FounderUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AthleteActivityCreateWithoutAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUncheckedCreateWithoutAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityCreateOrConnectWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    create: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityCreateManyAthleteInputEnvelope = {
    data: AthleteActivityCreateManyAthleteInput | AthleteActivityCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewCreateWithoutAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput>
  }

  export type RunCrewCreateManyAdminInputEnvelope = {
    data: RunCrewCreateManyAdminInput | RunCrewCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewMembershipCreateWithoutAthleteInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateOrConnectWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    create: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMembershipCreateManyAthleteInputEnvelope = {
    data: RunCrewMembershipCreateManyAthleteInput | RunCrewMembershipCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewPostCreateWithoutAthleteInput = {
    id?: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutPostsInput
    comments?: RunCrewPostCommentCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostCreateOrConnectWithoutAthleteInput = {
    where: RunCrewPostWhereUniqueInput
    create: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewPostCreateManyAthleteInputEnvelope = {
    data: RunCrewPostCreateManyAthleteInput | RunCrewPostCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewPostCommentCreateWithoutAthleteInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: RunCrewPostCreateNestedOneWithoutCommentsInput
  }

  export type RunCrewPostCommentUncheckedCreateWithoutAthleteInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentCreateOrConnectWithoutAthleteInput = {
    where: RunCrewPostCommentWhereUniqueInput
    create: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewPostCommentCreateManyAthleteInputEnvelope = {
    data: RunCrewPostCommentCreateManyAthleteInput | RunCrewPostCommentCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewLeaderboardCreateWithoutAthleteInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type RunCrewLeaderboardUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateOrConnectWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    create: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardCreateManyAthleteInputEnvelope = {
    data: RunCrewLeaderboardCreateManyAthleteInput | RunCrewLeaderboardCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RaceCreateWithoutCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput>
  }

  export type RaceCreateManyCreatedByAthleteInputEnvelope = {
    data: RaceCreateManyCreatedByAthleteInput | RaceCreateManyCreatedByAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanCreateWithoutAthleteInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutAthleteInput = {
    id?: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingPlanCreateManyAthleteInputEnvelope = {
    data: TrainingPlanCreateManyAthleteInput | TrainingPlanCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDayPlannedCreateWithoutAthleteInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateWithoutAthleteInput = {
    id?: string
    trainingPlanId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateOrConnectWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    create: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayPlannedCreateManyAthleteInputEnvelope = {
    data: TrainingDayPlannedCreateManyAthleteInput | TrainingDayPlannedCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDayExecutedCreateWithoutAthleteInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateWithoutAthleteInput = {
    id?: string
    executionId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateOrConnectWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    create: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayExecutedCreateManyAthleteInputEnvelope = {
    data: TrainingDayExecutedCreateManyAthleteInput | TrainingDayExecutedCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type FounderCreateWithoutAthleteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutAthleteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutAthleteInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    update: XOR<AthleteActivityUpdateWithoutAthleteInput, AthleteActivityUncheckedUpdateWithoutAthleteInput>
    create: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    data: XOR<AthleteActivityUpdateWithoutAthleteInput, AthleteActivityUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteActivityUpdateManyWithWhereWithoutAthleteInput = {
    where: AthleteActivityScalarWhereInput
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyWithoutAthleteInput>
  }

  export type AthleteActivityScalarWhereInput = {
    AND?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
    OR?: AthleteActivityScalarWhereInput[]
    NOT?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
    id?: StringFilter<"AthleteActivity"> | string
    athleteId?: StringFilter<"AthleteActivity"> | string
    sourceActivityId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
  }

  export type RunCrewUpsertWithWhereUniqueWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    update: XOR<RunCrewUpdateWithoutAdminInput, RunCrewUncheckedUpdateWithoutAdminInput>
    create: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput>
  }

  export type RunCrewUpdateWithWhereUniqueWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    data: XOR<RunCrewUpdateWithoutAdminInput, RunCrewUncheckedUpdateWithoutAdminInput>
  }

  export type RunCrewUpdateManyWithWhereWithoutAdminInput = {
    where: RunCrewScalarWhereInput
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyWithoutAdminInput>
  }

  export type RunCrewScalarWhereInput = {
    AND?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
    OR?: RunCrewScalarWhereInput[]
    NOT?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
    id?: StringFilter<"RunCrew"> | string
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    joinCode?: StringFilter<"RunCrew"> | string
    logo?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringFilter<"RunCrew"> | string
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
  }

  export type RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    update: XOR<RunCrewMembershipUpdateWithoutAthleteInput, RunCrewMembershipUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    data: XOR<RunCrewMembershipUpdateWithoutAthleteInput, RunCrewMembershipUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewMembershipScalarWhereInput
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewMembershipScalarWhereInput = {
    AND?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
    OR?: RunCrewMembershipScalarWhereInput[]
    NOT?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
    id?: StringFilter<"RunCrewMembership"> | string
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
  }

  export type RunCrewPostUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewPostWhereUniqueInput
    update: XOR<RunCrewPostUpdateWithoutAthleteInput, RunCrewPostUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewPostCreateWithoutAthleteInput, RunCrewPostUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewPostUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewPostWhereUniqueInput
    data: XOR<RunCrewPostUpdateWithoutAthleteInput, RunCrewPostUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewPostUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewPostScalarWhereInput
    data: XOR<RunCrewPostUpdateManyMutationInput, RunCrewPostUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewPostScalarWhereInput = {
    AND?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
    OR?: RunCrewPostScalarWhereInput[]
    NOT?: RunCrewPostScalarWhereInput | RunCrewPostScalarWhereInput[]
    id?: StringFilter<"RunCrewPost"> | string
    runCrewId?: StringFilter<"RunCrewPost"> | string
    athleteId?: StringFilter<"RunCrewPost"> | string
    content?: StringFilter<"RunCrewPost"> | string
    imageUrl?: StringNullableFilter<"RunCrewPost"> | string | null
    likes?: IntFilter<"RunCrewPost"> | number
    createdAt?: DateTimeFilter<"RunCrewPost"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPost"> | Date | string
  }

  export type RunCrewPostCommentUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewPostCommentWhereUniqueInput
    update: XOR<RunCrewPostCommentUpdateWithoutAthleteInput, RunCrewPostCommentUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewPostCommentCreateWithoutAthleteInput, RunCrewPostCommentUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewPostCommentUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewPostCommentWhereUniqueInput
    data: XOR<RunCrewPostCommentUpdateWithoutAthleteInput, RunCrewPostCommentUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewPostCommentUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewPostCommentScalarWhereInput
    data: XOR<RunCrewPostCommentUpdateManyMutationInput, RunCrewPostCommentUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewPostCommentScalarWhereInput = {
    AND?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
    OR?: RunCrewPostCommentScalarWhereInput[]
    NOT?: RunCrewPostCommentScalarWhereInput | RunCrewPostCommentScalarWhereInput[]
    id?: StringFilter<"RunCrewPostComment"> | string
    postId?: StringFilter<"RunCrewPostComment"> | string
    athleteId?: StringFilter<"RunCrewPostComment"> | string
    content?: StringFilter<"RunCrewPostComment"> | string
    createdAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewPostComment"> | Date | string
  }

  export type RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    update: XOR<RunCrewLeaderboardUpdateWithoutAthleteInput, RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    data: XOR<RunCrewLeaderboardUpdateWithoutAthleteInput, RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewLeaderboardScalarWhereInput
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewLeaderboardScalarWhereInput = {
    AND?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
    OR?: RunCrewLeaderboardScalarWhereInput[]
    NOT?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
    id?: StringFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
  }

  export type RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    update: XOR<RaceUpdateWithoutCreatedByAthleteInput, RaceUncheckedUpdateWithoutCreatedByAthleteInput>
    create: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput>
  }

  export type RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    data: XOR<RaceUpdateWithoutCreatedByAthleteInput, RaceUncheckedUpdateWithoutCreatedByAthleteInput>
  }

  export type RaceUpdateManyWithWhereWithoutCreatedByAthleteInput = {
    where: RaceScalarWhereInput
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyWithoutCreatedByAthleteInput>
  }

  export type RaceScalarWhereInput = {
    AND?: RaceScalarWhereInput | RaceScalarWhereInput[]
    OR?: RaceScalarWhereInput[]
    NOT?: RaceScalarWhereInput | RaceScalarWhereInput[]
    id?: StringFilter<"Race"> | string
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
  }

  export type TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    update: XOR<TrainingPlanUpdateWithoutAthleteInput, TrainingPlanUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    data: XOR<TrainingPlanUpdateWithoutAthleteInput, TrainingPlanUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingPlanUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingPlanScalarWhereInput
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingPlanScalarWhereInput = {
    AND?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
    OR?: TrainingPlanScalarWhereInput[]
    NOT?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
    id?: StringFilter<"TrainingPlan"> | string
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
  }

  export type TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    update: XOR<TrainingDayPlannedUpdateWithoutAthleteInput, TrainingDayPlannedUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    data: XOR<TrainingDayPlannedUpdateWithoutAthleteInput, TrainingDayPlannedUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingDayPlannedScalarWhereInput
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingDayPlannedScalarWhereInput = {
    AND?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
    OR?: TrainingDayPlannedScalarWhereInput[]
    NOT?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
    id?: StringFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
  }

  export type TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    update: XOR<TrainingDayExecutedUpdateWithoutAthleteInput, TrainingDayExecutedUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    data: XOR<TrainingDayExecutedUpdateWithoutAthleteInput, TrainingDayExecutedUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingDayExecutedScalarWhereInput
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingDayExecutedScalarWhereInput = {
    AND?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
    OR?: TrainingDayExecutedScalarWhereInput[]
    NOT?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
    id?: StringFilter<"TrainingDayExecuted"> | string
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
  }

  export type FounderUpsertWithoutAthleteInput = {
    update: XOR<FounderUpdateWithoutAthleteInput, FounderUncheckedUpdateWithoutAthleteInput>
    create: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutAthleteInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutAthleteInput, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type FounderUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type AthleteCreateWithoutActivitiesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutActivitiesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutActivitiesInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
  }

  export type AthleteUpsertWithoutActivitiesInput = {
    update: XOR<AthleteUpdateWithoutActivitiesInput, AthleteUncheckedUpdateWithoutActivitiesInput>
    create: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutActivitiesInput, AthleteUncheckedUpdateWithoutActivitiesInput>
  }

  export type AthleteUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutAdminRunCrewsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutAdminRunCrewsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutAdminRunCrewsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
  }

  export type RunCrewMembershipCreateWithoutRunCrewInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    create: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMembershipCreateManyRunCrewInputEnvelope = {
    data: RunCrewMembershipCreateManyRunCrewInput | RunCrewMembershipCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewPostCreateWithoutRunCrewInput = {
    id?: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewPostsInput
    comments?: RunCrewPostCommentCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type RunCrewPostCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewPostWhereUniqueInput
    create: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewPostCreateManyRunCrewInputEnvelope = {
    data: RunCrewPostCreateManyRunCrewInput | RunCrewPostCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewLeaderboardCreateWithoutRunCrewInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput
  }

  export type RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    create: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardCreateManyRunCrewInputEnvelope = {
    data: RunCrewLeaderboardCreateManyRunCrewInput | RunCrewLeaderboardCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutAdminRunCrewsInput = {
    update: XOR<AthleteUpdateWithoutAdminRunCrewsInput, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
    create: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutAdminRunCrewsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutAdminRunCrewsInput, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
  }

  export type AthleteUpdateWithoutAdminRunCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutAdminRunCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    update: XOR<RunCrewMembershipUpdateWithoutRunCrewInput, RunCrewMembershipUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    data: XOR<RunCrewMembershipUpdateWithoutRunCrewInput, RunCrewMembershipUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewMembershipScalarWhereInput
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewPostUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewPostWhereUniqueInput
    update: XOR<RunCrewPostUpdateWithoutRunCrewInput, RunCrewPostUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewPostCreateWithoutRunCrewInput, RunCrewPostUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewPostUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewPostWhereUniqueInput
    data: XOR<RunCrewPostUpdateWithoutRunCrewInput, RunCrewPostUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewPostUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewPostScalarWhereInput
    data: XOR<RunCrewPostUpdateManyMutationInput, RunCrewPostUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    update: XOR<RunCrewLeaderboardUpdateWithoutRunCrewInput, RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    data: XOR<RunCrewLeaderboardUpdateWithoutRunCrewInput, RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewLeaderboardScalarWhereInput
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    posts?: RunCrewPostCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    runcrewAdminId: string
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: RunCrewPostUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutMembershipsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
  }

  export type AthleteCreateWithoutRunCrewMembershipsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewMembershipsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewMembershipsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
  }

  export type RunCrewUpsertWithoutMembershipsInput = {
    update: XOR<RunCrewUpdateWithoutMembershipsInput, RunCrewUncheckedUpdateWithoutMembershipsInput>
    create: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutMembershipsInput, RunCrewUncheckedUpdateWithoutMembershipsInput>
  }

  export type RunCrewUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneRequiredWithoutAdminRunCrewsNestedInput
    posts?: RunCrewPostUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: RunCrewPostUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewMembershipsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewMembershipsInput, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
    create: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewMembershipsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewMembershipsInput, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
  }

  export type AthleteUpdateWithoutRunCrewMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    runcrewAdminId: string
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutPostsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutPostsInput, RunCrewUncheckedCreateWithoutPostsInput>
  }

  export type AthleteCreateWithoutRunCrewPostsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewPostsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewPostsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewPostsInput, AthleteUncheckedCreateWithoutRunCrewPostsInput>
  }

  export type RunCrewPostCommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewPostCommentsInput
  }

  export type RunCrewPostCommentUncheckedCreateWithoutPostInput = {
    id?: string
    athleteId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentCreateOrConnectWithoutPostInput = {
    where: RunCrewPostCommentWhereUniqueInput
    create: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput>
  }

  export type RunCrewPostCommentCreateManyPostInputEnvelope = {
    data: RunCrewPostCommentCreateManyPostInput | RunCrewPostCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewUpsertWithoutPostsInput = {
    update: XOR<RunCrewUpdateWithoutPostsInput, RunCrewUncheckedUpdateWithoutPostsInput>
    create: XOR<RunCrewCreateWithoutPostsInput, RunCrewUncheckedCreateWithoutPostsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutPostsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutPostsInput, RunCrewUncheckedUpdateWithoutPostsInput>
  }

  export type RunCrewUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneRequiredWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewPostsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewPostsInput, AthleteUncheckedUpdateWithoutRunCrewPostsInput>
    create: XOR<AthleteCreateWithoutRunCrewPostsInput, AthleteUncheckedCreateWithoutRunCrewPostsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewPostsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewPostsInput, AthleteUncheckedUpdateWithoutRunCrewPostsInput>
  }

  export type AthleteUpdateWithoutRunCrewPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewPostCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: RunCrewPostCommentWhereUniqueInput
    update: XOR<RunCrewPostCommentUpdateWithoutPostInput, RunCrewPostCommentUncheckedUpdateWithoutPostInput>
    create: XOR<RunCrewPostCommentCreateWithoutPostInput, RunCrewPostCommentUncheckedCreateWithoutPostInput>
  }

  export type RunCrewPostCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: RunCrewPostCommentWhereUniqueInput
    data: XOR<RunCrewPostCommentUpdateWithoutPostInput, RunCrewPostCommentUncheckedUpdateWithoutPostInput>
  }

  export type RunCrewPostCommentUpdateManyWithWhereWithoutPostInput = {
    where: RunCrewPostCommentScalarWhereInput
    data: XOR<RunCrewPostCommentUpdateManyMutationInput, RunCrewPostCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type RunCrewPostCreateWithoutCommentsInput = {
    id?: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutPostsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewPostsInput
  }

  export type RunCrewPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    runCrewId: string
    athleteId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCreateOrConnectWithoutCommentsInput = {
    where: RunCrewPostWhereUniqueInput
    create: XOR<RunCrewPostCreateWithoutCommentsInput, RunCrewPostUncheckedCreateWithoutCommentsInput>
  }

  export type AthleteCreateWithoutRunCrewPostCommentsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewPostCommentsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewPostCommentsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewPostCommentsInput, AthleteUncheckedCreateWithoutRunCrewPostCommentsInput>
  }

  export type RunCrewPostUpsertWithoutCommentsInput = {
    update: XOR<RunCrewPostUpdateWithoutCommentsInput, RunCrewPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<RunCrewPostCreateWithoutCommentsInput, RunCrewPostUncheckedCreateWithoutCommentsInput>
    where?: RunCrewPostWhereInput
  }

  export type RunCrewPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: RunCrewPostWhereInput
    data: XOR<RunCrewPostUpdateWithoutCommentsInput, RunCrewPostUncheckedUpdateWithoutCommentsInput>
  }

  export type RunCrewPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutPostsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewPostsNestedInput
  }

  export type RunCrewPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteUpsertWithoutRunCrewPostCommentsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewPostCommentsInput, AthleteUncheckedUpdateWithoutRunCrewPostCommentsInput>
    create: XOR<AthleteCreateWithoutRunCrewPostCommentsInput, AthleteUncheckedCreateWithoutRunCrewPostCommentsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewPostCommentsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewPostCommentsInput, AthleteUncheckedUpdateWithoutRunCrewPostCommentsInput>
  }

  export type AthleteUpdateWithoutRunCrewPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    runcrewAdminId: string
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    posts?: RunCrewPostUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type AthleteCreateWithoutRunCrewLeaderboardsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
  }

  export type RunCrewUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<RunCrewUpdateWithoutLeaderboardEntriesInput, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutLeaderboardEntriesInput, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type RunCrewUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneRequiredWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewLeaderboardsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewLeaderboardsInput, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
    create: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewLeaderboardsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewLeaderboardsInput, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
  }

  export type AthleteUpdateWithoutRunCrewLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutCreatedRacesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutCreatedRacesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutCreatedRacesInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
  }

  export type TrainingPlanCreateWithoutRaceInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutRaceInput = {
    id?: string
    athleteId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput>
  }

  export type TrainingPlanCreateManyRaceInputEnvelope = {
    data: TrainingPlanCreateManyRaceInput | TrainingPlanCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutCreatedRacesInput = {
    update: XOR<AthleteUpdateWithoutCreatedRacesInput, AthleteUncheckedUpdateWithoutCreatedRacesInput>
    create: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutCreatedRacesInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutCreatedRacesInput, AthleteUncheckedUpdateWithoutCreatedRacesInput>
  }

  export type AthleteUpdateWithoutCreatedRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutCreatedRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type TrainingPlanUpsertWithWhereUniqueWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    update: XOR<TrainingPlanUpdateWithoutRaceInput, TrainingPlanUncheckedUpdateWithoutRaceInput>
    create: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput>
  }

  export type TrainingPlanUpdateWithWhereUniqueWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    data: XOR<TrainingPlanUpdateWithoutRaceInput, TrainingPlanUncheckedUpdateWithoutRaceInput>
  }

  export type TrainingPlanUpdateManyWithWhereWithoutRaceInput = {
    where: TrainingPlanScalarWhereInput
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyWithoutRaceInput>
  }

  export type AthleteCreateWithoutTrainingPlansInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutTrainingPlansInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutTrainingPlansInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
  }

  export type RaceCreateWithoutTrainingPlansInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAthlete?: AthleteCreateNestedOneWithoutCreatedRacesInput
  }

  export type RaceUncheckedCreateWithoutTrainingPlansInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceCreateOrConnectWithoutTrainingPlansInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
  }

  export type TrainingDayPlannedCreateWithoutTrainingPlanInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput = {
    id?: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    create: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedCreateManyTrainingPlanInputEnvelope = {
    data: TrainingDayPlannedCreateManyTrainingPlanInput | TrainingDayPlannedCreateManyTrainingPlanInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanExecutionCreateWithoutTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    create: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope = {
    data: TrainingPlanExecutionCreateManyTrainingPlanInput | TrainingPlanExecutionCreateManyTrainingPlanInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutTrainingPlansInput = {
    update: XOR<AthleteUpdateWithoutTrainingPlansInput, AthleteUncheckedUpdateWithoutTrainingPlansInput>
    create: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutTrainingPlansInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutTrainingPlansInput, AthleteUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type AthleteUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RaceUpsertWithoutTrainingPlansInput = {
    update: XOR<RaceUpdateWithoutTrainingPlansInput, RaceUncheckedUpdateWithoutTrainingPlansInput>
    create: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutTrainingPlansInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutTrainingPlansInput, RaceUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type RaceUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAthlete?: AthleteUpdateOneWithoutCreatedRacesNestedInput
  }

  export type RaceUncheckedUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    update: XOR<TrainingDayPlannedUpdateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput>
    create: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    data: XOR<TrainingDayPlannedUpdateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput = {
    where: TrainingDayPlannedScalarWhereInput
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    update: XOR<TrainingPlanExecutionUpdateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput>
    create: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    data: XOR<TrainingPlanExecutionUpdateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionScalarWhereInput
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionScalarWhereInput = {
    AND?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
    OR?: TrainingPlanExecutionScalarWhereInput[]
    NOT?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
    id?: StringFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
  }

  export type TrainingPlanCreateWithoutPlannedDaysInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutPlannedDaysInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutPlannedDaysInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
  }

  export type AthleteCreateWithoutPlannedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutPlannedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutPlannedDaysInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
  }

  export type TrainingPlanUpsertWithoutPlannedDaysInput = {
    update: XOR<TrainingPlanUpdateWithoutPlannedDaysInput, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
    create: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    where?: TrainingPlanWhereInput
  }

  export type TrainingPlanUpdateToOneWithWhereWithoutPlannedDaysInput = {
    where?: TrainingPlanWhereInput
    data: XOR<TrainingPlanUpdateWithoutPlannedDaysInput, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type TrainingPlanUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type AthleteUpsertWithoutPlannedDaysInput = {
    update: XOR<AthleteUpdateWithoutPlannedDaysInput, AthleteUncheckedUpdateWithoutPlannedDaysInput>
    create: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutPlannedDaysInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutPlannedDaysInput, AthleteUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type AthleteUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type TrainingPlanCreateWithoutExecutionsInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutExecutionsInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutExecutionsInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
  }

  export type TrainingDayExecutedCreateWithoutExecutionInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateWithoutExecutionInput = {
    id?: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateOrConnectWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    create: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput>
  }

  export type TrainingDayExecutedCreateManyExecutionInputEnvelope = {
    data: TrainingDayExecutedCreateManyExecutionInput | TrainingDayExecutedCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanUpsertWithoutExecutionsInput = {
    update: XOR<TrainingPlanUpdateWithoutExecutionsInput, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    where?: TrainingPlanWhereInput
  }

  export type TrainingPlanUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TrainingPlanWhereInput
    data: XOR<TrainingPlanUpdateWithoutExecutionsInput, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TrainingPlanUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    update: XOR<TrainingDayExecutedUpdateWithoutExecutionInput, TrainingDayExecutedUncheckedUpdateWithoutExecutionInput>
    create: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput>
  }

  export type TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    data: XOR<TrainingDayExecutedUpdateWithoutExecutionInput, TrainingDayExecutedUncheckedUpdateWithoutExecutionInput>
  }

  export type TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput = {
    where: TrainingDayExecutedScalarWhereInput
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyWithoutExecutionInput>
  }

  export type TrainingPlanExecutionCreateWithoutExecutedDaysInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutExecutionsInput
  }

  export type TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    create: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
  }

  export type AthleteCreateWithoutExecutedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutExecutedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutExecutedDaysInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
  }

  export type TrainingPlanExecutionUpsertWithoutExecutedDaysInput = {
    update: XOR<TrainingPlanExecutionUpdateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
    create: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    where?: TrainingPlanExecutionWhereInput
  }

  export type TrainingPlanExecutionUpdateToOneWithWhereWithoutExecutedDaysInput = {
    where?: TrainingPlanExecutionWhereInput
    data: XOR<TrainingPlanExecutionUpdateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type TrainingPlanExecutionUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteUpsertWithoutExecutedDaysInput = {
    update: XOR<AthleteUpdateWithoutExecutedDaysInput, AthleteUncheckedUpdateWithoutExecutedDaysInput>
    create: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutExecutedDaysInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutExecutedDaysInput, AthleteUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutFounderInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutFounderInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPosts?: RunCrewPostUncheckedCreateNestedManyWithoutAthleteInput
    runCrewPostComments?: RunCrewPostCommentUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutFounderInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskCreateWithoutFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUncheckedCreateWithoutFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskCreateOrConnectWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    create: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskCreateManyFounderInputEnvelope = {
    data: FounderTaskCreateManyFounderInput | FounderTaskCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type CrmContactCreateWithoutFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUncheckedCreateWithoutFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactCreateOrConnectWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    create: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput>
  }

  export type CrmContactCreateManyFounderInputEnvelope = {
    data: CrmContactCreateManyFounderInput | CrmContactCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapItemCreateWithoutFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUncheckedCreateWithoutFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateOrConnectWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    create: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput>
  }

  export type RoadmapItemCreateManyFounderInputEnvelope = {
    data: RoadmapItemCreateManyFounderInput | RoadmapItemCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutFounderInput = {
    update: XOR<AthleteUpdateWithoutFounderInput, AthleteUncheckedUpdateWithoutFounderInput>
    create: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutFounderInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutFounderInput, AthleteUncheckedUpdateWithoutFounderInput>
  }

  export type AthleteUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPosts?: RunCrewPostUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewPostComments?: RunCrewPostCommentUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
  }

  export type FounderTaskUpsertWithWhereUniqueWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    update: XOR<FounderTaskUpdateWithoutFounderInput, FounderTaskUncheckedUpdateWithoutFounderInput>
    create: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskUpdateWithWhereUniqueWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    data: XOR<FounderTaskUpdateWithoutFounderInput, FounderTaskUncheckedUpdateWithoutFounderInput>
  }

  export type FounderTaskUpdateManyWithWhereWithoutFounderInput = {
    where: FounderTaskScalarWhereInput
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyWithoutFounderInput>
  }

  export type FounderTaskScalarWhereInput = {
    AND?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
    OR?: FounderTaskScalarWhereInput[]
    NOT?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
    id?: StringFilter<"FounderTask"> | string
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
  }

  export type CrmContactUpsertWithWhereUniqueWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    update: XOR<CrmContactUpdateWithoutFounderInput, CrmContactUncheckedUpdateWithoutFounderInput>
    create: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput>
  }

  export type CrmContactUpdateWithWhereUniqueWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    data: XOR<CrmContactUpdateWithoutFounderInput, CrmContactUncheckedUpdateWithoutFounderInput>
  }

  export type CrmContactUpdateManyWithWhereWithoutFounderInput = {
    where: CrmContactScalarWhereInput
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyWithoutFounderInput>
  }

  export type CrmContactScalarWhereInput = {
    AND?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
    OR?: CrmContactScalarWhereInput[]
    NOT?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
    id?: StringFilter<"CrmContact"> | string
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
  }

  export type RoadmapItemUpsertWithWhereUniqueWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    update: XOR<RoadmapItemUpdateWithoutFounderInput, RoadmapItemUncheckedUpdateWithoutFounderInput>
    create: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput>
  }

  export type RoadmapItemUpdateWithWhereUniqueWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    data: XOR<RoadmapItemUpdateWithoutFounderInput, RoadmapItemUncheckedUpdateWithoutFounderInput>
  }

  export type RoadmapItemUpdateManyWithWhereWithoutFounderInput = {
    where: RoadmapItemScalarWhereInput
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyWithoutFounderInput>
  }

  export type RoadmapItemScalarWhereInput = {
    AND?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    OR?: RoadmapItemScalarWhereInput[]
    NOT?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
  }

  export type FounderCreateWithoutTasksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutTasksInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutTasksInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
  }

  export type FounderUpsertWithoutTasksInput = {
    update: XOR<FounderUpdateWithoutTasksInput, FounderUncheckedUpdateWithoutTasksInput>
    create: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutTasksInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutTasksInput, FounderUncheckedUpdateWithoutTasksInput>
  }

  export type FounderUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateWithoutCrmContactsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutCrmContactsInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutCrmContactsInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
  }

  export type FounderUpsertWithoutCrmContactsInput = {
    update: XOR<FounderUpdateWithoutCrmContactsInput, FounderUncheckedUpdateWithoutCrmContactsInput>
    create: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutCrmContactsInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutCrmContactsInput, FounderUncheckedUpdateWithoutCrmContactsInput>
  }

  export type FounderUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateWithoutRoadmapItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutRoadmapItemsInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutRoadmapItemsInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
  }

  export type FounderUpsertWithoutRoadmapItemsInput = {
    update: XOR<FounderUpdateWithoutRoadmapItemsInput, FounderUncheckedUpdateWithoutRoadmapItemsInput>
    create: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutRoadmapItemsInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutRoadmapItemsInput, FounderUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type FounderUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type AthleteActivityCreateManyAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewCreateManyAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentCreateManyAthleteInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceCreateManyCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanCreateManyAthleteInput = {
    id?: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateManyAthleteInput = {
    id?: string
    trainingPlanId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateManyAthleteInput = {
    id?: string
    executionId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    posts?: RunCrewPostUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutPostsNestedInput
    comments?: RunCrewPostCommentUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: RunCrewPostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: RunCrewPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RunCrewPostCommentUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceUpdateWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateManyWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    content: string
    imageUrl?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewPostsNestedInput
    comments?: RunCrewPostCommentUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: RunCrewPostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type RunCrewPostUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentCreateManyPostInput = {
    id?: string
    athleteId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewPostCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewPostCommentsNestedInput
  }

  export type RunCrewPostCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewPostCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanCreateManyRaceInput = {
    id?: string
    athleteId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateManyWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateManyTrainingPlanInput = {
    id?: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionCreateManyTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateManyExecutionInput = {
    id?: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateManyFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactCreateManyFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateManyFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}