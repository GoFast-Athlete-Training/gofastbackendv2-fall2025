
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Athlete
 * 
 */
export type Athlete = $Result.DefaultSelection<Prisma.$AthletePayload>
/**
 * Model AthleteActivity
 * 
 */
export type AthleteActivity = $Result.DefaultSelection<Prisma.$AthleteActivityPayload>
/**
 * Model RunCrew
 * 
 */
export type RunCrew = $Result.DefaultSelection<Prisma.$RunCrewPayload>
/**
 * Model RunCrewMembership
 * 
 */
export type RunCrewMembership = $Result.DefaultSelection<Prisma.$RunCrewMembershipPayload>
/**
 * Model RunCrewMessage
 * 
 */
export type RunCrewMessage = $Result.DefaultSelection<Prisma.$RunCrewMessagePayload>
/**
 * Model RunCrewAnnouncement
 * 
 */
export type RunCrewAnnouncement = $Result.DefaultSelection<Prisma.$RunCrewAnnouncementPayload>
/**
 * Model RunCrewLeaderboard
 * 
 */
export type RunCrewLeaderboard = $Result.DefaultSelection<Prisma.$RunCrewLeaderboardPayload>
/**
 * Model RunCrewRun
 * 
 */
export type RunCrewRun = $Result.DefaultSelection<Prisma.$RunCrewRunPayload>
/**
 * Model RunCrewRunRSVP
 * 
 */
export type RunCrewRunRSVP = $Result.DefaultSelection<Prisma.$RunCrewRunRSVPPayload>
/**
 * Model RunCrewEvent
 * 
 */
export type RunCrewEvent = $Result.DefaultSelection<Prisma.$RunCrewEventPayload>
/**
 * Model RunCrewEventRSVP
 * 
 */
export type RunCrewEventRSVP = $Result.DefaultSelection<Prisma.$RunCrewEventRSVPPayload>
/**
 * Model RunCrewManager
 * 
 */
export type RunCrewManager = $Result.DefaultSelection<Prisma.$RunCrewManagerPayload>
/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model TrainingPlan
 * 
 */
export type TrainingPlan = $Result.DefaultSelection<Prisma.$TrainingPlanPayload>
/**
 * Model TrainingDayPlanned
 * 
 */
export type TrainingDayPlanned = $Result.DefaultSelection<Prisma.$TrainingDayPlannedPayload>
/**
 * Model TrainingPlanExecution
 * 
 */
export type TrainingPlanExecution = $Result.DefaultSelection<Prisma.$TrainingPlanExecutionPayload>
/**
 * Model TrainingDayExecuted
 * 
 */
export type TrainingDayExecuted = $Result.DefaultSelection<Prisma.$TrainingDayExecutedPayload>
/**
 * Model Founder
 * 
 */
export type Founder = $Result.DefaultSelection<Prisma.$FounderPayload>
/**
 * Model FounderTask
 * 
 */
export type FounderTask = $Result.DefaultSelection<Prisma.$FounderTaskPayload>
/**
 * Model CrmContact
 * 
 */
export type CrmContact = $Result.DefaultSelection<Prisma.$CrmContactPayload>
/**
 * Model RoadmapItem
 * 
 */
export type RoadmapItem = $Result.DefaultSelection<Prisma.$RoadmapItemPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyFounder
 * 
 */
export type CompanyFounder = $Result.DefaultSelection<Prisma.$CompanyFounderPayload>
/**
 * Model CompanyEmployee
 * 
 */
export type CompanyEmployee = $Result.DefaultSelection<Prisma.$CompanyEmployeePayload>
/**
 * Model CompanyRoadmapItem
 * 
 */
export type CompanyRoadmapItem = $Result.DefaultSelection<Prisma.$CompanyRoadmapItemPayload>
/**
 * Model CompanyCrmContact
 * 
 */
export type CompanyCrmContact = $Result.DefaultSelection<Prisma.$CompanyCrmContactPayload>
/**
 * Model CompanyFinancialSpend
 * 
 */
export type CompanyFinancialSpend = $Result.DefaultSelection<Prisma.$CompanyFinancialSpendPayload>
/**
 * Model CompanyFinancialProjection
 * 
 */
export type CompanyFinancialProjection = $Result.DefaultSelection<Prisma.$CompanyFinancialProjectionPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model GoFastCompany
 * 
 */
export type GoFastCompany = $Result.DefaultSelection<Prisma.$GoFastCompanyPayload>
/**
 * Model CompanyStaff
 * 
 */
export type CompanyStaff = $Result.DefaultSelection<Prisma.$CompanyStaffPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model PipelineConfig
 * 
 */
export type PipelineConfig = $Result.DefaultSelection<Prisma.$PipelineConfigPayload>
/**
 * Model ProductPipelineItem
 * 
 */
export type ProductPipelineItem = $Result.DefaultSelection<Prisma.$ProductPipelineItemPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Athletes
 * const athletes = await prisma.athlete.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Athletes
   * const athletes = await prisma.athlete.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.athlete`: Exposes CRUD operations for the **Athlete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Athletes
    * const athletes = await prisma.athlete.findMany()
    * ```
    */
  get athlete(): Prisma.AthleteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.athleteActivity`: Exposes CRUD operations for the **AthleteActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AthleteActivities
    * const athleteActivities = await prisma.athleteActivity.findMany()
    * ```
    */
  get athleteActivity(): Prisma.AthleteActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrew`: Exposes CRUD operations for the **RunCrew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrews
    * const runCrews = await prisma.runCrew.findMany()
    * ```
    */
  get runCrew(): Prisma.RunCrewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewMembership`: Exposes CRUD operations for the **RunCrewMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewMemberships
    * const runCrewMemberships = await prisma.runCrewMembership.findMany()
    * ```
    */
  get runCrewMembership(): Prisma.RunCrewMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewMessage`: Exposes CRUD operations for the **RunCrewMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewMessages
    * const runCrewMessages = await prisma.runCrewMessage.findMany()
    * ```
    */
  get runCrewMessage(): Prisma.RunCrewMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewAnnouncement`: Exposes CRUD operations for the **RunCrewAnnouncement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewAnnouncements
    * const runCrewAnnouncements = await prisma.runCrewAnnouncement.findMany()
    * ```
    */
  get runCrewAnnouncement(): Prisma.RunCrewAnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewLeaderboard`: Exposes CRUD operations for the **RunCrewLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewLeaderboards
    * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany()
    * ```
    */
  get runCrewLeaderboard(): Prisma.RunCrewLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewRun`: Exposes CRUD operations for the **RunCrewRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewRuns
    * const runCrewRuns = await prisma.runCrewRun.findMany()
    * ```
    */
  get runCrewRun(): Prisma.RunCrewRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewRunRSVP`: Exposes CRUD operations for the **RunCrewRunRSVP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewRunRSVPS
    * const runCrewRunRSVPS = await prisma.runCrewRunRSVP.findMany()
    * ```
    */
  get runCrewRunRSVP(): Prisma.RunCrewRunRSVPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewEvent`: Exposes CRUD operations for the **RunCrewEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewEvents
    * const runCrewEvents = await prisma.runCrewEvent.findMany()
    * ```
    */
  get runCrewEvent(): Prisma.RunCrewEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewEventRSVP`: Exposes CRUD operations for the **RunCrewEventRSVP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewEventRSVPS
    * const runCrewEventRSVPS = await prisma.runCrewEventRSVP.findMany()
    * ```
    */
  get runCrewEventRSVP(): Prisma.RunCrewEventRSVPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCrewManager`: Exposes CRUD operations for the **RunCrewManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCrewManagers
    * const runCrewManagers = await prisma.runCrewManager.findMany()
    * ```
    */
  get runCrewManager(): Prisma.RunCrewManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPlan`: Exposes CRUD operations for the **TrainingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPlans
    * const trainingPlans = await prisma.trainingPlan.findMany()
    * ```
    */
  get trainingPlan(): Prisma.TrainingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDayPlanned`: Exposes CRUD operations for the **TrainingDayPlanned** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDayPlanneds
    * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany()
    * ```
    */
  get trainingDayPlanned(): Prisma.TrainingDayPlannedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPlanExecution`: Exposes CRUD operations for the **TrainingPlanExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPlanExecutions
    * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany()
    * ```
    */
  get trainingPlanExecution(): Prisma.TrainingPlanExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDayExecuted`: Exposes CRUD operations for the **TrainingDayExecuted** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDayExecuteds
    * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany()
    * ```
    */
  get trainingDayExecuted(): Prisma.TrainingDayExecutedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.founder`: Exposes CRUD operations for the **Founder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Founders
    * const founders = await prisma.founder.findMany()
    * ```
    */
  get founder(): Prisma.FounderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.founderTask`: Exposes CRUD operations for the **FounderTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FounderTasks
    * const founderTasks = await prisma.founderTask.findMany()
    * ```
    */
  get founderTask(): Prisma.FounderTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crmContact`: Exposes CRUD operations for the **CrmContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmContacts
    * const crmContacts = await prisma.crmContact.findMany()
    * ```
    */
  get crmContact(): Prisma.CrmContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapItem`: Exposes CRUD operations for the **RoadmapItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapItems
    * const roadmapItems = await prisma.roadmapItem.findMany()
    * ```
    */
  get roadmapItem(): Prisma.RoadmapItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyFounder`: Exposes CRUD operations for the **CompanyFounder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyFounders
    * const companyFounders = await prisma.companyFounder.findMany()
    * ```
    */
  get companyFounder(): Prisma.CompanyFounderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyEmployee`: Exposes CRUD operations for the **CompanyEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyEmployees
    * const companyEmployees = await prisma.companyEmployee.findMany()
    * ```
    */
  get companyEmployee(): Prisma.CompanyEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyRoadmapItem`: Exposes CRUD operations for the **CompanyRoadmapItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyRoadmapItems
    * const companyRoadmapItems = await prisma.companyRoadmapItem.findMany()
    * ```
    */
  get companyRoadmapItem(): Prisma.CompanyRoadmapItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyCrmContact`: Exposes CRUD operations for the **CompanyCrmContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyCrmContacts
    * const companyCrmContacts = await prisma.companyCrmContact.findMany()
    * ```
    */
  get companyCrmContact(): Prisma.CompanyCrmContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyFinancialSpend`: Exposes CRUD operations for the **CompanyFinancialSpend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyFinancialSpends
    * const companyFinancialSpends = await prisma.companyFinancialSpend.findMany()
    * ```
    */
  get companyFinancialSpend(): Prisma.CompanyFinancialSpendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyFinancialProjection`: Exposes CRUD operations for the **CompanyFinancialProjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyFinancialProjections
    * const companyFinancialProjections = await prisma.companyFinancialProjection.findMany()
    * ```
    */
  get companyFinancialProjection(): Prisma.CompanyFinancialProjectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goFastCompany`: Exposes CRUD operations for the **GoFastCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoFastCompanies
    * const goFastCompanies = await prisma.goFastCompany.findMany()
    * ```
    */
  get goFastCompany(): Prisma.GoFastCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyStaff`: Exposes CRUD operations for the **CompanyStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyStaffs
    * const companyStaffs = await prisma.companyStaff.findMany()
    * ```
    */
  get companyStaff(): Prisma.CompanyStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipelineConfig`: Exposes CRUD operations for the **PipelineConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PipelineConfigs
    * const pipelineConfigs = await prisma.pipelineConfig.findMany()
    * ```
    */
  get pipelineConfig(): Prisma.PipelineConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productPipelineItem`: Exposes CRUD operations for the **ProductPipelineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPipelineItems
    * const productPipelineItems = await prisma.productPipelineItem.findMany()
    * ```
    */
  get productPipelineItem(): Prisma.ProductPipelineItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Athlete: 'Athlete',
    AthleteActivity: 'AthleteActivity',
    RunCrew: 'RunCrew',
    RunCrewMembership: 'RunCrewMembership',
    RunCrewMessage: 'RunCrewMessage',
    RunCrewAnnouncement: 'RunCrewAnnouncement',
    RunCrewLeaderboard: 'RunCrewLeaderboard',
    RunCrewRun: 'RunCrewRun',
    RunCrewRunRSVP: 'RunCrewRunRSVP',
    RunCrewEvent: 'RunCrewEvent',
    RunCrewEventRSVP: 'RunCrewEventRSVP',
    RunCrewManager: 'RunCrewManager',
    Race: 'Race',
    TrainingPlan: 'TrainingPlan',
    TrainingDayPlanned: 'TrainingDayPlanned',
    TrainingPlanExecution: 'TrainingPlanExecution',
    TrainingDayExecuted: 'TrainingDayExecuted',
    Founder: 'Founder',
    FounderTask: 'FounderTask',
    CrmContact: 'CrmContact',
    RoadmapItem: 'RoadmapItem',
    Company: 'Company',
    CompanyFounder: 'CompanyFounder',
    CompanyEmployee: 'CompanyEmployee',
    CompanyRoadmapItem: 'CompanyRoadmapItem',
    CompanyCrmContact: 'CompanyCrmContact',
    CompanyFinancialSpend: 'CompanyFinancialSpend',
    CompanyFinancialProjection: 'CompanyFinancialProjection',
    Task: 'Task',
    Message: 'Message',
    GoFastCompany: 'GoFastCompany',
    CompanyStaff: 'CompanyStaff',
    Contact: 'Contact',
    Pipeline: 'Pipeline',
    PipelineConfig: 'PipelineConfig',
    ProductPipelineItem: 'ProductPipelineItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "athlete" | "athleteActivity" | "runCrew" | "runCrewMembership" | "runCrewMessage" | "runCrewAnnouncement" | "runCrewLeaderboard" | "runCrewRun" | "runCrewRunRSVP" | "runCrewEvent" | "runCrewEventRSVP" | "runCrewManager" | "race" | "trainingPlan" | "trainingDayPlanned" | "trainingPlanExecution" | "trainingDayExecuted" | "founder" | "founderTask" | "crmContact" | "roadmapItem" | "company" | "companyFounder" | "companyEmployee" | "companyRoadmapItem" | "companyCrmContact" | "companyFinancialSpend" | "companyFinancialProjection" | "task" | "message" | "goFastCompany" | "companyStaff" | "contact" | "pipeline" | "pipelineConfig" | "productPipelineItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Athlete: {
        payload: Prisma.$AthletePayload<ExtArgs>
        fields: Prisma.AthleteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findFirst: {
            args: Prisma.AthleteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findMany: {
            args: Prisma.AthleteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          create: {
            args: Prisma.AthleteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          createMany: {
            args: Prisma.AthleteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AthleteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          delete: {
            args: Prisma.AthleteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          update: {
            args: Prisma.AthleteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          deleteMany: {
            args: Prisma.AthleteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AthleteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AthleteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          upsert: {
            args: Prisma.AthleteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          aggregate: {
            args: Prisma.AthleteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAthlete>
          }
          groupBy: {
            args: Prisma.AthleteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AthleteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleteCountArgs<ExtArgs>
            result: $Utils.Optional<AthleteCountAggregateOutputType> | number
          }
        }
      }
      AthleteActivity: {
        payload: Prisma.$AthleteActivityPayload<ExtArgs>
        fields: Prisma.AthleteActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleteActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleteActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          findFirst: {
            args: Prisma.AthleteActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleteActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          findMany: {
            args: Prisma.AthleteActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          create: {
            args: Prisma.AthleteActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          createMany: {
            args: Prisma.AthleteActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AthleteActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          delete: {
            args: Prisma.AthleteActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          update: {
            args: Prisma.AthleteActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          deleteMany: {
            args: Prisma.AthleteActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AthleteActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AthleteActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>[]
          }
          upsert: {
            args: Prisma.AthleteActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleteActivityPayload>
          }
          aggregate: {
            args: Prisma.AthleteActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAthleteActivity>
          }
          groupBy: {
            args: Prisma.AthleteActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AthleteActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleteActivityCountArgs<ExtArgs>
            result: $Utils.Optional<AthleteActivityCountAggregateOutputType> | number
          }
        }
      }
      RunCrew: {
        payload: Prisma.$RunCrewPayload<ExtArgs>
        fields: Prisma.RunCrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          findFirst: {
            args: Prisma.RunCrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          findMany: {
            args: Prisma.RunCrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          create: {
            args: Prisma.RunCrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          createMany: {
            args: Prisma.RunCrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          delete: {
            args: Prisma.RunCrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          update: {
            args: Prisma.RunCrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewPayload>
          }
          aggregate: {
            args: Prisma.RunCrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrew>
          }
          groupBy: {
            args: Prisma.RunCrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewCountAggregateOutputType> | number
          }
        }
      }
      RunCrewMembership: {
        payload: Prisma.$RunCrewMembershipPayload<ExtArgs>
        fields: Prisma.RunCrewMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          findFirst: {
            args: Prisma.RunCrewMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          findMany: {
            args: Prisma.RunCrewMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          create: {
            args: Prisma.RunCrewMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          createMany: {
            args: Prisma.RunCrewMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          delete: {
            args: Prisma.RunCrewMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          update: {
            args: Prisma.RunCrewMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMembershipPayload>
          }
          aggregate: {
            args: Prisma.RunCrewMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewMembership>
          }
          groupBy: {
            args: Prisma.RunCrewMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMembershipCountAggregateOutputType> | number
          }
        }
      }
      RunCrewMessage: {
        payload: Prisma.$RunCrewMessagePayload<ExtArgs>
        fields: Prisma.RunCrewMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          findFirst: {
            args: Prisma.RunCrewMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          findMany: {
            args: Prisma.RunCrewMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>[]
          }
          create: {
            args: Prisma.RunCrewMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          createMany: {
            args: Prisma.RunCrewMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>[]
          }
          delete: {
            args: Prisma.RunCrewMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          update: {
            args: Prisma.RunCrewMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          deleteMany: {
            args: Prisma.RunCrewMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>[]
          }
          upsert: {
            args: Prisma.RunCrewMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewMessagePayload>
          }
          aggregate: {
            args: Prisma.RunCrewMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewMessage>
          }
          groupBy: {
            args: Prisma.RunCrewMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewMessageCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewMessageCountAggregateOutputType> | number
          }
        }
      }
      RunCrewAnnouncement: {
        payload: Prisma.$RunCrewAnnouncementPayload<ExtArgs>
        fields: Prisma.RunCrewAnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewAnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewAnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          findFirst: {
            args: Prisma.RunCrewAnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewAnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          findMany: {
            args: Prisma.RunCrewAnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>[]
          }
          create: {
            args: Prisma.RunCrewAnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          createMany: {
            args: Prisma.RunCrewAnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewAnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>[]
          }
          delete: {
            args: Prisma.RunCrewAnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          update: {
            args: Prisma.RunCrewAnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewAnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewAnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewAnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewAnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewAnnouncementPayload>
          }
          aggregate: {
            args: Prisma.RunCrewAnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewAnnouncement>
          }
          groupBy: {
            args: Prisma.RunCrewAnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewAnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewAnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewAnnouncementCountAggregateOutputType> | number
          }
        }
      }
      RunCrewLeaderboard: {
        payload: Prisma.$RunCrewLeaderboardPayload<ExtArgs>
        fields: Prisma.RunCrewLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.RunCrewLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          findMany: {
            args: Prisma.RunCrewLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          create: {
            args: Prisma.RunCrewLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          createMany: {
            args: Prisma.RunCrewLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.RunCrewLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          update: {
            args: Prisma.RunCrewLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.RunCrewLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewLeaderboard>
          }
          groupBy: {
            args: Prisma.RunCrewLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      RunCrewRun: {
        payload: Prisma.$RunCrewRunPayload<ExtArgs>
        fields: Prisma.RunCrewRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          findFirst: {
            args: Prisma.RunCrewRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          findMany: {
            args: Prisma.RunCrewRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>[]
          }
          create: {
            args: Prisma.RunCrewRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          createMany: {
            args: Prisma.RunCrewRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>[]
          }
          delete: {
            args: Prisma.RunCrewRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          update: {
            args: Prisma.RunCrewRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunPayload>
          }
          aggregate: {
            args: Prisma.RunCrewRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewRun>
          }
          groupBy: {
            args: Prisma.RunCrewRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewRunCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewRunCountAggregateOutputType> | number
          }
        }
      }
      RunCrewRunRSVP: {
        payload: Prisma.$RunCrewRunRSVPPayload<ExtArgs>
        fields: Prisma.RunCrewRunRSVPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewRunRSVPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewRunRSVPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          findFirst: {
            args: Prisma.RunCrewRunRSVPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewRunRSVPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          findMany: {
            args: Prisma.RunCrewRunRSVPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>[]
          }
          create: {
            args: Prisma.RunCrewRunRSVPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          createMany: {
            args: Prisma.RunCrewRunRSVPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewRunRSVPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>[]
          }
          delete: {
            args: Prisma.RunCrewRunRSVPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          update: {
            args: Prisma.RunCrewRunRSVPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewRunRSVPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewRunRSVPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewRunRSVPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewRunRSVPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewRunRSVPPayload>
          }
          aggregate: {
            args: Prisma.RunCrewRunRSVPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewRunRSVP>
          }
          groupBy: {
            args: Prisma.RunCrewRunRSVPGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewRunRSVPGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewRunRSVPCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewRunRSVPCountAggregateOutputType> | number
          }
        }
      }
      RunCrewEvent: {
        payload: Prisma.$RunCrewEventPayload<ExtArgs>
        fields: Prisma.RunCrewEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          findFirst: {
            args: Prisma.RunCrewEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          findMany: {
            args: Prisma.RunCrewEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>[]
          }
          create: {
            args: Prisma.RunCrewEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          createMany: {
            args: Prisma.RunCrewEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>[]
          }
          delete: {
            args: Prisma.RunCrewEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          update: {
            args: Prisma.RunCrewEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventPayload>
          }
          aggregate: {
            args: Prisma.RunCrewEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewEvent>
          }
          groupBy: {
            args: Prisma.RunCrewEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewEventCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewEventCountAggregateOutputType> | number
          }
        }
      }
      RunCrewEventRSVP: {
        payload: Prisma.$RunCrewEventRSVPPayload<ExtArgs>
        fields: Prisma.RunCrewEventRSVPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewEventRSVPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewEventRSVPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          findFirst: {
            args: Prisma.RunCrewEventRSVPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewEventRSVPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          findMany: {
            args: Prisma.RunCrewEventRSVPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>[]
          }
          create: {
            args: Prisma.RunCrewEventRSVPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          createMany: {
            args: Prisma.RunCrewEventRSVPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewEventRSVPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>[]
          }
          delete: {
            args: Prisma.RunCrewEventRSVPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          update: {
            args: Prisma.RunCrewEventRSVPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewEventRSVPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewEventRSVPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewEventRSVPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewEventRSVPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewEventRSVPPayload>
          }
          aggregate: {
            args: Prisma.RunCrewEventRSVPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewEventRSVP>
          }
          groupBy: {
            args: Prisma.RunCrewEventRSVPGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewEventRSVPGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewEventRSVPCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewEventRSVPCountAggregateOutputType> | number
          }
        }
      }
      RunCrewManager: {
        payload: Prisma.$RunCrewManagerPayload<ExtArgs>
        fields: Prisma.RunCrewManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCrewManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCrewManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          findFirst: {
            args: Prisma.RunCrewManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCrewManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          findMany: {
            args: Prisma.RunCrewManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>[]
          }
          create: {
            args: Prisma.RunCrewManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          createMany: {
            args: Prisma.RunCrewManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCrewManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>[]
          }
          delete: {
            args: Prisma.RunCrewManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          update: {
            args: Prisma.RunCrewManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          deleteMany: {
            args: Prisma.RunCrewManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCrewManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCrewManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>[]
          }
          upsert: {
            args: Prisma.RunCrewManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCrewManagerPayload>
          }
          aggregate: {
            args: Prisma.RunCrewManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCrewManager>
          }
          groupBy: {
            args: Prisma.RunCrewManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCrewManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCrewManagerCountArgs<ExtArgs>
            result: $Utils.Optional<RunCrewManagerCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      TrainingPlan: {
        payload: Prisma.$TrainingPlanPayload<ExtArgs>
        fields: Prisma.TrainingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          findFirst: {
            args: Prisma.TrainingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          findMany: {
            args: Prisma.TrainingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          create: {
            args: Prisma.TrainingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          createMany: {
            args: Prisma.TrainingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          delete: {
            args: Prisma.TrainingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          update: {
            args: Prisma.TrainingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanPayload>
          }
          aggregate: {
            args: Prisma.TrainingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPlan>
          }
          groupBy: {
            args: Prisma.TrainingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanCountAggregateOutputType> | number
          }
        }
      }
      TrainingDayPlanned: {
        payload: Prisma.$TrainingDayPlannedPayload<ExtArgs>
        fields: Prisma.TrainingDayPlannedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDayPlannedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          findFirst: {
            args: Prisma.TrainingDayPlannedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          findMany: {
            args: Prisma.TrainingDayPlannedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          create: {
            args: Prisma.TrainingDayPlannedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          createMany: {
            args: Prisma.TrainingDayPlannedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          delete: {
            args: Prisma.TrainingDayPlannedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          update: {
            args: Prisma.TrainingDayPlannedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDayPlannedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDayPlannedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDayPlannedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayPlannedPayload>
          }
          aggregate: {
            args: Prisma.TrainingDayPlannedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDayPlanned>
          }
          groupBy: {
            args: Prisma.TrainingDayPlannedGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayPlannedGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDayPlannedCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayPlannedCountAggregateOutputType> | number
          }
        }
      }
      TrainingPlanExecution: {
        payload: Prisma.$TrainingPlanExecutionPayload<ExtArgs>
        fields: Prisma.TrainingPlanExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPlanExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          findFirst: {
            args: Prisma.TrainingPlanExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          findMany: {
            args: Prisma.TrainingPlanExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          create: {
            args: Prisma.TrainingPlanExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          createMany: {
            args: Prisma.TrainingPlanExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          delete: {
            args: Prisma.TrainingPlanExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          update: {
            args: Prisma.TrainingPlanExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPlanExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPlanExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPlanExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPlanExecutionPayload>
          }
          aggregate: {
            args: Prisma.TrainingPlanExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPlanExecution>
          }
          groupBy: {
            args: Prisma.TrainingPlanExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPlanExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPlanExecutionCountAggregateOutputType> | number
          }
        }
      }
      TrainingDayExecuted: {
        payload: Prisma.$TrainingDayExecutedPayload<ExtArgs>
        fields: Prisma.TrainingDayExecutedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDayExecutedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          findFirst: {
            args: Prisma.TrainingDayExecutedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          findMany: {
            args: Prisma.TrainingDayExecutedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          create: {
            args: Prisma.TrainingDayExecutedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          createMany: {
            args: Prisma.TrainingDayExecutedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          delete: {
            args: Prisma.TrainingDayExecutedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          update: {
            args: Prisma.TrainingDayExecutedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDayExecutedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDayExecutedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDayExecutedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDayExecutedPayload>
          }
          aggregate: {
            args: Prisma.TrainingDayExecutedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDayExecuted>
          }
          groupBy: {
            args: Prisma.TrainingDayExecutedGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayExecutedGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDayExecutedCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDayExecutedCountAggregateOutputType> | number
          }
        }
      }
      Founder: {
        payload: Prisma.$FounderPayload<ExtArgs>
        fields: Prisma.FounderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FounderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FounderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          findFirst: {
            args: Prisma.FounderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FounderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          findMany: {
            args: Prisma.FounderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          create: {
            args: Prisma.FounderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          createMany: {
            args: Prisma.FounderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FounderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          delete: {
            args: Prisma.FounderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          update: {
            args: Prisma.FounderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          deleteMany: {
            args: Prisma.FounderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FounderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FounderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>[]
          }
          upsert: {
            args: Prisma.FounderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderPayload>
          }
          aggregate: {
            args: Prisma.FounderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFounder>
          }
          groupBy: {
            args: Prisma.FounderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FounderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FounderCountArgs<ExtArgs>
            result: $Utils.Optional<FounderCountAggregateOutputType> | number
          }
        }
      }
      FounderTask: {
        payload: Prisma.$FounderTaskPayload<ExtArgs>
        fields: Prisma.FounderTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FounderTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FounderTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          findFirst: {
            args: Prisma.FounderTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FounderTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          findMany: {
            args: Prisma.FounderTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          create: {
            args: Prisma.FounderTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          createMany: {
            args: Prisma.FounderTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FounderTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          delete: {
            args: Prisma.FounderTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          update: {
            args: Prisma.FounderTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          deleteMany: {
            args: Prisma.FounderTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FounderTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FounderTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>[]
          }
          upsert: {
            args: Prisma.FounderTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderTaskPayload>
          }
          aggregate: {
            args: Prisma.FounderTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFounderTask>
          }
          groupBy: {
            args: Prisma.FounderTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<FounderTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.FounderTaskCountArgs<ExtArgs>
            result: $Utils.Optional<FounderTaskCountAggregateOutputType> | number
          }
        }
      }
      CrmContact: {
        payload: Prisma.$CrmContactPayload<ExtArgs>
        fields: Prisma.CrmContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findFirst: {
            args: Prisma.CrmContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findMany: {
            args: Prisma.CrmContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          create: {
            args: Prisma.CrmContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          createMany: {
            args: Prisma.CrmContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          delete: {
            args: Prisma.CrmContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          update: {
            args: Prisma.CrmContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          deleteMany: {
            args: Prisma.CrmContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrmContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          upsert: {
            args: Prisma.CrmContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          aggregate: {
            args: Prisma.CrmContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmContact>
          }
          groupBy: {
            args: Prisma.CrmContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmContactCountArgs<ExtArgs>
            result: $Utils.Optional<CrmContactCountAggregateOutputType> | number
          }
        }
      }
      RoadmapItem: {
        payload: Prisma.$RoadmapItemPayload<ExtArgs>
        fields: Prisma.RoadmapItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findFirst: {
            args: Prisma.RoadmapItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findMany: {
            args: Prisma.RoadmapItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          create: {
            args: Prisma.RoadmapItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          createMany: {
            args: Prisma.RoadmapItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          delete: {
            args: Prisma.RoadmapItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          update: {
            args: Prisma.RoadmapItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          aggregate: {
            args: Prisma.RoadmapItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapItem>
          }
          groupBy: {
            args: Prisma.RoadmapItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapItemCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyFounder: {
        payload: Prisma.$CompanyFounderPayload<ExtArgs>
        fields: Prisma.CompanyFounderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFounderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFounderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          findFirst: {
            args: Prisma.CompanyFounderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFounderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          findMany: {
            args: Prisma.CompanyFounderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>[]
          }
          create: {
            args: Prisma.CompanyFounderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          createMany: {
            args: Prisma.CompanyFounderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyFounderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>[]
          }
          delete: {
            args: Prisma.CompanyFounderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          update: {
            args: Prisma.CompanyFounderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          deleteMany: {
            args: Prisma.CompanyFounderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyFounderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyFounderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>[]
          }
          upsert: {
            args: Prisma.CompanyFounderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFounderPayload>
          }
          aggregate: {
            args: Prisma.CompanyFounderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyFounder>
          }
          groupBy: {
            args: Prisma.CompanyFounderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyFounderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyFounderCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyFounderCountAggregateOutputType> | number
          }
        }
      }
      CompanyEmployee: {
        payload: Prisma.$CompanyEmployeePayload<ExtArgs>
        fields: Prisma.CompanyEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          findFirst: {
            args: Prisma.CompanyEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          findMany: {
            args: Prisma.CompanyEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>[]
          }
          create: {
            args: Prisma.CompanyEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          createMany: {
            args: Prisma.CompanyEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>[]
          }
          delete: {
            args: Prisma.CompanyEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          update: {
            args: Prisma.CompanyEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          deleteMany: {
            args: Prisma.CompanyEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>[]
          }
          upsert: {
            args: Prisma.CompanyEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          aggregate: {
            args: Prisma.CompanyEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyEmployee>
          }
          groupBy: {
            args: Prisma.CompanyEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyEmployeeCountAggregateOutputType> | number
          }
        }
      }
      CompanyRoadmapItem: {
        payload: Prisma.$CompanyRoadmapItemPayload<ExtArgs>
        fields: Prisma.CompanyRoadmapItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyRoadmapItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyRoadmapItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          findFirst: {
            args: Prisma.CompanyRoadmapItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyRoadmapItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          findMany: {
            args: Prisma.CompanyRoadmapItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>[]
          }
          create: {
            args: Prisma.CompanyRoadmapItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          createMany: {
            args: Prisma.CompanyRoadmapItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyRoadmapItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>[]
          }
          delete: {
            args: Prisma.CompanyRoadmapItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          update: {
            args: Prisma.CompanyRoadmapItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          deleteMany: {
            args: Prisma.CompanyRoadmapItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyRoadmapItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyRoadmapItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>[]
          }
          upsert: {
            args: Prisma.CompanyRoadmapItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRoadmapItemPayload>
          }
          aggregate: {
            args: Prisma.CompanyRoadmapItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyRoadmapItem>
          }
          groupBy: {
            args: Prisma.CompanyRoadmapItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyRoadmapItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyRoadmapItemCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyRoadmapItemCountAggregateOutputType> | number
          }
        }
      }
      CompanyCrmContact: {
        payload: Prisma.$CompanyCrmContactPayload<ExtArgs>
        fields: Prisma.CompanyCrmContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyCrmContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyCrmContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          findFirst: {
            args: Prisma.CompanyCrmContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyCrmContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          findMany: {
            args: Prisma.CompanyCrmContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>[]
          }
          create: {
            args: Prisma.CompanyCrmContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          createMany: {
            args: Prisma.CompanyCrmContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCrmContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>[]
          }
          delete: {
            args: Prisma.CompanyCrmContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          update: {
            args: Prisma.CompanyCrmContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          deleteMany: {
            args: Prisma.CompanyCrmContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyCrmContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyCrmContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>[]
          }
          upsert: {
            args: Prisma.CompanyCrmContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyCrmContactPayload>
          }
          aggregate: {
            args: Prisma.CompanyCrmContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyCrmContact>
          }
          groupBy: {
            args: Prisma.CompanyCrmContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyCrmContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCrmContactCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCrmContactCountAggregateOutputType> | number
          }
        }
      }
      CompanyFinancialSpend: {
        payload: Prisma.$CompanyFinancialSpendPayload<ExtArgs>
        fields: Prisma.CompanyFinancialSpendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFinancialSpendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFinancialSpendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          findFirst: {
            args: Prisma.CompanyFinancialSpendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFinancialSpendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          findMany: {
            args: Prisma.CompanyFinancialSpendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>[]
          }
          create: {
            args: Prisma.CompanyFinancialSpendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          createMany: {
            args: Prisma.CompanyFinancialSpendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyFinancialSpendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>[]
          }
          delete: {
            args: Prisma.CompanyFinancialSpendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          update: {
            args: Prisma.CompanyFinancialSpendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          deleteMany: {
            args: Prisma.CompanyFinancialSpendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyFinancialSpendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyFinancialSpendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>[]
          }
          upsert: {
            args: Prisma.CompanyFinancialSpendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialSpendPayload>
          }
          aggregate: {
            args: Prisma.CompanyFinancialSpendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyFinancialSpend>
          }
          groupBy: {
            args: Prisma.CompanyFinancialSpendGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinancialSpendGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyFinancialSpendCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinancialSpendCountAggregateOutputType> | number
          }
        }
      }
      CompanyFinancialProjection: {
        payload: Prisma.$CompanyFinancialProjectionPayload<ExtArgs>
        fields: Prisma.CompanyFinancialProjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFinancialProjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFinancialProjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          findFirst: {
            args: Prisma.CompanyFinancialProjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFinancialProjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          findMany: {
            args: Prisma.CompanyFinancialProjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>[]
          }
          create: {
            args: Prisma.CompanyFinancialProjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          createMany: {
            args: Prisma.CompanyFinancialProjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyFinancialProjectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>[]
          }
          delete: {
            args: Prisma.CompanyFinancialProjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          update: {
            args: Prisma.CompanyFinancialProjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          deleteMany: {
            args: Prisma.CompanyFinancialProjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyFinancialProjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyFinancialProjectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>[]
          }
          upsert: {
            args: Prisma.CompanyFinancialProjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFinancialProjectionPayload>
          }
          aggregate: {
            args: Prisma.CompanyFinancialProjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyFinancialProjection>
          }
          groupBy: {
            args: Prisma.CompanyFinancialProjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinancialProjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyFinancialProjectionCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinancialProjectionCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      GoFastCompany: {
        payload: Prisma.$GoFastCompanyPayload<ExtArgs>
        fields: Prisma.GoFastCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoFastCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoFastCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          findFirst: {
            args: Prisma.GoFastCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoFastCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          findMany: {
            args: Prisma.GoFastCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>[]
          }
          create: {
            args: Prisma.GoFastCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          createMany: {
            args: Prisma.GoFastCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoFastCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>[]
          }
          delete: {
            args: Prisma.GoFastCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          update: {
            args: Prisma.GoFastCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          deleteMany: {
            args: Prisma.GoFastCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoFastCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoFastCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>[]
          }
          upsert: {
            args: Prisma.GoFastCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoFastCompanyPayload>
          }
          aggregate: {
            args: Prisma.GoFastCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoFastCompany>
          }
          groupBy: {
            args: Prisma.GoFastCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoFastCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoFastCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<GoFastCompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyStaff: {
        payload: Prisma.$CompanyStaffPayload<ExtArgs>
        fields: Prisma.CompanyStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          findFirst: {
            args: Prisma.CompanyStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          findMany: {
            args: Prisma.CompanyStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>[]
          }
          create: {
            args: Prisma.CompanyStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          createMany: {
            args: Prisma.CompanyStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>[]
          }
          delete: {
            args: Prisma.CompanyStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          update: {
            args: Prisma.CompanyStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          deleteMany: {
            args: Prisma.CompanyStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>[]
          }
          upsert: {
            args: Prisma.CompanyStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStaffPayload>
          }
          aggregate: {
            args: Prisma.CompanyStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyStaff>
          }
          groupBy: {
            args: Prisma.CompanyStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyStaffCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyStaffCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      PipelineConfig: {
        payload: Prisma.$PipelineConfigPayload<ExtArgs>
        fields: Prisma.PipelineConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          findFirst: {
            args: Prisma.PipelineConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          findMany: {
            args: Prisma.PipelineConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>[]
          }
          create: {
            args: Prisma.PipelineConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          createMany: {
            args: Prisma.PipelineConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>[]
          }
          delete: {
            args: Prisma.PipelineConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          update: {
            args: Prisma.PipelineConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          deleteMany: {
            args: Prisma.PipelineConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelineConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>[]
          }
          upsert: {
            args: Prisma.PipelineConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineConfigPayload>
          }
          aggregate: {
            args: Prisma.PipelineConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelineConfig>
          }
          groupBy: {
            args: Prisma.PipelineConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineConfigCountAggregateOutputType> | number
          }
        }
      }
      ProductPipelineItem: {
        payload: Prisma.$ProductPipelineItemPayload<ExtArgs>
        fields: Prisma.ProductPipelineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPipelineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPipelineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          findFirst: {
            args: Prisma.ProductPipelineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPipelineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          findMany: {
            args: Prisma.ProductPipelineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>[]
          }
          create: {
            args: Prisma.ProductPipelineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          createMany: {
            args: Prisma.ProductPipelineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPipelineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>[]
          }
          delete: {
            args: Prisma.ProductPipelineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          update: {
            args: Prisma.ProductPipelineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          deleteMany: {
            args: Prisma.ProductPipelineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPipelineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductPipelineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>[]
          }
          upsert: {
            args: Prisma.ProductPipelineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPipelineItemPayload>
          }
          aggregate: {
            args: Prisma.ProductPipelineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPipelineItem>
          }
          groupBy: {
            args: Prisma.ProductPipelineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPipelineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPipelineItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPipelineItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    athlete?: AthleteOmit
    athleteActivity?: AthleteActivityOmit
    runCrew?: RunCrewOmit
    runCrewMembership?: RunCrewMembershipOmit
    runCrewMessage?: RunCrewMessageOmit
    runCrewAnnouncement?: RunCrewAnnouncementOmit
    runCrewLeaderboard?: RunCrewLeaderboardOmit
    runCrewRun?: RunCrewRunOmit
    runCrewRunRSVP?: RunCrewRunRSVPOmit
    runCrewEvent?: RunCrewEventOmit
    runCrewEventRSVP?: RunCrewEventRSVPOmit
    runCrewManager?: RunCrewManagerOmit
    race?: RaceOmit
    trainingPlan?: TrainingPlanOmit
    trainingDayPlanned?: TrainingDayPlannedOmit
    trainingPlanExecution?: TrainingPlanExecutionOmit
    trainingDayExecuted?: TrainingDayExecutedOmit
    founder?: FounderOmit
    founderTask?: FounderTaskOmit
    crmContact?: CrmContactOmit
    roadmapItem?: RoadmapItemOmit
    company?: CompanyOmit
    companyFounder?: CompanyFounderOmit
    companyEmployee?: CompanyEmployeeOmit
    companyRoadmapItem?: CompanyRoadmapItemOmit
    companyCrmContact?: CompanyCrmContactOmit
    companyFinancialSpend?: CompanyFinancialSpendOmit
    companyFinancialProjection?: CompanyFinancialProjectionOmit
    task?: TaskOmit
    message?: MessageOmit
    goFastCompany?: GoFastCompanyOmit
    companyStaff?: CompanyStaffOmit
    contact?: ContactOmit
    pipeline?: PipelineOmit
    pipelineConfig?: PipelineConfigOmit
    productPipelineItem?: ProductPipelineItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AthleteCountOutputType
   */

  export type AthleteCountOutputType = {
    activities: number
    adminRunCrews: number
    runCrewMemberships: number
    runCrewMessages: number
    runCrewAnnouncements: number
    runCrewLeaderboards: number
    runCrewRuns: number
    runCrewRunRSVPs: number
    runCrewEvents: number
    runCrewEventRSVPs: number
    runCrewManagers: number
    createdRaces: number
    trainingPlans: number
    plannedDays: number
    executedDays: number
  }

  export type AthleteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | AthleteCountOutputTypeCountActivitiesArgs
    adminRunCrews?: boolean | AthleteCountOutputTypeCountAdminRunCrewsArgs
    runCrewMemberships?: boolean | AthleteCountOutputTypeCountRunCrewMembershipsArgs
    runCrewMessages?: boolean | AthleteCountOutputTypeCountRunCrewMessagesArgs
    runCrewAnnouncements?: boolean | AthleteCountOutputTypeCountRunCrewAnnouncementsArgs
    runCrewLeaderboards?: boolean | AthleteCountOutputTypeCountRunCrewLeaderboardsArgs
    runCrewRuns?: boolean | AthleteCountOutputTypeCountRunCrewRunsArgs
    runCrewRunRSVPs?: boolean | AthleteCountOutputTypeCountRunCrewRunRSVPsArgs
    runCrewEvents?: boolean | AthleteCountOutputTypeCountRunCrewEventsArgs
    runCrewEventRSVPs?: boolean | AthleteCountOutputTypeCountRunCrewEventRSVPsArgs
    runCrewManagers?: boolean | AthleteCountOutputTypeCountRunCrewManagersArgs
    createdRaces?: boolean | AthleteCountOutputTypeCountCreatedRacesArgs
    trainingPlans?: boolean | AthleteCountOutputTypeCountTrainingPlansArgs
    plannedDays?: boolean | AthleteCountOutputTypeCountPlannedDaysArgs
    executedDays?: boolean | AthleteCountOutputTypeCountExecutedDaysArgs
  }

  // Custom InputTypes
  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteCountOutputType
     */
    select?: AthleteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteActivityWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountAdminRunCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMessageWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewAnnouncementWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewRunRSVPsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunRSVPWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewEventRSVPsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventRSVPWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountRunCrewManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewManagerWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountCreatedRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountTrainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountPlannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
  }

  /**
   * AthleteCountOutputType without action
   */
  export type AthleteCountOutputTypeCountExecutedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
  }


  /**
   * Count Type RunCrewCountOutputType
   */

  export type RunCrewCountOutputType = {
    memberships: number
    messages: number
    announcements: number
    leaderboardEntries: number
    runs: number
    events: number
    managers: number
  }

  export type RunCrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | RunCrewCountOutputTypeCountMembershipsArgs
    messages?: boolean | RunCrewCountOutputTypeCountMessagesArgs
    announcements?: boolean | RunCrewCountOutputTypeCountAnnouncementsArgs
    leaderboardEntries?: boolean | RunCrewCountOutputTypeCountLeaderboardEntriesArgs
    runs?: boolean | RunCrewCountOutputTypeCountRunsArgs
    events?: boolean | RunCrewCountOutputTypeCountEventsArgs
    managers?: boolean | RunCrewCountOutputTypeCountManagersArgs
  }

  // Custom InputTypes
  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewCountOutputType
     */
    select?: RunCrewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMessageWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewAnnouncementWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventWhereInput
  }

  /**
   * RunCrewCountOutputType without action
   */
  export type RunCrewCountOutputTypeCountManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewManagerWhereInput
  }


  /**
   * Count Type RunCrewRunCountOutputType
   */

  export type RunCrewRunCountOutputType = {
    rsvps: number
  }

  export type RunCrewRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rsvps?: boolean | RunCrewRunCountOutputTypeCountRsvpsArgs
  }

  // Custom InputTypes
  /**
   * RunCrewRunCountOutputType without action
   */
  export type RunCrewRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunCountOutputType
     */
    select?: RunCrewRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCrewRunCountOutputType without action
   */
  export type RunCrewRunCountOutputTypeCountRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunRSVPWhereInput
  }


  /**
   * Count Type RunCrewEventCountOutputType
   */

  export type RunCrewEventCountOutputType = {
    rsvps: number
  }

  export type RunCrewEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rsvps?: boolean | RunCrewEventCountOutputTypeCountRsvpsArgs
  }

  // Custom InputTypes
  /**
   * RunCrewEventCountOutputType without action
   */
  export type RunCrewEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventCountOutputType
     */
    select?: RunCrewEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCrewEventCountOutputType without action
   */
  export type RunCrewEventCountOutputTypeCountRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventRSVPWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    trainingPlans: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlans?: boolean | RaceCountOutputTypeCountTrainingPlansArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountTrainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
  }


  /**
   * Count Type TrainingPlanCountOutputType
   */

  export type TrainingPlanCountOutputType = {
    plannedDays: number
    executions: number
  }

  export type TrainingPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannedDays?: boolean | TrainingPlanCountOutputTypeCountPlannedDaysArgs
    executions?: boolean | TrainingPlanCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanCountOutputType
     */
    select?: TrainingPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeCountPlannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
  }

  /**
   * TrainingPlanCountOutputType without action
   */
  export type TrainingPlanCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanExecutionWhereInput
  }


  /**
   * Count Type TrainingPlanExecutionCountOutputType
   */

  export type TrainingPlanExecutionCountOutputType = {
    executedDays: number
  }

  export type TrainingPlanExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executedDays?: boolean | TrainingPlanExecutionCountOutputTypeCountExecutedDaysArgs
  }

  // Custom InputTypes
  /**
   * TrainingPlanExecutionCountOutputType without action
   */
  export type TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecutionCountOutputType
     */
    select?: TrainingPlanExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingPlanExecutionCountOutputType without action
   */
  export type TrainingPlanExecutionCountOutputTypeCountExecutedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
  }


  /**
   * Count Type FounderCountOutputType
   */

  export type FounderCountOutputType = {
    tasks: number
    crmContacts: number
    roadmapItems: number
    companyFounders: number
    unifiedTasks: number
  }

  export type FounderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | FounderCountOutputTypeCountTasksArgs
    crmContacts?: boolean | FounderCountOutputTypeCountCrmContactsArgs
    roadmapItems?: boolean | FounderCountOutputTypeCountRoadmapItemsArgs
    companyFounders?: boolean | FounderCountOutputTypeCountCompanyFoundersArgs
    unifiedTasks?: boolean | FounderCountOutputTypeCountUnifiedTasksArgs
  }

  // Custom InputTypes
  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderCountOutputType
     */
    select?: FounderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderTaskWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountCrmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmContactWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountRoadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountCompanyFoundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFounderWhereInput
  }

  /**
   * FounderCountOutputType without action
   */
  export type FounderCountOutputTypeCountUnifiedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    founders: number
    employees: number
    roadmapItems: number
    tasks: number
    crmContacts: number
    financialSpends: number
    financialProjections: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founders?: boolean | CompanyCountOutputTypeCountFoundersArgs
    employees?: boolean | CompanyCountOutputTypeCountEmployeesArgs
    roadmapItems?: boolean | CompanyCountOutputTypeCountRoadmapItemsArgs
    tasks?: boolean | CompanyCountOutputTypeCountTasksArgs
    crmContacts?: boolean | CompanyCountOutputTypeCountCrmContactsArgs
    financialSpends?: boolean | CompanyCountOutputTypeCountFinancialSpendsArgs
    financialProjections?: boolean | CompanyCountOutputTypeCountFinancialProjectionsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFoundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFounderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEmployeeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRoadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRoadmapItemWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCrmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyCrmContactWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFinancialSpendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialSpendWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFinancialProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialProjectionWhereInput
  }


  /**
   * Count Type GoFastCompanyCountOutputType
   */

  export type GoFastCompanyCountOutputType = {
    staff: number
    contacts: number
    pipelines: number
    pipelineConfigs: number
    productPipelineItems: number
    financialSpends: number
    financialProjections: number
    roadmapItems: number
    tasks: number
  }

  export type GoFastCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | GoFastCompanyCountOutputTypeCountStaffArgs
    contacts?: boolean | GoFastCompanyCountOutputTypeCountContactsArgs
    pipelines?: boolean | GoFastCompanyCountOutputTypeCountPipelinesArgs
    pipelineConfigs?: boolean | GoFastCompanyCountOutputTypeCountPipelineConfigsArgs
    productPipelineItems?: boolean | GoFastCompanyCountOutputTypeCountProductPipelineItemsArgs
    financialSpends?: boolean | GoFastCompanyCountOutputTypeCountFinancialSpendsArgs
    financialProjections?: boolean | GoFastCompanyCountOutputTypeCountFinancialProjectionsArgs
    roadmapItems?: boolean | GoFastCompanyCountOutputTypeCountRoadmapItemsArgs
    tasks?: boolean | GoFastCompanyCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompanyCountOutputType
     */
    select?: GoFastCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyStaffWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountPipelineConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineConfigWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountProductPipelineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPipelineItemWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountFinancialSpendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialSpendWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountFinancialProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialProjectionWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountRoadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRoadmapItemWhereInput
  }

  /**
   * GoFastCompanyCountOutputType without action
   */
  export type GoFastCompanyCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    pipelines: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipelines?: boolean | ContactCountOutputTypeCountPipelinesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }


  /**
   * Count Type PipelineConfigCountOutputType
   */

  export type PipelineConfigCountOutputType = {
    pipelines: number
  }

  export type PipelineConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipelines?: boolean | PipelineConfigCountOutputTypeCountPipelinesArgs
  }

  // Custom InputTypes
  /**
   * PipelineConfigCountOutputType without action
   */
  export type PipelineConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfigCountOutputType
     */
    select?: PipelineConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineConfigCountOutputType without action
   */
  export type PipelineConfigCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Athlete
   */

  export type AggregateAthlete = {
    _count: AthleteCountAggregateOutputType | null
    _avg: AthleteAvgAggregateOutputType | null
    _sum: AthleteSumAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  export type AthleteAvgAggregateOutputType = {
    weeklyMileage: number | null
    garmin_expires_in: number | null
    strava_id: number | null
    strava_expires_at: number | null
  }

  export type AthleteSumAggregateOutputType = {
    weeklyMileage: number | null
    garmin_expires_in: number | null
    strava_id: number | null
    strava_expires_at: number | null
  }

  export type AthleteMinAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_is_connected: boolean | null
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AthleteMaxAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_is_connected: boolean | null
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type AthleteCountAggregateOutputType = {
    id: number
    firebaseId: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    gofastHandle: number
    birthday: number
    gender: number
    city: number
    state: number
    primarySport: number
    photoURL: number
    bio: number
    instagram: number
    currentPace: number
    weeklyMileage: number
    trainingGoal: number
    targetRace: number
    trainingStartDate: number
    preferredDistance: number
    timePreference: number
    paceRange: number
    runningGoals: number
    garmin_user_id: number
    garmin_access_token: number
    garmin_refresh_token: number
    garmin_expires_in: number
    garmin_scope: number
    garmin_connected_at: number
    garmin_last_sync_at: number
    garmin_permissions: number
    garmin_is_connected: number
    garmin_disconnected_at: number
    strava_id: number
    strava_access_token: number
    strava_refresh_token: number
    strava_expires_at: number
    garmin_user_profile: number
    garmin_user_sleep: number
    garmin_user_preferences: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AthleteAvgAggregateInputType = {
    weeklyMileage?: true
    garmin_expires_in?: true
    strava_id?: true
    strava_expires_at?: true
  }

  export type AthleteSumAggregateInputType = {
    weeklyMileage?: true
    garmin_expires_in?: true
    strava_id?: true
    strava_expires_at?: true
  }

  export type AthleteMinAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AthleteMaxAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AthleteCountAggregateInputType = {
    id?: true
    firebaseId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    gofastHandle?: true
    birthday?: true
    gender?: true
    city?: true
    state?: true
    primarySport?: true
    photoURL?: true
    bio?: true
    instagram?: true
    currentPace?: true
    weeklyMileage?: true
    trainingGoal?: true
    targetRace?: true
    trainingStartDate?: true
    preferredDistance?: true
    timePreference?: true
    paceRange?: true
    runningGoals?: true
    garmin_user_id?: true
    garmin_access_token?: true
    garmin_refresh_token?: true
    garmin_expires_in?: true
    garmin_scope?: true
    garmin_connected_at?: true
    garmin_last_sync_at?: true
    garmin_permissions?: true
    garmin_is_connected?: true
    garmin_disconnected_at?: true
    strava_id?: true
    strava_access_token?: true
    strava_refresh_token?: true
    strava_expires_at?: true
    garmin_user_profile?: true
    garmin_user_sleep?: true
    garmin_user_preferences?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AthleteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athlete to aggregate.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Athletes
    **/
    _count?: true | AthleteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteMaxAggregateInputType
  }

  export type GetAthleteAggregateType<T extends AthleteAggregateArgs> = {
        [P in keyof T & keyof AggregateAthlete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthlete[P]>
      : GetScalarType<T[P], AggregateAthlete[P]>
  }




  export type AthleteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteWhereInput
    orderBy?: AthleteOrderByWithAggregationInput | AthleteOrderByWithAggregationInput[]
    by: AthleteScalarFieldEnum[] | AthleteScalarFieldEnum
    having?: AthleteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteCountAggregateInputType | true
    _avg?: AthleteAvgAggregateInputType
    _sum?: AthleteSumAggregateInputType
    _min?: AthleteMinAggregateInputType
    _max?: AthleteMaxAggregateInputType
  }

  export type AthleteGroupByOutputType = {
    id: string
    firebaseId: string
    firstName: string | null
    lastName: string | null
    email: string
    phoneNumber: string | null
    gofastHandle: string | null
    birthday: Date | null
    gender: string | null
    city: string | null
    state: string | null
    primarySport: string | null
    photoURL: string | null
    bio: string | null
    instagram: string | null
    currentPace: string | null
    weeklyMileage: number | null
    trainingGoal: string | null
    targetRace: string | null
    trainingStartDate: Date | null
    preferredDistance: string | null
    timePreference: string | null
    paceRange: string | null
    runningGoals: string | null
    garmin_user_id: string | null
    garmin_access_token: string | null
    garmin_refresh_token: string | null
    garmin_expires_in: number | null
    garmin_scope: string | null
    garmin_connected_at: Date | null
    garmin_last_sync_at: Date | null
    garmin_permissions: JsonValue | null
    garmin_is_connected: boolean
    garmin_disconnected_at: Date | null
    strava_id: number | null
    strava_access_token: string | null
    strava_refresh_token: string | null
    strava_expires_at: number | null
    garmin_user_profile: JsonValue | null
    garmin_user_sleep: JsonValue | null
    garmin_user_preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    status: string | null
    _count: AthleteCountAggregateOutputType | null
    _avg: AthleteAvgAggregateOutputType | null
    _sum: AthleteSumAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  type GetAthleteGroupByPayload<T extends AthleteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteGroupByOutputType[P]>
        }
      >
    >


  export type AthleteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    activities?: boolean | Athlete$activitiesArgs<ExtArgs>
    adminRunCrews?: boolean | Athlete$adminRunCrewsArgs<ExtArgs>
    runCrewMemberships?: boolean | Athlete$runCrewMembershipsArgs<ExtArgs>
    runCrewMessages?: boolean | Athlete$runCrewMessagesArgs<ExtArgs>
    runCrewAnnouncements?: boolean | Athlete$runCrewAnnouncementsArgs<ExtArgs>
    runCrewLeaderboards?: boolean | Athlete$runCrewLeaderboardsArgs<ExtArgs>
    runCrewRuns?: boolean | Athlete$runCrewRunsArgs<ExtArgs>
    runCrewRunRSVPs?: boolean | Athlete$runCrewRunRSVPsArgs<ExtArgs>
    runCrewEvents?: boolean | Athlete$runCrewEventsArgs<ExtArgs>
    runCrewEventRSVPs?: boolean | Athlete$runCrewEventRSVPsArgs<ExtArgs>
    runCrewManagers?: boolean | Athlete$runCrewManagersArgs<ExtArgs>
    createdRaces?: boolean | Athlete$createdRacesArgs<ExtArgs>
    trainingPlans?: boolean | Athlete$trainingPlansArgs<ExtArgs>
    plannedDays?: boolean | Athlete$plannedDaysArgs<ExtArgs>
    executedDays?: boolean | Athlete$executedDaysArgs<ExtArgs>
    founder?: boolean | Athlete$founderArgs<ExtArgs>
    _count?: boolean | AthleteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectScalar = {
    id?: boolean
    firebaseId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    gofastHandle?: boolean
    birthday?: boolean
    gender?: boolean
    city?: boolean
    state?: boolean
    primarySport?: boolean
    photoURL?: boolean
    bio?: boolean
    instagram?: boolean
    currentPace?: boolean
    weeklyMileage?: boolean
    trainingGoal?: boolean
    targetRace?: boolean
    trainingStartDate?: boolean
    preferredDistance?: boolean
    timePreference?: boolean
    paceRange?: boolean
    runningGoals?: boolean
    garmin_user_id?: boolean
    garmin_access_token?: boolean
    garmin_refresh_token?: boolean
    garmin_expires_in?: boolean
    garmin_scope?: boolean
    garmin_connected_at?: boolean
    garmin_last_sync_at?: boolean
    garmin_permissions?: boolean
    garmin_is_connected?: boolean
    garmin_disconnected_at?: boolean
    strava_id?: boolean
    strava_access_token?: boolean
    strava_refresh_token?: boolean
    strava_expires_at?: boolean
    garmin_user_profile?: boolean
    garmin_user_sleep?: boolean
    garmin_user_preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type AthleteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firebaseId" | "firstName" | "lastName" | "email" | "phoneNumber" | "gofastHandle" | "birthday" | "gender" | "city" | "state" | "primarySport" | "photoURL" | "bio" | "instagram" | "currentPace" | "weeklyMileage" | "trainingGoal" | "targetRace" | "trainingStartDate" | "preferredDistance" | "timePreference" | "paceRange" | "runningGoals" | "garmin_user_id" | "garmin_access_token" | "garmin_refresh_token" | "garmin_expires_in" | "garmin_scope" | "garmin_connected_at" | "garmin_last_sync_at" | "garmin_permissions" | "garmin_is_connected" | "garmin_disconnected_at" | "strava_id" | "strava_access_token" | "strava_refresh_token" | "strava_expires_at" | "garmin_user_profile" | "garmin_user_sleep" | "garmin_user_preferences" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["athlete"]>
  export type AthleteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Athlete$activitiesArgs<ExtArgs>
    adminRunCrews?: boolean | Athlete$adminRunCrewsArgs<ExtArgs>
    runCrewMemberships?: boolean | Athlete$runCrewMembershipsArgs<ExtArgs>
    runCrewMessages?: boolean | Athlete$runCrewMessagesArgs<ExtArgs>
    runCrewAnnouncements?: boolean | Athlete$runCrewAnnouncementsArgs<ExtArgs>
    runCrewLeaderboards?: boolean | Athlete$runCrewLeaderboardsArgs<ExtArgs>
    runCrewRuns?: boolean | Athlete$runCrewRunsArgs<ExtArgs>
    runCrewRunRSVPs?: boolean | Athlete$runCrewRunRSVPsArgs<ExtArgs>
    runCrewEvents?: boolean | Athlete$runCrewEventsArgs<ExtArgs>
    runCrewEventRSVPs?: boolean | Athlete$runCrewEventRSVPsArgs<ExtArgs>
    runCrewManagers?: boolean | Athlete$runCrewManagersArgs<ExtArgs>
    createdRaces?: boolean | Athlete$createdRacesArgs<ExtArgs>
    trainingPlans?: boolean | Athlete$trainingPlansArgs<ExtArgs>
    plannedDays?: boolean | Athlete$plannedDaysArgs<ExtArgs>
    executedDays?: boolean | Athlete$executedDaysArgs<ExtArgs>
    founder?: boolean | Athlete$founderArgs<ExtArgs>
    _count?: boolean | AthleteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AthleteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AthleteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AthletePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Athlete"
    objects: {
      activities: Prisma.$AthleteActivityPayload<ExtArgs>[]
      adminRunCrews: Prisma.$RunCrewPayload<ExtArgs>[]
      runCrewMemberships: Prisma.$RunCrewMembershipPayload<ExtArgs>[]
      runCrewMessages: Prisma.$RunCrewMessagePayload<ExtArgs>[]
      runCrewAnnouncements: Prisma.$RunCrewAnnouncementPayload<ExtArgs>[]
      runCrewLeaderboards: Prisma.$RunCrewLeaderboardPayload<ExtArgs>[]
      runCrewRuns: Prisma.$RunCrewRunPayload<ExtArgs>[]
      runCrewRunRSVPs: Prisma.$RunCrewRunRSVPPayload<ExtArgs>[]
      runCrewEvents: Prisma.$RunCrewEventPayload<ExtArgs>[]
      runCrewEventRSVPs: Prisma.$RunCrewEventRSVPPayload<ExtArgs>[]
      runCrewManagers: Prisma.$RunCrewManagerPayload<ExtArgs>[]
      createdRaces: Prisma.$RacePayload<ExtArgs>[]
      trainingPlans: Prisma.$TrainingPlanPayload<ExtArgs>[]
      plannedDays: Prisma.$TrainingDayPlannedPayload<ExtArgs>[]
      executedDays: Prisma.$TrainingDayExecutedPayload<ExtArgs>[]
      founder: Prisma.$FounderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firebaseId: string
      firstName: string | null
      lastName: string | null
      email: string
      phoneNumber: string | null
      gofastHandle: string | null
      birthday: Date | null
      gender: string | null
      city: string | null
      state: string | null
      primarySport: string | null
      photoURL: string | null
      bio: string | null
      instagram: string | null
      currentPace: string | null
      weeklyMileage: number | null
      trainingGoal: string | null
      targetRace: string | null
      trainingStartDate: Date | null
      preferredDistance: string | null
      timePreference: string | null
      paceRange: string | null
      runningGoals: string | null
      garmin_user_id: string | null
      garmin_access_token: string | null
      garmin_refresh_token: string | null
      garmin_expires_in: number | null
      garmin_scope: string | null
      garmin_connected_at: Date | null
      garmin_last_sync_at: Date | null
      garmin_permissions: Prisma.JsonValue | null
      garmin_is_connected: boolean
      garmin_disconnected_at: Date | null
      strava_id: number | null
      strava_access_token: string | null
      strava_refresh_token: string | null
      strava_expires_at: number | null
      garmin_user_profile: Prisma.JsonValue | null
      garmin_user_sleep: Prisma.JsonValue | null
      garmin_user_preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      status: string | null
    }, ExtArgs["result"]["athlete"]>
    composites: {}
  }

  type AthleteGetPayload<S extends boolean | null | undefined | AthleteDefaultArgs> = $Result.GetResult<Prisma.$AthletePayload, S>

  type AthleteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AthleteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AthleteCountAggregateInputType | true
    }

  export interface AthleteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Athlete'], meta: { name: 'Athlete' } }
    /**
     * Find zero or one Athlete that matches the filter.
     * @param {AthleteFindUniqueArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AthleteFindUniqueArgs>(args: SelectSubset<T, AthleteFindUniqueArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Athlete that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AthleteFindUniqueOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AthleteFindUniqueOrThrowArgs>(args: SelectSubset<T, AthleteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Athlete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AthleteFindFirstArgs>(args?: SelectSubset<T, AthleteFindFirstArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Athlete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AthleteFindFirstOrThrowArgs>(args?: SelectSubset<T, AthleteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Athletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Athletes
     * const athletes = await prisma.athlete.findMany()
     * 
     * // Get first 10 Athletes
     * const athletes = await prisma.athlete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteWithIdOnly = await prisma.athlete.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AthleteFindManyArgs>(args?: SelectSubset<T, AthleteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Athlete.
     * @param {AthleteCreateArgs} args - Arguments to create a Athlete.
     * @example
     * // Create one Athlete
     * const Athlete = await prisma.athlete.create({
     *   data: {
     *     // ... data to create a Athlete
     *   }
     * })
     * 
     */
    create<T extends AthleteCreateArgs>(args: SelectSubset<T, AthleteCreateArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Athletes.
     * @param {AthleteCreateManyArgs} args - Arguments to create many Athletes.
     * @example
     * // Create many Athletes
     * const athlete = await prisma.athlete.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AthleteCreateManyArgs>(args?: SelectSubset<T, AthleteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Athletes and returns the data saved in the database.
     * @param {AthleteCreateManyAndReturnArgs} args - Arguments to create many Athletes.
     * @example
     * // Create many Athletes
     * const athlete = await prisma.athlete.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Athletes and only return the `id`
     * const athleteWithIdOnly = await prisma.athlete.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AthleteCreateManyAndReturnArgs>(args?: SelectSubset<T, AthleteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Athlete.
     * @param {AthleteDeleteArgs} args - Arguments to delete one Athlete.
     * @example
     * // Delete one Athlete
     * const Athlete = await prisma.athlete.delete({
     *   where: {
     *     // ... filter to delete one Athlete
     *   }
     * })
     * 
     */
    delete<T extends AthleteDeleteArgs>(args: SelectSubset<T, AthleteDeleteArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Athlete.
     * @param {AthleteUpdateArgs} args - Arguments to update one Athlete.
     * @example
     * // Update one Athlete
     * const athlete = await prisma.athlete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AthleteUpdateArgs>(args: SelectSubset<T, AthleteUpdateArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Athletes.
     * @param {AthleteDeleteManyArgs} args - Arguments to filter Athletes to delete.
     * @example
     * // Delete a few Athletes
     * const { count } = await prisma.athlete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AthleteDeleteManyArgs>(args?: SelectSubset<T, AthleteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Athletes
     * const athlete = await prisma.athlete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AthleteUpdateManyArgs>(args: SelectSubset<T, AthleteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Athletes and returns the data updated in the database.
     * @param {AthleteUpdateManyAndReturnArgs} args - Arguments to update many Athletes.
     * @example
     * // Update many Athletes
     * const athlete = await prisma.athlete.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Athletes and only return the `id`
     * const athleteWithIdOnly = await prisma.athlete.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AthleteUpdateManyAndReturnArgs>(args: SelectSubset<T, AthleteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Athlete.
     * @param {AthleteUpsertArgs} args - Arguments to update or create a Athlete.
     * @example
     * // Update or create a Athlete
     * const athlete = await prisma.athlete.upsert({
     *   create: {
     *     // ... data to create a Athlete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Athlete we want to update
     *   }
     * })
     */
    upsert<T extends AthleteUpsertArgs>(args: SelectSubset<T, AthleteUpsertArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCountArgs} args - Arguments to filter Athletes to count.
     * @example
     * // Count the number of Athletes
     * const count = await prisma.athlete.count({
     *   where: {
     *     // ... the filter for the Athletes we want to count
     *   }
     * })
    **/
    count<T extends AthleteCountArgs>(
      args?: Subset<T, AthleteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteAggregateArgs>(args: Subset<T, AthleteAggregateArgs>): Prisma.PrismaPromise<GetAthleteAggregateType<T>>

    /**
     * Group by Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteGroupByArgs['orderBy'] }
        : { orderBy?: AthleteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Athlete model
   */
  readonly fields: AthleteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Athlete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Athlete$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminRunCrews<T extends Athlete$adminRunCrewsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$adminRunCrewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewMemberships<T extends Athlete$runCrewMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewMessages<T extends Athlete$runCrewMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewAnnouncements<T extends Athlete$runCrewAnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewAnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewLeaderboards<T extends Athlete$runCrewLeaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewLeaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewRuns<T extends Athlete$runCrewRunsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewRunRSVPs<T extends Athlete$runCrewRunRSVPsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewRunRSVPsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewEvents<T extends Athlete$runCrewEventsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewEventRSVPs<T extends Athlete$runCrewEventRSVPsArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewEventRSVPsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runCrewManagers<T extends Athlete$runCrewManagersArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$runCrewManagersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRaces<T extends Athlete$createdRacesArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$createdRacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingPlans<T extends Athlete$trainingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$trainingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannedDays<T extends Athlete$plannedDaysArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$plannedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executedDays<T extends Athlete$executedDaysArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$executedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    founder<T extends Athlete$founderArgs<ExtArgs> = {}>(args?: Subset<T, Athlete$founderArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Athlete model
   */
  interface AthleteFieldRefs {
    readonly id: FieldRef<"Athlete", 'String'>
    readonly firebaseId: FieldRef<"Athlete", 'String'>
    readonly firstName: FieldRef<"Athlete", 'String'>
    readonly lastName: FieldRef<"Athlete", 'String'>
    readonly email: FieldRef<"Athlete", 'String'>
    readonly phoneNumber: FieldRef<"Athlete", 'String'>
    readonly gofastHandle: FieldRef<"Athlete", 'String'>
    readonly birthday: FieldRef<"Athlete", 'DateTime'>
    readonly gender: FieldRef<"Athlete", 'String'>
    readonly city: FieldRef<"Athlete", 'String'>
    readonly state: FieldRef<"Athlete", 'String'>
    readonly primarySport: FieldRef<"Athlete", 'String'>
    readonly photoURL: FieldRef<"Athlete", 'String'>
    readonly bio: FieldRef<"Athlete", 'String'>
    readonly instagram: FieldRef<"Athlete", 'String'>
    readonly currentPace: FieldRef<"Athlete", 'String'>
    readonly weeklyMileage: FieldRef<"Athlete", 'Int'>
    readonly trainingGoal: FieldRef<"Athlete", 'String'>
    readonly targetRace: FieldRef<"Athlete", 'String'>
    readonly trainingStartDate: FieldRef<"Athlete", 'DateTime'>
    readonly preferredDistance: FieldRef<"Athlete", 'String'>
    readonly timePreference: FieldRef<"Athlete", 'String'>
    readonly paceRange: FieldRef<"Athlete", 'String'>
    readonly runningGoals: FieldRef<"Athlete", 'String'>
    readonly garmin_user_id: FieldRef<"Athlete", 'String'>
    readonly garmin_access_token: FieldRef<"Athlete", 'String'>
    readonly garmin_refresh_token: FieldRef<"Athlete", 'String'>
    readonly garmin_expires_in: FieldRef<"Athlete", 'Int'>
    readonly garmin_scope: FieldRef<"Athlete", 'String'>
    readonly garmin_connected_at: FieldRef<"Athlete", 'DateTime'>
    readonly garmin_last_sync_at: FieldRef<"Athlete", 'DateTime'>
    readonly garmin_permissions: FieldRef<"Athlete", 'Json'>
    readonly garmin_is_connected: FieldRef<"Athlete", 'Boolean'>
    readonly garmin_disconnected_at: FieldRef<"Athlete", 'DateTime'>
    readonly strava_id: FieldRef<"Athlete", 'Int'>
    readonly strava_access_token: FieldRef<"Athlete", 'String'>
    readonly strava_refresh_token: FieldRef<"Athlete", 'String'>
    readonly strava_expires_at: FieldRef<"Athlete", 'Int'>
    readonly garmin_user_profile: FieldRef<"Athlete", 'Json'>
    readonly garmin_user_sleep: FieldRef<"Athlete", 'Json'>
    readonly garmin_user_preferences: FieldRef<"Athlete", 'Json'>
    readonly createdAt: FieldRef<"Athlete", 'DateTime'>
    readonly updatedAt: FieldRef<"Athlete", 'DateTime'>
    readonly status: FieldRef<"Athlete", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Athlete findUnique
   */
  export type AthleteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete findUniqueOrThrow
   */
  export type AthleteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete findFirst
   */
  export type AthleteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete findFirstOrThrow
   */
  export type AthleteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete findMany
   */
  export type AthleteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter, which Athletes to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }

  /**
   * Athlete create
   */
  export type AthleteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The data needed to create a Athlete.
     */
    data: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
  }

  /**
   * Athlete createMany
   */
  export type AthleteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Athletes.
     */
    data: AthleteCreateManyInput | AthleteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Athlete createManyAndReturn
   */
  export type AthleteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * The data used to create many Athletes.
     */
    data: AthleteCreateManyInput | AthleteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Athlete update
   */
  export type AthleteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The data needed to update a Athlete.
     */
    data: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
    /**
     * Choose, which Athlete to update.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete updateMany
   */
  export type AthleteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Athletes.
     */
    data: XOR<AthleteUpdateManyMutationInput, AthleteUncheckedUpdateManyInput>
    /**
     * Filter which Athletes to update
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to update.
     */
    limit?: number
  }

  /**
   * Athlete updateManyAndReturn
   */
  export type AthleteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * The data used to update Athletes.
     */
    data: XOR<AthleteUpdateManyMutationInput, AthleteUncheckedUpdateManyInput>
    /**
     * Filter which Athletes to update
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to update.
     */
    limit?: number
  }

  /**
   * Athlete upsert
   */
  export type AthleteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * The filter to search for the Athlete to update in case it exists.
     */
    where: AthleteWhereUniqueInput
    /**
     * In case the Athlete found by the `where` argument doesn't exist, create a new Athlete with this data.
     */
    create: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
    /**
     * In case the Athlete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
  }

  /**
   * Athlete delete
   */
  export type AthleteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    /**
     * Filter which Athlete to delete.
     */
    where: AthleteWhereUniqueInput
  }

  /**
   * Athlete deleteMany
   */
  export type AthleteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athletes to delete
     */
    where?: AthleteWhereInput
    /**
     * Limit how many Athletes to delete.
     */
    limit?: number
  }

  /**
   * Athlete.activities
   */
  export type Athlete$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    where?: AthleteActivityWhereInput
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    cursor?: AthleteActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * Athlete.adminRunCrews
   */
  export type Athlete$adminRunCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    where?: RunCrewWhereInput
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    cursor?: RunCrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewMemberships
   */
  export type Athlete$runCrewMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    cursor?: RunCrewMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewMessages
   */
  export type Athlete$runCrewMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    where?: RunCrewMessageWhereInput
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    cursor?: RunCrewMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMessageScalarFieldEnum | RunCrewMessageScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewAnnouncements
   */
  export type Athlete$runCrewAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    where?: RunCrewAnnouncementWhereInput
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    cursor?: RunCrewAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewAnnouncementScalarFieldEnum | RunCrewAnnouncementScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewLeaderboards
   */
  export type Athlete$runCrewLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    cursor?: RunCrewLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewRuns
   */
  export type Athlete$runCrewRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    where?: RunCrewRunWhereInput
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    cursor?: RunCrewRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewRunScalarFieldEnum | RunCrewRunScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewRunRSVPs
   */
  export type Athlete$runCrewRunRSVPsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    where?: RunCrewRunRSVPWhereInput
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    cursor?: RunCrewRunRSVPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewRunRSVPScalarFieldEnum | RunCrewRunRSVPScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewEvents
   */
  export type Athlete$runCrewEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    where?: RunCrewEventWhereInput
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    cursor?: RunCrewEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewEventScalarFieldEnum | RunCrewEventScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewEventRSVPs
   */
  export type Athlete$runCrewEventRSVPsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    where?: RunCrewEventRSVPWhereInput
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    cursor?: RunCrewEventRSVPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewEventRSVPScalarFieldEnum | RunCrewEventRSVPScalarFieldEnum[]
  }

  /**
   * Athlete.runCrewManagers
   */
  export type Athlete$runCrewManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    where?: RunCrewManagerWhereInput
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    cursor?: RunCrewManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewManagerScalarFieldEnum | RunCrewManagerScalarFieldEnum[]
  }

  /**
   * Athlete.createdRaces
   */
  export type Athlete$createdRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    cursor?: RaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Athlete.trainingPlans
   */
  export type Athlete$trainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    cursor?: TrainingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * Athlete.plannedDays
   */
  export type Athlete$plannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    cursor?: TrainingDayPlannedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * Athlete.executedDays
   */
  export type Athlete$executedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    cursor?: TrainingDayExecutedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * Athlete.founder
   */
  export type Athlete$founderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    where?: FounderWhereInput
  }

  /**
   * Athlete without action
   */
  export type AthleteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
  }


  /**
   * Model AthleteActivity
   */

  export type AggregateAthleteActivity = {
    _count: AthleteActivityCountAggregateOutputType | null
    _avg: AthleteActivityAvgAggregateOutputType | null
    _sum: AthleteActivitySumAggregateOutputType | null
    _min: AthleteActivityMinAggregateOutputType | null
    _max: AthleteActivityMaxAggregateOutputType | null
  }

  export type AthleteActivityAvgAggregateOutputType = {
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type AthleteActivitySumAggregateOutputType = {
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type AthleteActivityMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    sourceActivityId: string | null
    source: string | null
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    hydratedAt: Date | null
    syncedAt: Date | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteActivityMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    sourceActivityId: string | null
    source: string | null
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    hydratedAt: Date | null
    syncedAt: Date | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteActivityCountAggregateOutputType = {
    id: number
    athleteId: number
    sourceActivityId: number
    source: number
    activityType: number
    activityName: number
    startTime: number
    duration: number
    distance: number
    averageSpeed: number
    calories: number
    averageHeartRate: number
    maxHeartRate: number
    elevationGain: number
    steps: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    summaryPolyline: number
    deviceName: number
    garminUserId: number
    summaryData: number
    detailData: number
    hydratedAt: number
    syncedAt: number
    lastUpdatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AthleteActivityAvgAggregateInputType = {
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type AthleteActivitySumAggregateInputType = {
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type AthleteActivityMinAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteActivityMaxAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteActivityCountAggregateInputType = {
    id?: true
    athleteId?: true
    sourceActivityId?: true
    source?: true
    activityType?: true
    activityName?: true
    startTime?: true
    duration?: true
    distance?: true
    averageSpeed?: true
    calories?: true
    averageHeartRate?: true
    maxHeartRate?: true
    elevationGain?: true
    steps?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    summaryPolyline?: true
    deviceName?: true
    garminUserId?: true
    summaryData?: true
    detailData?: true
    hydratedAt?: true
    syncedAt?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AthleteActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleteActivity to aggregate.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AthleteActivities
    **/
    _count?: true | AthleteActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleteActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleteActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteActivityMaxAggregateInputType
  }

  export type GetAthleteActivityAggregateType<T extends AthleteActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateAthleteActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthleteActivity[P]>
      : GetScalarType<T[P], AggregateAthleteActivity[P]>
  }




  export type AthleteActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleteActivityWhereInput
    orderBy?: AthleteActivityOrderByWithAggregationInput | AthleteActivityOrderByWithAggregationInput[]
    by: AthleteActivityScalarFieldEnum[] | AthleteActivityScalarFieldEnum
    having?: AthleteActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteActivityCountAggregateInputType | true
    _avg?: AthleteActivityAvgAggregateInputType
    _sum?: AthleteActivitySumAggregateInputType
    _min?: AthleteActivityMinAggregateInputType
    _max?: AthleteActivityMaxAggregateInputType
  }

  export type AthleteActivityGroupByOutputType = {
    id: string
    athleteId: string
    sourceActivityId: string
    source: string
    activityType: string | null
    activityName: string | null
    startTime: Date | null
    duration: number | null
    distance: number | null
    averageSpeed: number | null
    calories: number | null
    averageHeartRate: number | null
    maxHeartRate: number | null
    elevationGain: number | null
    steps: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    summaryPolyline: string | null
    deviceName: string | null
    garminUserId: string | null
    summaryData: JsonValue | null
    detailData: JsonValue | null
    hydratedAt: Date | null
    syncedAt: Date
    lastUpdatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AthleteActivityCountAggregateOutputType | null
    _avg: AthleteActivityAvgAggregateOutputType | null
    _sum: AthleteActivitySumAggregateOutputType | null
    _min: AthleteActivityMinAggregateOutputType | null
    _max: AthleteActivityMaxAggregateOutputType | null
  }

  type GetAthleteActivityGroupByPayload<T extends AthleteActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleteActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteActivityGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteActivityGroupByOutputType[P]>
        }
      >
    >


  export type AthleteActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleteActivity"]>

  export type AthleteActivitySelectScalar = {
    id?: boolean
    athleteId?: boolean
    sourceActivityId?: boolean
    source?: boolean
    activityType?: boolean
    activityName?: boolean
    startTime?: boolean
    duration?: boolean
    distance?: boolean
    averageSpeed?: boolean
    calories?: boolean
    averageHeartRate?: boolean
    maxHeartRate?: boolean
    elevationGain?: boolean
    steps?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    summaryPolyline?: boolean
    deviceName?: boolean
    garminUserId?: boolean
    summaryData?: boolean
    detailData?: boolean
    hydratedAt?: boolean
    syncedAt?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AthleteActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "sourceActivityId" | "source" | "activityType" | "activityName" | "startTime" | "duration" | "distance" | "averageSpeed" | "calories" | "averageHeartRate" | "maxHeartRate" | "elevationGain" | "steps" | "startLatitude" | "startLongitude" | "endLatitude" | "endLongitude" | "summaryPolyline" | "deviceName" | "garminUserId" | "summaryData" | "detailData" | "hydratedAt" | "syncedAt" | "lastUpdatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["athleteActivity"]>
  export type AthleteActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type AthleteActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type AthleteActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $AthleteActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AthleteActivity"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      sourceActivityId: string
      source: string
      activityType: string | null
      activityName: string | null
      startTime: Date | null
      duration: number | null
      distance: number | null
      averageSpeed: number | null
      calories: number | null
      averageHeartRate: number | null
      maxHeartRate: number | null
      elevationGain: number | null
      steps: number | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      summaryPolyline: string | null
      deviceName: string | null
      garminUserId: string | null
      summaryData: Prisma.JsonValue | null
      detailData: Prisma.JsonValue | null
      hydratedAt: Date | null
      syncedAt: Date
      lastUpdatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["athleteActivity"]>
    composites: {}
  }

  type AthleteActivityGetPayload<S extends boolean | null | undefined | AthleteActivityDefaultArgs> = $Result.GetResult<Prisma.$AthleteActivityPayload, S>

  type AthleteActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AthleteActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AthleteActivityCountAggregateInputType | true
    }

  export interface AthleteActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AthleteActivity'], meta: { name: 'AthleteActivity' } }
    /**
     * Find zero or one AthleteActivity that matches the filter.
     * @param {AthleteActivityFindUniqueArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AthleteActivityFindUniqueArgs>(args: SelectSubset<T, AthleteActivityFindUniqueArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AthleteActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AthleteActivityFindUniqueOrThrowArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AthleteActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, AthleteActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AthleteActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindFirstArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AthleteActivityFindFirstArgs>(args?: SelectSubset<T, AthleteActivityFindFirstArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AthleteActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindFirstOrThrowArgs} args - Arguments to find a AthleteActivity
     * @example
     * // Get one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AthleteActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, AthleteActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AthleteActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AthleteActivities
     * const athleteActivities = await prisma.athleteActivity.findMany()
     * 
     * // Get first 10 AthleteActivities
     * const athleteActivities = await prisma.athleteActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AthleteActivityFindManyArgs>(args?: SelectSubset<T, AthleteActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AthleteActivity.
     * @param {AthleteActivityCreateArgs} args - Arguments to create a AthleteActivity.
     * @example
     * // Create one AthleteActivity
     * const AthleteActivity = await prisma.athleteActivity.create({
     *   data: {
     *     // ... data to create a AthleteActivity
     *   }
     * })
     * 
     */
    create<T extends AthleteActivityCreateArgs>(args: SelectSubset<T, AthleteActivityCreateArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AthleteActivities.
     * @param {AthleteActivityCreateManyArgs} args - Arguments to create many AthleteActivities.
     * @example
     * // Create many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AthleteActivityCreateManyArgs>(args?: SelectSubset<T, AthleteActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AthleteActivities and returns the data saved in the database.
     * @param {AthleteActivityCreateManyAndReturnArgs} args - Arguments to create many AthleteActivities.
     * @example
     * // Create many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AthleteActivities and only return the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AthleteActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, AthleteActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AthleteActivity.
     * @param {AthleteActivityDeleteArgs} args - Arguments to delete one AthleteActivity.
     * @example
     * // Delete one AthleteActivity
     * const AthleteActivity = await prisma.athleteActivity.delete({
     *   where: {
     *     // ... filter to delete one AthleteActivity
     *   }
     * })
     * 
     */
    delete<T extends AthleteActivityDeleteArgs>(args: SelectSubset<T, AthleteActivityDeleteArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AthleteActivity.
     * @param {AthleteActivityUpdateArgs} args - Arguments to update one AthleteActivity.
     * @example
     * // Update one AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AthleteActivityUpdateArgs>(args: SelectSubset<T, AthleteActivityUpdateArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AthleteActivities.
     * @param {AthleteActivityDeleteManyArgs} args - Arguments to filter AthleteActivities to delete.
     * @example
     * // Delete a few AthleteActivities
     * const { count } = await prisma.athleteActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AthleteActivityDeleteManyArgs>(args?: SelectSubset<T, AthleteActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleteActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AthleteActivityUpdateManyArgs>(args: SelectSubset<T, AthleteActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleteActivities and returns the data updated in the database.
     * @param {AthleteActivityUpdateManyAndReturnArgs} args - Arguments to update many AthleteActivities.
     * @example
     * // Update many AthleteActivities
     * const athleteActivity = await prisma.athleteActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AthleteActivities and only return the `id`
     * const athleteActivityWithIdOnly = await prisma.athleteActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AthleteActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, AthleteActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AthleteActivity.
     * @param {AthleteActivityUpsertArgs} args - Arguments to update or create a AthleteActivity.
     * @example
     * // Update or create a AthleteActivity
     * const athleteActivity = await prisma.athleteActivity.upsert({
     *   create: {
     *     // ... data to create a AthleteActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AthleteActivity we want to update
     *   }
     * })
     */
    upsert<T extends AthleteActivityUpsertArgs>(args: SelectSubset<T, AthleteActivityUpsertArgs<ExtArgs>>): Prisma__AthleteActivityClient<$Result.GetResult<Prisma.$AthleteActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AthleteActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityCountArgs} args - Arguments to filter AthleteActivities to count.
     * @example
     * // Count the number of AthleteActivities
     * const count = await prisma.athleteActivity.count({
     *   where: {
     *     // ... the filter for the AthleteActivities we want to count
     *   }
     * })
    **/
    count<T extends AthleteActivityCountArgs>(
      args?: Subset<T, AthleteActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AthleteActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteActivityAggregateArgs>(args: Subset<T, AthleteActivityAggregateArgs>): Prisma.PrismaPromise<GetAthleteActivityAggregateType<T>>

    /**
     * Group by AthleteActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteActivityGroupByArgs['orderBy'] }
        : { orderBy?: AthleteActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AthleteActivity model
   */
  readonly fields: AthleteActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AthleteActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleteActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AthleteActivity model
   */
  interface AthleteActivityFieldRefs {
    readonly id: FieldRef<"AthleteActivity", 'String'>
    readonly athleteId: FieldRef<"AthleteActivity", 'String'>
    readonly sourceActivityId: FieldRef<"AthleteActivity", 'String'>
    readonly source: FieldRef<"AthleteActivity", 'String'>
    readonly activityType: FieldRef<"AthleteActivity", 'String'>
    readonly activityName: FieldRef<"AthleteActivity", 'String'>
    readonly startTime: FieldRef<"AthleteActivity", 'DateTime'>
    readonly duration: FieldRef<"AthleteActivity", 'Int'>
    readonly distance: FieldRef<"AthleteActivity", 'Float'>
    readonly averageSpeed: FieldRef<"AthleteActivity", 'Float'>
    readonly calories: FieldRef<"AthleteActivity", 'Int'>
    readonly averageHeartRate: FieldRef<"AthleteActivity", 'Int'>
    readonly maxHeartRate: FieldRef<"AthleteActivity", 'Int'>
    readonly elevationGain: FieldRef<"AthleteActivity", 'Float'>
    readonly steps: FieldRef<"AthleteActivity", 'Int'>
    readonly startLatitude: FieldRef<"AthleteActivity", 'Float'>
    readonly startLongitude: FieldRef<"AthleteActivity", 'Float'>
    readonly endLatitude: FieldRef<"AthleteActivity", 'Float'>
    readonly endLongitude: FieldRef<"AthleteActivity", 'Float'>
    readonly summaryPolyline: FieldRef<"AthleteActivity", 'String'>
    readonly deviceName: FieldRef<"AthleteActivity", 'String'>
    readonly garminUserId: FieldRef<"AthleteActivity", 'String'>
    readonly summaryData: FieldRef<"AthleteActivity", 'Json'>
    readonly detailData: FieldRef<"AthleteActivity", 'Json'>
    readonly hydratedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly syncedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly lastUpdatedAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly createdAt: FieldRef<"AthleteActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"AthleteActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AthleteActivity findUnique
   */
  export type AthleteActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity findUniqueOrThrow
   */
  export type AthleteActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity findFirst
   */
  export type AthleteActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleteActivities.
     */
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity findFirstOrThrow
   */
  export type AthleteActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivity to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleteActivities.
     */
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity findMany
   */
  export type AthleteActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter, which AthleteActivities to fetch.
     */
    where?: AthleteActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteActivities to fetch.
     */
    orderBy?: AthleteActivityOrderByWithRelationInput | AthleteActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AthleteActivities.
     */
    cursor?: AthleteActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteActivities.
     */
    skip?: number
    distinct?: AthleteActivityScalarFieldEnum | AthleteActivityScalarFieldEnum[]
  }

  /**
   * AthleteActivity create
   */
  export type AthleteActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a AthleteActivity.
     */
    data: XOR<AthleteActivityCreateInput, AthleteActivityUncheckedCreateInput>
  }

  /**
   * AthleteActivity createMany
   */
  export type AthleteActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AthleteActivities.
     */
    data: AthleteActivityCreateManyInput | AthleteActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AthleteActivity createManyAndReturn
   */
  export type AthleteActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * The data used to create many AthleteActivities.
     */
    data: AthleteActivityCreateManyInput | AthleteActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleteActivity update
   */
  export type AthleteActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a AthleteActivity.
     */
    data: XOR<AthleteActivityUpdateInput, AthleteActivityUncheckedUpdateInput>
    /**
     * Choose, which AthleteActivity to update.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity updateMany
   */
  export type AthleteActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AthleteActivities.
     */
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyInput>
    /**
     * Filter which AthleteActivities to update
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to update.
     */
    limit?: number
  }

  /**
   * AthleteActivity updateManyAndReturn
   */
  export type AthleteActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * The data used to update AthleteActivities.
     */
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyInput>
    /**
     * Filter which AthleteActivities to update
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleteActivity upsert
   */
  export type AthleteActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the AthleteActivity to update in case it exists.
     */
    where: AthleteActivityWhereUniqueInput
    /**
     * In case the AthleteActivity found by the `where` argument doesn't exist, create a new AthleteActivity with this data.
     */
    create: XOR<AthleteActivityCreateInput, AthleteActivityUncheckedCreateInput>
    /**
     * In case the AthleteActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleteActivityUpdateInput, AthleteActivityUncheckedUpdateInput>
  }

  /**
   * AthleteActivity delete
   */
  export type AthleteActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
    /**
     * Filter which AthleteActivity to delete.
     */
    where: AthleteActivityWhereUniqueInput
  }

  /**
   * AthleteActivity deleteMany
   */
  export type AthleteActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleteActivities to delete
     */
    where?: AthleteActivityWhereInput
    /**
     * Limit how many AthleteActivities to delete.
     */
    limit?: number
  }

  /**
   * AthleteActivity without action
   */
  export type AthleteActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleteActivity
     */
    select?: AthleteActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleteActivity
     */
    omit?: AthleteActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteActivityInclude<ExtArgs> | null
  }


  /**
   * Model RunCrew
   */

  export type AggregateRunCrew = {
    _count: RunCrewCountAggregateOutputType | null
    _min: RunCrewMinAggregateOutputType | null
    _max: RunCrewMaxAggregateOutputType | null
  }

  export type RunCrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    joinCode: string | null
    logo: string | null
    icon: string | null
    runcrewAdminId: string | null
    isArchived: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    joinCode: string | null
    logo: string | null
    icon: string | null
    runcrewAdminId: string | null
    isArchived: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewCountAggregateOutputType = {
    id: number
    name: number
    description: number
    joinCode: number
    logo: number
    icon: number
    runcrewAdminId: number
    isArchived: number
    archivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    icon?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    icon?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    joinCode?: true
    logo?: true
    icon?: true
    runcrewAdminId?: true
    isArchived?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrew to aggregate.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrews
    **/
    _count?: true | RunCrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewMaxAggregateInputType
  }

  export type GetRunCrewAggregateType<T extends RunCrewAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrew[P]>
      : GetScalarType<T[P], AggregateRunCrew[P]>
  }




  export type RunCrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewWhereInput
    orderBy?: RunCrewOrderByWithAggregationInput | RunCrewOrderByWithAggregationInput[]
    by: RunCrewScalarFieldEnum[] | RunCrewScalarFieldEnum
    having?: RunCrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewCountAggregateInputType | true
    _min?: RunCrewMinAggregateInputType
    _max?: RunCrewMaxAggregateInputType
  }

  export type RunCrewGroupByOutputType = {
    id: string
    name: string
    description: string | null
    joinCode: string
    logo: string | null
    icon: string | null
    runcrewAdminId: string | null
    isArchived: boolean
    archivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RunCrewCountAggregateOutputType | null
    _min: RunCrewMinAggregateOutputType | null
    _max: RunCrewMaxAggregateOutputType | null
  }

  type GetRunCrewGroupByPayload<T extends RunCrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    icon?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
    memberships?: boolean | RunCrew$membershipsArgs<ExtArgs>
    messages?: boolean | RunCrew$messagesArgs<ExtArgs>
    announcements?: boolean | RunCrew$announcementsArgs<ExtArgs>
    leaderboardEntries?: boolean | RunCrew$leaderboardEntriesArgs<ExtArgs>
    runs?: boolean | RunCrew$runsArgs<ExtArgs>
    events?: boolean | RunCrew$eventsArgs<ExtArgs>
    managers?: boolean | RunCrew$managersArgs<ExtArgs>
    _count?: boolean | RunCrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    icon?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    icon?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
  }, ExtArgs["result"]["runCrew"]>

  export type RunCrewSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    joinCode?: boolean
    logo?: boolean
    icon?: boolean
    runcrewAdminId?: boolean
    isArchived?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "joinCode" | "logo" | "icon" | "runcrewAdminId" | "isArchived" | "archivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrew"]>
  export type RunCrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
    memberships?: boolean | RunCrew$membershipsArgs<ExtArgs>
    messages?: boolean | RunCrew$messagesArgs<ExtArgs>
    announcements?: boolean | RunCrew$announcementsArgs<ExtArgs>
    leaderboardEntries?: boolean | RunCrew$leaderboardEntriesArgs<ExtArgs>
    runs?: boolean | RunCrew$runsArgs<ExtArgs>
    events?: boolean | RunCrew$eventsArgs<ExtArgs>
    managers?: boolean | RunCrew$managersArgs<ExtArgs>
    _count?: boolean | RunCrewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunCrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
  }
  export type RunCrewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | RunCrew$adminArgs<ExtArgs>
  }

  export type $RunCrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrew"
    objects: {
      admin: Prisma.$AthletePayload<ExtArgs> | null
      memberships: Prisma.$RunCrewMembershipPayload<ExtArgs>[]
      messages: Prisma.$RunCrewMessagePayload<ExtArgs>[]
      announcements: Prisma.$RunCrewAnnouncementPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$RunCrewLeaderboardPayload<ExtArgs>[]
      runs: Prisma.$RunCrewRunPayload<ExtArgs>[]
      events: Prisma.$RunCrewEventPayload<ExtArgs>[]
      managers: Prisma.$RunCrewManagerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      joinCode: string
      logo: string | null
      icon: string | null
      runcrewAdminId: string | null
      isArchived: boolean
      archivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrew"]>
    composites: {}
  }

  type RunCrewGetPayload<S extends boolean | null | undefined | RunCrewDefaultArgs> = $Result.GetResult<Prisma.$RunCrewPayload, S>

  type RunCrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewCountAggregateInputType | true
    }

  export interface RunCrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrew'], meta: { name: 'RunCrew' } }
    /**
     * Find zero or one RunCrew that matches the filter.
     * @param {RunCrewFindUniqueArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewFindUniqueArgs>(args: SelectSubset<T, RunCrewFindUniqueArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrew that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewFindUniqueOrThrowArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindFirstArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewFindFirstArgs>(args?: SelectSubset<T, RunCrewFindFirstArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindFirstOrThrowArgs} args - Arguments to find a RunCrew
     * @example
     * // Get one RunCrew
     * const runCrew = await prisma.runCrew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrews
     * const runCrews = await prisma.runCrew.findMany()
     * 
     * // Get first 10 RunCrews
     * const runCrews = await prisma.runCrew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewFindManyArgs>(args?: SelectSubset<T, RunCrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrew.
     * @param {RunCrewCreateArgs} args - Arguments to create a RunCrew.
     * @example
     * // Create one RunCrew
     * const RunCrew = await prisma.runCrew.create({
     *   data: {
     *     // ... data to create a RunCrew
     *   }
     * })
     * 
     */
    create<T extends RunCrewCreateArgs>(args: SelectSubset<T, RunCrewCreateArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrews.
     * @param {RunCrewCreateManyArgs} args - Arguments to create many RunCrews.
     * @example
     * // Create many RunCrews
     * const runCrew = await prisma.runCrew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewCreateManyArgs>(args?: SelectSubset<T, RunCrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrews and returns the data saved in the database.
     * @param {RunCrewCreateManyAndReturnArgs} args - Arguments to create many RunCrews.
     * @example
     * // Create many RunCrews
     * const runCrew = await prisma.runCrew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrews and only return the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrew.
     * @param {RunCrewDeleteArgs} args - Arguments to delete one RunCrew.
     * @example
     * // Delete one RunCrew
     * const RunCrew = await prisma.runCrew.delete({
     *   where: {
     *     // ... filter to delete one RunCrew
     *   }
     * })
     * 
     */
    delete<T extends RunCrewDeleteArgs>(args: SelectSubset<T, RunCrewDeleteArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrew.
     * @param {RunCrewUpdateArgs} args - Arguments to update one RunCrew.
     * @example
     * // Update one RunCrew
     * const runCrew = await prisma.runCrew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewUpdateArgs>(args: SelectSubset<T, RunCrewUpdateArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrews.
     * @param {RunCrewDeleteManyArgs} args - Arguments to filter RunCrews to delete.
     * @example
     * // Delete a few RunCrews
     * const { count } = await prisma.runCrew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewDeleteManyArgs>(args?: SelectSubset<T, RunCrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrews
     * const runCrew = await prisma.runCrew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewUpdateManyArgs>(args: SelectSubset<T, RunCrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrews and returns the data updated in the database.
     * @param {RunCrewUpdateManyAndReturnArgs} args - Arguments to update many RunCrews.
     * @example
     * // Update many RunCrews
     * const runCrew = await prisma.runCrew.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrews and only return the `id`
     * const runCrewWithIdOnly = await prisma.runCrew.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrew.
     * @param {RunCrewUpsertArgs} args - Arguments to update or create a RunCrew.
     * @example
     * // Update or create a RunCrew
     * const runCrew = await prisma.runCrew.upsert({
     *   create: {
     *     // ... data to create a RunCrew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrew we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewUpsertArgs>(args: SelectSubset<T, RunCrewUpsertArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewCountArgs} args - Arguments to filter RunCrews to count.
     * @example
     * // Count the number of RunCrews
     * const count = await prisma.runCrew.count({
     *   where: {
     *     // ... the filter for the RunCrews we want to count
     *   }
     * })
    **/
    count<T extends RunCrewCountArgs>(
      args?: Subset<T, RunCrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewAggregateArgs>(args: Subset<T, RunCrewAggregateArgs>): Prisma.PrismaPromise<GetRunCrewAggregateType<T>>

    /**
     * Group by RunCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrew model
   */
  readonly fields: RunCrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends RunCrew$adminArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$adminArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    memberships<T extends RunCrew$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends RunCrew$messagesArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends RunCrew$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboardEntries<T extends RunCrew$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runs<T extends RunCrew$runsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends RunCrew$eventsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managers<T extends RunCrew$managersArgs<ExtArgs> = {}>(args?: Subset<T, RunCrew$managersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrew model
   */
  interface RunCrewFieldRefs {
    readonly id: FieldRef<"RunCrew", 'String'>
    readonly name: FieldRef<"RunCrew", 'String'>
    readonly description: FieldRef<"RunCrew", 'String'>
    readonly joinCode: FieldRef<"RunCrew", 'String'>
    readonly logo: FieldRef<"RunCrew", 'String'>
    readonly icon: FieldRef<"RunCrew", 'String'>
    readonly runcrewAdminId: FieldRef<"RunCrew", 'String'>
    readonly isArchived: FieldRef<"RunCrew", 'Boolean'>
    readonly archivedAt: FieldRef<"RunCrew", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrew", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrew", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrew findUnique
   */
  export type RunCrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew findUniqueOrThrow
   */
  export type RunCrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew findFirst
   */
  export type RunCrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrews.
     */
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew findFirstOrThrow
   */
  export type RunCrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrew to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrews.
     */
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew findMany
   */
  export type RunCrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter, which RunCrews to fetch.
     */
    where?: RunCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrews to fetch.
     */
    orderBy?: RunCrewOrderByWithRelationInput | RunCrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrews.
     */
    cursor?: RunCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrews.
     */
    skip?: number
    distinct?: RunCrewScalarFieldEnum | RunCrewScalarFieldEnum[]
  }

  /**
   * RunCrew create
   */
  export type RunCrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrew.
     */
    data: XOR<RunCrewCreateInput, RunCrewUncheckedCreateInput>
  }

  /**
   * RunCrew createMany
   */
  export type RunCrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrews.
     */
    data: RunCrewCreateManyInput | RunCrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrew createManyAndReturn
   */
  export type RunCrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrews.
     */
    data: RunCrewCreateManyInput | RunCrewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrew update
   */
  export type RunCrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrew.
     */
    data: XOR<RunCrewUpdateInput, RunCrewUncheckedUpdateInput>
    /**
     * Choose, which RunCrew to update.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew updateMany
   */
  export type RunCrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrews.
     */
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyInput>
    /**
     * Filter which RunCrews to update
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to update.
     */
    limit?: number
  }

  /**
   * RunCrew updateManyAndReturn
   */
  export type RunCrewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * The data used to update RunCrews.
     */
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyInput>
    /**
     * Filter which RunCrews to update
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrew upsert
   */
  export type RunCrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrew to update in case it exists.
     */
    where: RunCrewWhereUniqueInput
    /**
     * In case the RunCrew found by the `where` argument doesn't exist, create a new RunCrew with this data.
     */
    create: XOR<RunCrewCreateInput, RunCrewUncheckedCreateInput>
    /**
     * In case the RunCrew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewUpdateInput, RunCrewUncheckedUpdateInput>
  }

  /**
   * RunCrew delete
   */
  export type RunCrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
    /**
     * Filter which RunCrew to delete.
     */
    where: RunCrewWhereUniqueInput
  }

  /**
   * RunCrew deleteMany
   */
  export type RunCrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrews to delete
     */
    where?: RunCrewWhereInput
    /**
     * Limit how many RunCrews to delete.
     */
    limit?: number
  }

  /**
   * RunCrew.admin
   */
  export type RunCrew$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    where?: AthleteWhereInput
  }

  /**
   * RunCrew.memberships
   */
  export type RunCrew$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    cursor?: RunCrewMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrew.messages
   */
  export type RunCrew$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    where?: RunCrewMessageWhereInput
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    cursor?: RunCrewMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewMessageScalarFieldEnum | RunCrewMessageScalarFieldEnum[]
  }

  /**
   * RunCrew.announcements
   */
  export type RunCrew$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    where?: RunCrewAnnouncementWhereInput
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    cursor?: RunCrewAnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewAnnouncementScalarFieldEnum | RunCrewAnnouncementScalarFieldEnum[]
  }

  /**
   * RunCrew.leaderboardEntries
   */
  export type RunCrew$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    cursor?: RunCrewLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrew.runs
   */
  export type RunCrew$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    where?: RunCrewRunWhereInput
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    cursor?: RunCrewRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewRunScalarFieldEnum | RunCrewRunScalarFieldEnum[]
  }

  /**
   * RunCrew.events
   */
  export type RunCrew$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    where?: RunCrewEventWhereInput
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    cursor?: RunCrewEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewEventScalarFieldEnum | RunCrewEventScalarFieldEnum[]
  }

  /**
   * RunCrew.managers
   */
  export type RunCrew$managersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    where?: RunCrewManagerWhereInput
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    cursor?: RunCrewManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewManagerScalarFieldEnum | RunCrewManagerScalarFieldEnum[]
  }

  /**
   * RunCrew without action
   */
  export type RunCrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrew
     */
    select?: RunCrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrew
     */
    omit?: RunCrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewMembership
   */

  export type AggregateRunCrewMembership = {
    _count: RunCrewMembershipCountAggregateOutputType | null
    _min: RunCrewMembershipMinAggregateOutputType | null
    _max: RunCrewMembershipMaxAggregateOutputType | null
  }

  export type RunCrewMembershipMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMembershipMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewMembershipCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewMembershipMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMembershipMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewMembershipCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMembership to aggregate.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewMemberships
    **/
    _count?: true | RunCrewMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewMembershipMaxAggregateInputType
  }

  export type GetRunCrewMembershipAggregateType<T extends RunCrewMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewMembership[P]>
      : GetScalarType<T[P], AggregateRunCrewMembership[P]>
  }




  export type RunCrewMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMembershipWhereInput
    orderBy?: RunCrewMembershipOrderByWithAggregationInput | RunCrewMembershipOrderByWithAggregationInput[]
    by: RunCrewMembershipScalarFieldEnum[] | RunCrewMembershipScalarFieldEnum
    having?: RunCrewMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewMembershipCountAggregateInputType | true
    _min?: RunCrewMembershipMinAggregateInputType
    _max?: RunCrewMembershipMaxAggregateInputType
  }

  export type RunCrewMembershipGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    joinedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RunCrewMembershipCountAggregateOutputType | null
    _min: RunCrewMembershipMinAggregateOutputType | null
    _max: RunCrewMembershipMaxAggregateOutputType | null
  }

  type GetRunCrewMembershipGroupByPayload<T extends RunCrewMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewMembershipGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMembership"]>

  export type RunCrewMembershipSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "joinedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewMembership"]>
  export type RunCrewMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewMembership"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      joinedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewMembership"]>
    composites: {}
  }

  type RunCrewMembershipGetPayload<S extends boolean | null | undefined | RunCrewMembershipDefaultArgs> = $Result.GetResult<Prisma.$RunCrewMembershipPayload, S>

  type RunCrewMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewMembershipCountAggregateInputType | true
    }

  export interface RunCrewMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewMembership'], meta: { name: 'RunCrewMembership' } }
    /**
     * Find zero or one RunCrewMembership that matches the filter.
     * @param {RunCrewMembershipFindUniqueArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewMembershipFindUniqueArgs>(args: SelectSubset<T, RunCrewMembershipFindUniqueArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewMembershipFindUniqueOrThrowArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindFirstArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewMembershipFindFirstArgs>(args?: SelectSubset<T, RunCrewMembershipFindFirstArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindFirstOrThrowArgs} args - Arguments to find a RunCrewMembership
     * @example
     * // Get one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewMemberships
     * const runCrewMemberships = await prisma.runCrewMembership.findMany()
     * 
     * // Get first 10 RunCrewMemberships
     * const runCrewMemberships = await prisma.runCrewMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewMembershipFindManyArgs>(args?: SelectSubset<T, RunCrewMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewMembership.
     * @param {RunCrewMembershipCreateArgs} args - Arguments to create a RunCrewMembership.
     * @example
     * // Create one RunCrewMembership
     * const RunCrewMembership = await prisma.runCrewMembership.create({
     *   data: {
     *     // ... data to create a RunCrewMembership
     *   }
     * })
     * 
     */
    create<T extends RunCrewMembershipCreateArgs>(args: SelectSubset<T, RunCrewMembershipCreateArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewMemberships.
     * @param {RunCrewMembershipCreateManyArgs} args - Arguments to create many RunCrewMemberships.
     * @example
     * // Create many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewMembershipCreateManyArgs>(args?: SelectSubset<T, RunCrewMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewMemberships and returns the data saved in the database.
     * @param {RunCrewMembershipCreateManyAndReturnArgs} args - Arguments to create many RunCrewMemberships.
     * @example
     * // Create many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewMemberships and only return the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewMembership.
     * @param {RunCrewMembershipDeleteArgs} args - Arguments to delete one RunCrewMembership.
     * @example
     * // Delete one RunCrewMembership
     * const RunCrewMembership = await prisma.runCrewMembership.delete({
     *   where: {
     *     // ... filter to delete one RunCrewMembership
     *   }
     * })
     * 
     */
    delete<T extends RunCrewMembershipDeleteArgs>(args: SelectSubset<T, RunCrewMembershipDeleteArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewMembership.
     * @param {RunCrewMembershipUpdateArgs} args - Arguments to update one RunCrewMembership.
     * @example
     * // Update one RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewMembershipUpdateArgs>(args: SelectSubset<T, RunCrewMembershipUpdateArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewMemberships.
     * @param {RunCrewMembershipDeleteManyArgs} args - Arguments to filter RunCrewMemberships to delete.
     * @example
     * // Delete a few RunCrewMemberships
     * const { count } = await prisma.runCrewMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewMembershipDeleteManyArgs>(args?: SelectSubset<T, RunCrewMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewMembershipUpdateManyArgs>(args: SelectSubset<T, RunCrewMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMemberships and returns the data updated in the database.
     * @param {RunCrewMembershipUpdateManyAndReturnArgs} args - Arguments to update many RunCrewMemberships.
     * @example
     * // Update many RunCrewMemberships
     * const runCrewMembership = await prisma.runCrewMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewMemberships and only return the `id`
     * const runCrewMembershipWithIdOnly = await prisma.runCrewMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewMembership.
     * @param {RunCrewMembershipUpsertArgs} args - Arguments to update or create a RunCrewMembership.
     * @example
     * // Update or create a RunCrewMembership
     * const runCrewMembership = await prisma.runCrewMembership.upsert({
     *   create: {
     *     // ... data to create a RunCrewMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewMembership we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewMembershipUpsertArgs>(args: SelectSubset<T, RunCrewMembershipUpsertArgs<ExtArgs>>): Prisma__RunCrewMembershipClient<$Result.GetResult<Prisma.$RunCrewMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipCountArgs} args - Arguments to filter RunCrewMemberships to count.
     * @example
     * // Count the number of RunCrewMemberships
     * const count = await prisma.runCrewMembership.count({
     *   where: {
     *     // ... the filter for the RunCrewMemberships we want to count
     *   }
     * })
    **/
    count<T extends RunCrewMembershipCountArgs>(
      args?: Subset<T, RunCrewMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewMembershipAggregateArgs>(args: Subset<T, RunCrewMembershipAggregateArgs>): Prisma.PrismaPromise<GetRunCrewMembershipAggregateType<T>>

    /**
     * Group by RunCrewMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewMembershipGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewMembership model
   */
  readonly fields: RunCrewMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewMembership model
   */
  interface RunCrewMembershipFieldRefs {
    readonly id: FieldRef<"RunCrewMembership", 'String'>
    readonly runCrewId: FieldRef<"RunCrewMembership", 'String'>
    readonly athleteId: FieldRef<"RunCrewMembership", 'String'>
    readonly joinedAt: FieldRef<"RunCrewMembership", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrewMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewMembership findUnique
   */
  export type RunCrewMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership findUniqueOrThrow
   */
  export type RunCrewMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership findFirst
   */
  export type RunCrewMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMemberships.
     */
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership findFirstOrThrow
   */
  export type RunCrewMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMembership to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMemberships.
     */
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership findMany
   */
  export type RunCrewMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMemberships to fetch.
     */
    where?: RunCrewMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMemberships to fetch.
     */
    orderBy?: RunCrewMembershipOrderByWithRelationInput | RunCrewMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewMemberships.
     */
    cursor?: RunCrewMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMemberships.
     */
    skip?: number
    distinct?: RunCrewMembershipScalarFieldEnum | RunCrewMembershipScalarFieldEnum[]
  }

  /**
   * RunCrewMembership create
   */
  export type RunCrewMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewMembership.
     */
    data: XOR<RunCrewMembershipCreateInput, RunCrewMembershipUncheckedCreateInput>
  }

  /**
   * RunCrewMembership createMany
   */
  export type RunCrewMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewMemberships.
     */
    data: RunCrewMembershipCreateManyInput | RunCrewMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewMembership createManyAndReturn
   */
  export type RunCrewMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewMemberships.
     */
    data: RunCrewMembershipCreateManyInput | RunCrewMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMembership update
   */
  export type RunCrewMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewMembership.
     */
    data: XOR<RunCrewMembershipUpdateInput, RunCrewMembershipUncheckedUpdateInput>
    /**
     * Choose, which RunCrewMembership to update.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership updateMany
   */
  export type RunCrewMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewMemberships.
     */
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMemberships to update
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to update.
     */
    limit?: number
  }

  /**
   * RunCrewMembership updateManyAndReturn
   */
  export type RunCrewMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewMemberships.
     */
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMemberships to update
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMembership upsert
   */
  export type RunCrewMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewMembership to update in case it exists.
     */
    where: RunCrewMembershipWhereUniqueInput
    /**
     * In case the RunCrewMembership found by the `where` argument doesn't exist, create a new RunCrewMembership with this data.
     */
    create: XOR<RunCrewMembershipCreateInput, RunCrewMembershipUncheckedCreateInput>
    /**
     * In case the RunCrewMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewMembershipUpdateInput, RunCrewMembershipUncheckedUpdateInput>
  }

  /**
   * RunCrewMembership delete
   */
  export type RunCrewMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
    /**
     * Filter which RunCrewMembership to delete.
     */
    where: RunCrewMembershipWhereUniqueInput
  }

  /**
   * RunCrewMembership deleteMany
   */
  export type RunCrewMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMemberships to delete
     */
    where?: RunCrewMembershipWhereInput
    /**
     * Limit how many RunCrewMemberships to delete.
     */
    limit?: number
  }

  /**
   * RunCrewMembership without action
   */
  export type RunCrewMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMembership
     */
    select?: RunCrewMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMembership
     */
    omit?: RunCrewMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMembershipInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewMessage
   */

  export type AggregateRunCrewMessage = {
    _count: RunCrewMessageCountAggregateOutputType | null
    _min: RunCrewMessageMinAggregateOutputType | null
    _max: RunCrewMessageMaxAggregateOutputType | null
  }

  export type RunCrewMessageMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RunCrewMessageMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RunCrewMessageCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    content: number
    createdAt: number
    _all: number
  }


  export type RunCrewMessageMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    createdAt?: true
  }

  export type RunCrewMessageMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    createdAt?: true
  }

  export type RunCrewMessageCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type RunCrewMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMessage to aggregate.
     */
    where?: RunCrewMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMessages to fetch.
     */
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewMessages
    **/
    _count?: true | RunCrewMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewMessageMaxAggregateInputType
  }

  export type GetRunCrewMessageAggregateType<T extends RunCrewMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewMessage[P]>
      : GetScalarType<T[P], AggregateRunCrewMessage[P]>
  }




  export type RunCrewMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewMessageWhereInput
    orderBy?: RunCrewMessageOrderByWithAggregationInput | RunCrewMessageOrderByWithAggregationInput[]
    by: RunCrewMessageScalarFieldEnum[] | RunCrewMessageScalarFieldEnum
    having?: RunCrewMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewMessageCountAggregateInputType | true
    _min?: RunCrewMessageMinAggregateInputType
    _max?: RunCrewMessageMaxAggregateInputType
  }

  export type RunCrewMessageGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    content: string
    createdAt: Date
    _count: RunCrewMessageCountAggregateOutputType | null
    _min: RunCrewMessageMinAggregateOutputType | null
    _max: RunCrewMessageMaxAggregateOutputType | null
  }

  type GetRunCrewMessageGroupByPayload<T extends RunCrewMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewMessageGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewMessageGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMessage"]>

  export type RunCrewMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMessage"]>

  export type RunCrewMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewMessage"]>

  export type RunCrewMessageSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type RunCrewMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "content" | "createdAt", ExtArgs["result"]["runCrewMessage"]>
  export type RunCrewMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewMessage"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["runCrewMessage"]>
    composites: {}
  }

  type RunCrewMessageGetPayload<S extends boolean | null | undefined | RunCrewMessageDefaultArgs> = $Result.GetResult<Prisma.$RunCrewMessagePayload, S>

  type RunCrewMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewMessageCountAggregateInputType | true
    }

  export interface RunCrewMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewMessage'], meta: { name: 'RunCrewMessage' } }
    /**
     * Find zero or one RunCrewMessage that matches the filter.
     * @param {RunCrewMessageFindUniqueArgs} args - Arguments to find a RunCrewMessage
     * @example
     * // Get one RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewMessageFindUniqueArgs>(args: SelectSubset<T, RunCrewMessageFindUniqueArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewMessageFindUniqueOrThrowArgs} args - Arguments to find a RunCrewMessage
     * @example
     * // Get one RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageFindFirstArgs} args - Arguments to find a RunCrewMessage
     * @example
     * // Get one RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewMessageFindFirstArgs>(args?: SelectSubset<T, RunCrewMessageFindFirstArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageFindFirstOrThrowArgs} args - Arguments to find a RunCrewMessage
     * @example
     * // Get one RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewMessages
     * const runCrewMessages = await prisma.runCrewMessage.findMany()
     * 
     * // Get first 10 RunCrewMessages
     * const runCrewMessages = await prisma.runCrewMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewMessageWithIdOnly = await prisma.runCrewMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewMessageFindManyArgs>(args?: SelectSubset<T, RunCrewMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewMessage.
     * @param {RunCrewMessageCreateArgs} args - Arguments to create a RunCrewMessage.
     * @example
     * // Create one RunCrewMessage
     * const RunCrewMessage = await prisma.runCrewMessage.create({
     *   data: {
     *     // ... data to create a RunCrewMessage
     *   }
     * })
     * 
     */
    create<T extends RunCrewMessageCreateArgs>(args: SelectSubset<T, RunCrewMessageCreateArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewMessages.
     * @param {RunCrewMessageCreateManyArgs} args - Arguments to create many RunCrewMessages.
     * @example
     * // Create many RunCrewMessages
     * const runCrewMessage = await prisma.runCrewMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewMessageCreateManyArgs>(args?: SelectSubset<T, RunCrewMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewMessages and returns the data saved in the database.
     * @param {RunCrewMessageCreateManyAndReturnArgs} args - Arguments to create many RunCrewMessages.
     * @example
     * // Create many RunCrewMessages
     * const runCrewMessage = await prisma.runCrewMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewMessages and only return the `id`
     * const runCrewMessageWithIdOnly = await prisma.runCrewMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewMessage.
     * @param {RunCrewMessageDeleteArgs} args - Arguments to delete one RunCrewMessage.
     * @example
     * // Delete one RunCrewMessage
     * const RunCrewMessage = await prisma.runCrewMessage.delete({
     *   where: {
     *     // ... filter to delete one RunCrewMessage
     *   }
     * })
     * 
     */
    delete<T extends RunCrewMessageDeleteArgs>(args: SelectSubset<T, RunCrewMessageDeleteArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewMessage.
     * @param {RunCrewMessageUpdateArgs} args - Arguments to update one RunCrewMessage.
     * @example
     * // Update one RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewMessageUpdateArgs>(args: SelectSubset<T, RunCrewMessageUpdateArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewMessages.
     * @param {RunCrewMessageDeleteManyArgs} args - Arguments to filter RunCrewMessages to delete.
     * @example
     * // Delete a few RunCrewMessages
     * const { count } = await prisma.runCrewMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewMessageDeleteManyArgs>(args?: SelectSubset<T, RunCrewMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewMessages
     * const runCrewMessage = await prisma.runCrewMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewMessageUpdateManyArgs>(args: SelectSubset<T, RunCrewMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewMessages and returns the data updated in the database.
     * @param {RunCrewMessageUpdateManyAndReturnArgs} args - Arguments to update many RunCrewMessages.
     * @example
     * // Update many RunCrewMessages
     * const runCrewMessage = await prisma.runCrewMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewMessages and only return the `id`
     * const runCrewMessageWithIdOnly = await prisma.runCrewMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewMessage.
     * @param {RunCrewMessageUpsertArgs} args - Arguments to update or create a RunCrewMessage.
     * @example
     * // Update or create a RunCrewMessage
     * const runCrewMessage = await prisma.runCrewMessage.upsert({
     *   create: {
     *     // ... data to create a RunCrewMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewMessage we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewMessageUpsertArgs>(args: SelectSubset<T, RunCrewMessageUpsertArgs<ExtArgs>>): Prisma__RunCrewMessageClient<$Result.GetResult<Prisma.$RunCrewMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageCountArgs} args - Arguments to filter RunCrewMessages to count.
     * @example
     * // Count the number of RunCrewMessages
     * const count = await prisma.runCrewMessage.count({
     *   where: {
     *     // ... the filter for the RunCrewMessages we want to count
     *   }
     * })
    **/
    count<T extends RunCrewMessageCountArgs>(
      args?: Subset<T, RunCrewMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewMessageAggregateArgs>(args: Subset<T, RunCrewMessageAggregateArgs>): Prisma.PrismaPromise<GetRunCrewMessageAggregateType<T>>

    /**
     * Group by RunCrewMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewMessageGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewMessage model
   */
  readonly fields: RunCrewMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewMessage model
   */
  interface RunCrewMessageFieldRefs {
    readonly id: FieldRef<"RunCrewMessage", 'String'>
    readonly runCrewId: FieldRef<"RunCrewMessage", 'String'>
    readonly athleteId: FieldRef<"RunCrewMessage", 'String'>
    readonly content: FieldRef<"RunCrewMessage", 'String'>
    readonly createdAt: FieldRef<"RunCrewMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewMessage findUnique
   */
  export type RunCrewMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMessage to fetch.
     */
    where: RunCrewMessageWhereUniqueInput
  }

  /**
   * RunCrewMessage findUniqueOrThrow
   */
  export type RunCrewMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMessage to fetch.
     */
    where: RunCrewMessageWhereUniqueInput
  }

  /**
   * RunCrewMessage findFirst
   */
  export type RunCrewMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMessage to fetch.
     */
    where?: RunCrewMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMessages to fetch.
     */
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMessages.
     */
    cursor?: RunCrewMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMessages.
     */
    distinct?: RunCrewMessageScalarFieldEnum | RunCrewMessageScalarFieldEnum[]
  }

  /**
   * RunCrewMessage findFirstOrThrow
   */
  export type RunCrewMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMessage to fetch.
     */
    where?: RunCrewMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMessages to fetch.
     */
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewMessages.
     */
    cursor?: RunCrewMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewMessages.
     */
    distinct?: RunCrewMessageScalarFieldEnum | RunCrewMessageScalarFieldEnum[]
  }

  /**
   * RunCrewMessage findMany
   */
  export type RunCrewMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewMessages to fetch.
     */
    where?: RunCrewMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewMessages to fetch.
     */
    orderBy?: RunCrewMessageOrderByWithRelationInput | RunCrewMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewMessages.
     */
    cursor?: RunCrewMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewMessages.
     */
    skip?: number
    distinct?: RunCrewMessageScalarFieldEnum | RunCrewMessageScalarFieldEnum[]
  }

  /**
   * RunCrewMessage create
   */
  export type RunCrewMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewMessage.
     */
    data: XOR<RunCrewMessageCreateInput, RunCrewMessageUncheckedCreateInput>
  }

  /**
   * RunCrewMessage createMany
   */
  export type RunCrewMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewMessages.
     */
    data: RunCrewMessageCreateManyInput | RunCrewMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewMessage createManyAndReturn
   */
  export type RunCrewMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewMessages.
     */
    data: RunCrewMessageCreateManyInput | RunCrewMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMessage update
   */
  export type RunCrewMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewMessage.
     */
    data: XOR<RunCrewMessageUpdateInput, RunCrewMessageUncheckedUpdateInput>
    /**
     * Choose, which RunCrewMessage to update.
     */
    where: RunCrewMessageWhereUniqueInput
  }

  /**
   * RunCrewMessage updateMany
   */
  export type RunCrewMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewMessages.
     */
    data: XOR<RunCrewMessageUpdateManyMutationInput, RunCrewMessageUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMessages to update
     */
    where?: RunCrewMessageWhereInput
    /**
     * Limit how many RunCrewMessages to update.
     */
    limit?: number
  }

  /**
   * RunCrewMessage updateManyAndReturn
   */
  export type RunCrewMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewMessages.
     */
    data: XOR<RunCrewMessageUpdateManyMutationInput, RunCrewMessageUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewMessages to update
     */
    where?: RunCrewMessageWhereInput
    /**
     * Limit how many RunCrewMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewMessage upsert
   */
  export type RunCrewMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewMessage to update in case it exists.
     */
    where: RunCrewMessageWhereUniqueInput
    /**
     * In case the RunCrewMessage found by the `where` argument doesn't exist, create a new RunCrewMessage with this data.
     */
    create: XOR<RunCrewMessageCreateInput, RunCrewMessageUncheckedCreateInput>
    /**
     * In case the RunCrewMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewMessageUpdateInput, RunCrewMessageUncheckedUpdateInput>
  }

  /**
   * RunCrewMessage delete
   */
  export type RunCrewMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
    /**
     * Filter which RunCrewMessage to delete.
     */
    where: RunCrewMessageWhereUniqueInput
  }

  /**
   * RunCrewMessage deleteMany
   */
  export type RunCrewMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewMessages to delete
     */
    where?: RunCrewMessageWhereInput
    /**
     * Limit how many RunCrewMessages to delete.
     */
    limit?: number
  }

  /**
   * RunCrewMessage without action
   */
  export type RunCrewMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewMessage
     */
    select?: RunCrewMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewMessage
     */
    omit?: RunCrewMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewMessageInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewAnnouncement
   */

  export type AggregateRunCrewAnnouncement = {
    _count: RunCrewAnnouncementCountAggregateOutputType | null
    _min: RunCrewAnnouncementMinAggregateOutputType | null
    _max: RunCrewAnnouncementMaxAggregateOutputType | null
  }

  export type RunCrewAnnouncementMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewAnnouncementMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewAnnouncementCountAggregateOutputType = {
    id: number
    runCrewId: number
    authorId: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewAnnouncementMinAggregateInputType = {
    id?: true
    runCrewId?: true
    authorId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewAnnouncementMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    authorId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewAnnouncementCountAggregateInputType = {
    id?: true
    runCrewId?: true
    authorId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewAnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewAnnouncement to aggregate.
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewAnnouncements to fetch.
     */
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewAnnouncements
    **/
    _count?: true | RunCrewAnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewAnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewAnnouncementMaxAggregateInputType
  }

  export type GetRunCrewAnnouncementAggregateType<T extends RunCrewAnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewAnnouncement[P]>
      : GetScalarType<T[P], AggregateRunCrewAnnouncement[P]>
  }




  export type RunCrewAnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewAnnouncementWhereInput
    orderBy?: RunCrewAnnouncementOrderByWithAggregationInput | RunCrewAnnouncementOrderByWithAggregationInput[]
    by: RunCrewAnnouncementScalarFieldEnum[] | RunCrewAnnouncementScalarFieldEnum
    having?: RunCrewAnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewAnnouncementCountAggregateInputType | true
    _min?: RunCrewAnnouncementMinAggregateInputType
    _max?: RunCrewAnnouncementMaxAggregateInputType
  }

  export type RunCrewAnnouncementGroupByOutputType = {
    id: string
    runCrewId: string
    authorId: string
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: RunCrewAnnouncementCountAggregateOutputType | null
    _min: RunCrewAnnouncementMinAggregateOutputType | null
    _max: RunCrewAnnouncementMaxAggregateOutputType | null
  }

  type GetRunCrewAnnouncementGroupByPayload<T extends RunCrewAnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewAnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewAnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewAnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewAnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewAnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewAnnouncement"]>

  export type RunCrewAnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewAnnouncement"]>

  export type RunCrewAnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewAnnouncement"]>

  export type RunCrewAnnouncementSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewAnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "authorId" | "title" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewAnnouncement"]>
  export type RunCrewAnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewAnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewAnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    author?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewAnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewAnnouncement"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      author: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      authorId: string
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewAnnouncement"]>
    composites: {}
  }

  type RunCrewAnnouncementGetPayload<S extends boolean | null | undefined | RunCrewAnnouncementDefaultArgs> = $Result.GetResult<Prisma.$RunCrewAnnouncementPayload, S>

  type RunCrewAnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewAnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewAnnouncementCountAggregateInputType | true
    }

  export interface RunCrewAnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewAnnouncement'], meta: { name: 'RunCrewAnnouncement' } }
    /**
     * Find zero or one RunCrewAnnouncement that matches the filter.
     * @param {RunCrewAnnouncementFindUniqueArgs} args - Arguments to find a RunCrewAnnouncement
     * @example
     * // Get one RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewAnnouncementFindUniqueArgs>(args: SelectSubset<T, RunCrewAnnouncementFindUniqueArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewAnnouncement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewAnnouncementFindUniqueOrThrowArgs} args - Arguments to find a RunCrewAnnouncement
     * @example
     * // Get one RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewAnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewAnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewAnnouncement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementFindFirstArgs} args - Arguments to find a RunCrewAnnouncement
     * @example
     * // Get one RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewAnnouncementFindFirstArgs>(args?: SelectSubset<T, RunCrewAnnouncementFindFirstArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewAnnouncement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementFindFirstOrThrowArgs} args - Arguments to find a RunCrewAnnouncement
     * @example
     * // Get one RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewAnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewAnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewAnnouncements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewAnnouncements
     * const runCrewAnnouncements = await prisma.runCrewAnnouncement.findMany()
     * 
     * // Get first 10 RunCrewAnnouncements
     * const runCrewAnnouncements = await prisma.runCrewAnnouncement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewAnnouncementWithIdOnly = await prisma.runCrewAnnouncement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewAnnouncementFindManyArgs>(args?: SelectSubset<T, RunCrewAnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewAnnouncement.
     * @param {RunCrewAnnouncementCreateArgs} args - Arguments to create a RunCrewAnnouncement.
     * @example
     * // Create one RunCrewAnnouncement
     * const RunCrewAnnouncement = await prisma.runCrewAnnouncement.create({
     *   data: {
     *     // ... data to create a RunCrewAnnouncement
     *   }
     * })
     * 
     */
    create<T extends RunCrewAnnouncementCreateArgs>(args: SelectSubset<T, RunCrewAnnouncementCreateArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewAnnouncements.
     * @param {RunCrewAnnouncementCreateManyArgs} args - Arguments to create many RunCrewAnnouncements.
     * @example
     * // Create many RunCrewAnnouncements
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewAnnouncementCreateManyArgs>(args?: SelectSubset<T, RunCrewAnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewAnnouncements and returns the data saved in the database.
     * @param {RunCrewAnnouncementCreateManyAndReturnArgs} args - Arguments to create many RunCrewAnnouncements.
     * @example
     * // Create many RunCrewAnnouncements
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewAnnouncements and only return the `id`
     * const runCrewAnnouncementWithIdOnly = await prisma.runCrewAnnouncement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewAnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewAnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewAnnouncement.
     * @param {RunCrewAnnouncementDeleteArgs} args - Arguments to delete one RunCrewAnnouncement.
     * @example
     * // Delete one RunCrewAnnouncement
     * const RunCrewAnnouncement = await prisma.runCrewAnnouncement.delete({
     *   where: {
     *     // ... filter to delete one RunCrewAnnouncement
     *   }
     * })
     * 
     */
    delete<T extends RunCrewAnnouncementDeleteArgs>(args: SelectSubset<T, RunCrewAnnouncementDeleteArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewAnnouncement.
     * @param {RunCrewAnnouncementUpdateArgs} args - Arguments to update one RunCrewAnnouncement.
     * @example
     * // Update one RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewAnnouncementUpdateArgs>(args: SelectSubset<T, RunCrewAnnouncementUpdateArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewAnnouncements.
     * @param {RunCrewAnnouncementDeleteManyArgs} args - Arguments to filter RunCrewAnnouncements to delete.
     * @example
     * // Delete a few RunCrewAnnouncements
     * const { count } = await prisma.runCrewAnnouncement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewAnnouncementDeleteManyArgs>(args?: SelectSubset<T, RunCrewAnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewAnnouncements
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewAnnouncementUpdateManyArgs>(args: SelectSubset<T, RunCrewAnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewAnnouncements and returns the data updated in the database.
     * @param {RunCrewAnnouncementUpdateManyAndReturnArgs} args - Arguments to update many RunCrewAnnouncements.
     * @example
     * // Update many RunCrewAnnouncements
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewAnnouncements and only return the `id`
     * const runCrewAnnouncementWithIdOnly = await prisma.runCrewAnnouncement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewAnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewAnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewAnnouncement.
     * @param {RunCrewAnnouncementUpsertArgs} args - Arguments to update or create a RunCrewAnnouncement.
     * @example
     * // Update or create a RunCrewAnnouncement
     * const runCrewAnnouncement = await prisma.runCrewAnnouncement.upsert({
     *   create: {
     *     // ... data to create a RunCrewAnnouncement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewAnnouncement we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewAnnouncementUpsertArgs>(args: SelectSubset<T, RunCrewAnnouncementUpsertArgs<ExtArgs>>): Prisma__RunCrewAnnouncementClient<$Result.GetResult<Prisma.$RunCrewAnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementCountArgs} args - Arguments to filter RunCrewAnnouncements to count.
     * @example
     * // Count the number of RunCrewAnnouncements
     * const count = await prisma.runCrewAnnouncement.count({
     *   where: {
     *     // ... the filter for the RunCrewAnnouncements we want to count
     *   }
     * })
    **/
    count<T extends RunCrewAnnouncementCountArgs>(
      args?: Subset<T, RunCrewAnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewAnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewAnnouncementAggregateArgs>(args: Subset<T, RunCrewAnnouncementAggregateArgs>): Prisma.PrismaPromise<GetRunCrewAnnouncementAggregateType<T>>

    /**
     * Group by RunCrewAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewAnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewAnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewAnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewAnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewAnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewAnnouncement model
   */
  readonly fields: RunCrewAnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewAnnouncement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewAnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewAnnouncement model
   */
  interface RunCrewAnnouncementFieldRefs {
    readonly id: FieldRef<"RunCrewAnnouncement", 'String'>
    readonly runCrewId: FieldRef<"RunCrewAnnouncement", 'String'>
    readonly authorId: FieldRef<"RunCrewAnnouncement", 'String'>
    readonly title: FieldRef<"RunCrewAnnouncement", 'String'>
    readonly content: FieldRef<"RunCrewAnnouncement", 'String'>
    readonly createdAt: FieldRef<"RunCrewAnnouncement", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewAnnouncement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewAnnouncement findUnique
   */
  export type RunCrewAnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewAnnouncement to fetch.
     */
    where: RunCrewAnnouncementWhereUniqueInput
  }

  /**
   * RunCrewAnnouncement findUniqueOrThrow
   */
  export type RunCrewAnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewAnnouncement to fetch.
     */
    where: RunCrewAnnouncementWhereUniqueInput
  }

  /**
   * RunCrewAnnouncement findFirst
   */
  export type RunCrewAnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewAnnouncement to fetch.
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewAnnouncements to fetch.
     */
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewAnnouncements.
     */
    cursor?: RunCrewAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewAnnouncements.
     */
    distinct?: RunCrewAnnouncementScalarFieldEnum | RunCrewAnnouncementScalarFieldEnum[]
  }

  /**
   * RunCrewAnnouncement findFirstOrThrow
   */
  export type RunCrewAnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewAnnouncement to fetch.
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewAnnouncements to fetch.
     */
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewAnnouncements.
     */
    cursor?: RunCrewAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewAnnouncements.
     */
    distinct?: RunCrewAnnouncementScalarFieldEnum | RunCrewAnnouncementScalarFieldEnum[]
  }

  /**
   * RunCrewAnnouncement findMany
   */
  export type RunCrewAnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewAnnouncements to fetch.
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewAnnouncements to fetch.
     */
    orderBy?: RunCrewAnnouncementOrderByWithRelationInput | RunCrewAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewAnnouncements.
     */
    cursor?: RunCrewAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewAnnouncements.
     */
    skip?: number
    distinct?: RunCrewAnnouncementScalarFieldEnum | RunCrewAnnouncementScalarFieldEnum[]
  }

  /**
   * RunCrewAnnouncement create
   */
  export type RunCrewAnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewAnnouncement.
     */
    data: XOR<RunCrewAnnouncementCreateInput, RunCrewAnnouncementUncheckedCreateInput>
  }

  /**
   * RunCrewAnnouncement createMany
   */
  export type RunCrewAnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewAnnouncements.
     */
    data: RunCrewAnnouncementCreateManyInput | RunCrewAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewAnnouncement createManyAndReturn
   */
  export type RunCrewAnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewAnnouncements.
     */
    data: RunCrewAnnouncementCreateManyInput | RunCrewAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewAnnouncement update
   */
  export type RunCrewAnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewAnnouncement.
     */
    data: XOR<RunCrewAnnouncementUpdateInput, RunCrewAnnouncementUncheckedUpdateInput>
    /**
     * Choose, which RunCrewAnnouncement to update.
     */
    where: RunCrewAnnouncementWhereUniqueInput
  }

  /**
   * RunCrewAnnouncement updateMany
   */
  export type RunCrewAnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewAnnouncements.
     */
    data: XOR<RunCrewAnnouncementUpdateManyMutationInput, RunCrewAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewAnnouncements to update
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * Limit how many RunCrewAnnouncements to update.
     */
    limit?: number
  }

  /**
   * RunCrewAnnouncement updateManyAndReturn
   */
  export type RunCrewAnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewAnnouncements.
     */
    data: XOR<RunCrewAnnouncementUpdateManyMutationInput, RunCrewAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewAnnouncements to update
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * Limit how many RunCrewAnnouncements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewAnnouncement upsert
   */
  export type RunCrewAnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewAnnouncement to update in case it exists.
     */
    where: RunCrewAnnouncementWhereUniqueInput
    /**
     * In case the RunCrewAnnouncement found by the `where` argument doesn't exist, create a new RunCrewAnnouncement with this data.
     */
    create: XOR<RunCrewAnnouncementCreateInput, RunCrewAnnouncementUncheckedCreateInput>
    /**
     * In case the RunCrewAnnouncement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewAnnouncementUpdateInput, RunCrewAnnouncementUncheckedUpdateInput>
  }

  /**
   * RunCrewAnnouncement delete
   */
  export type RunCrewAnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
    /**
     * Filter which RunCrewAnnouncement to delete.
     */
    where: RunCrewAnnouncementWhereUniqueInput
  }

  /**
   * RunCrewAnnouncement deleteMany
   */
  export type RunCrewAnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewAnnouncements to delete
     */
    where?: RunCrewAnnouncementWhereInput
    /**
     * Limit how many RunCrewAnnouncements to delete.
     */
    limit?: number
  }

  /**
   * RunCrewAnnouncement without action
   */
  export type RunCrewAnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewAnnouncement
     */
    select?: RunCrewAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewAnnouncement
     */
    omit?: RunCrewAnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewAnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewLeaderboard
   */

  export type AggregateRunCrewLeaderboard = {
    _count: RunCrewLeaderboardCountAggregateOutputType | null
    _avg: RunCrewLeaderboardAvgAggregateOutputType | null
    _sum: RunCrewLeaderboardSumAggregateOutputType | null
    _min: RunCrewLeaderboardMinAggregateOutputType | null
    _max: RunCrewLeaderboardMaxAggregateOutputType | null
  }

  export type RunCrewLeaderboardAvgAggregateOutputType = {
    totalMiles: number | null
    totalRuns: number | null
    totalCalories: number | null
    totalElevation: number | null
  }

  export type RunCrewLeaderboardSumAggregateOutputType = {
    totalMiles: number | null
    totalRuns: number | null
    totalCalories: number | null
    totalElevation: number | null
  }

  export type RunCrewLeaderboardMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalMiles: number | null
    totalRuns: number | null
    bestPace: string | null
    totalCalories: number | null
    totalElevation: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewLeaderboardMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalMiles: number | null
    totalRuns: number | null
    bestPace: string | null
    totalCalories: number | null
    totalElevation: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewLeaderboardCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    period: number
    periodStart: number
    periodEnd: number
    totalMiles: number
    totalRuns: number
    bestPace: number
    totalCalories: number
    totalElevation: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewLeaderboardAvgAggregateInputType = {
    totalMiles?: true
    totalRuns?: true
    totalCalories?: true
    totalElevation?: true
  }

  export type RunCrewLeaderboardSumAggregateInputType = {
    totalMiles?: true
    totalRuns?: true
    totalCalories?: true
    totalElevation?: true
  }

  export type RunCrewLeaderboardMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewLeaderboardMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewLeaderboardCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalMiles?: true
    totalRuns?: true
    bestPace?: true
    totalCalories?: true
    totalElevation?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewLeaderboard to aggregate.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewLeaderboards
    **/
    _count?: true | RunCrewLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RunCrewLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RunCrewLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewLeaderboardMaxAggregateInputType
  }

  export type GetRunCrewLeaderboardAggregateType<T extends RunCrewLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewLeaderboard[P]>
      : GetScalarType<T[P], AggregateRunCrewLeaderboard[P]>
  }




  export type RunCrewLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewLeaderboardWhereInput
    orderBy?: RunCrewLeaderboardOrderByWithAggregationInput | RunCrewLeaderboardOrderByWithAggregationInput[]
    by: RunCrewLeaderboardScalarFieldEnum[] | RunCrewLeaderboardScalarFieldEnum
    having?: RunCrewLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewLeaderboardCountAggregateInputType | true
    _avg?: RunCrewLeaderboardAvgAggregateInputType
    _sum?: RunCrewLeaderboardSumAggregateInputType
    _min?: RunCrewLeaderboardMinAggregateInputType
    _max?: RunCrewLeaderboardMaxAggregateInputType
  }

  export type RunCrewLeaderboardGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date
    periodEnd: Date
    totalMiles: number
    totalRuns: number
    bestPace: string | null
    totalCalories: number
    totalElevation: number
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RunCrewLeaderboardCountAggregateOutputType | null
    _avg: RunCrewLeaderboardAvgAggregateOutputType | null
    _sum: RunCrewLeaderboardSumAggregateOutputType | null
    _min: RunCrewLeaderboardMinAggregateOutputType | null
    _max: RunCrewLeaderboardMaxAggregateOutputType | null
  }

  type GetRunCrewLeaderboardGroupByPayload<T extends RunCrewLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewLeaderboard"]>

  export type RunCrewLeaderboardSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalMiles?: boolean
    totalRuns?: boolean
    bestPace?: boolean
    totalCalories?: boolean
    totalElevation?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "period" | "periodStart" | "periodEnd" | "totalMiles" | "totalRuns" | "bestPace" | "totalCalories" | "totalElevation" | "calculatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewLeaderboard"]>
  export type RunCrewLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewLeaderboard"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      period: string
      periodStart: Date
      periodEnd: Date
      totalMiles: number
      totalRuns: number
      bestPace: string | null
      totalCalories: number
      totalElevation: number
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewLeaderboard"]>
    composites: {}
  }

  type RunCrewLeaderboardGetPayload<S extends boolean | null | undefined | RunCrewLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$RunCrewLeaderboardPayload, S>

  type RunCrewLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewLeaderboardCountAggregateInputType | true
    }

  export interface RunCrewLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewLeaderboard'], meta: { name: 'RunCrewLeaderboard' } }
    /**
     * Find zero or one RunCrewLeaderboard that matches the filter.
     * @param {RunCrewLeaderboardFindUniqueArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewLeaderboardFindUniqueArgs>(args: SelectSubset<T, RunCrewLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindFirstArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewLeaderboardFindFirstArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindFirstArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindFirstOrThrowArgs} args - Arguments to find a RunCrewLeaderboard
     * @example
     * // Get one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewLeaderboards
     * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany()
     * 
     * // Get first 10 RunCrewLeaderboards
     * const runCrewLeaderboards = await prisma.runCrewLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewLeaderboardFindManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewLeaderboard.
     * @param {RunCrewLeaderboardCreateArgs} args - Arguments to create a RunCrewLeaderboard.
     * @example
     * // Create one RunCrewLeaderboard
     * const RunCrewLeaderboard = await prisma.runCrewLeaderboard.create({
     *   data: {
     *     // ... data to create a RunCrewLeaderboard
     *   }
     * })
     * 
     */
    create<T extends RunCrewLeaderboardCreateArgs>(args: SelectSubset<T, RunCrewLeaderboardCreateArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewLeaderboards.
     * @param {RunCrewLeaderboardCreateManyArgs} args - Arguments to create many RunCrewLeaderboards.
     * @example
     * // Create many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewLeaderboardCreateManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewLeaderboards and returns the data saved in the database.
     * @param {RunCrewLeaderboardCreateManyAndReturnArgs} args - Arguments to create many RunCrewLeaderboards.
     * @example
     * // Create many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewLeaderboards and only return the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewLeaderboard.
     * @param {RunCrewLeaderboardDeleteArgs} args - Arguments to delete one RunCrewLeaderboard.
     * @example
     * // Delete one RunCrewLeaderboard
     * const RunCrewLeaderboard = await prisma.runCrewLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one RunCrewLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends RunCrewLeaderboardDeleteArgs>(args: SelectSubset<T, RunCrewLeaderboardDeleteArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewLeaderboard.
     * @param {RunCrewLeaderboardUpdateArgs} args - Arguments to update one RunCrewLeaderboard.
     * @example
     * // Update one RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewLeaderboardUpdateArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewLeaderboards.
     * @param {RunCrewLeaderboardDeleteManyArgs} args - Arguments to filter RunCrewLeaderboards to delete.
     * @example
     * // Delete a few RunCrewLeaderboards
     * const { count } = await prisma.runCrewLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewLeaderboardDeleteManyArgs>(args?: SelectSubset<T, RunCrewLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewLeaderboardUpdateManyArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewLeaderboards and returns the data updated in the database.
     * @param {RunCrewLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many RunCrewLeaderboards.
     * @example
     * // Update many RunCrewLeaderboards
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewLeaderboards and only return the `id`
     * const runCrewLeaderboardWithIdOnly = await prisma.runCrewLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewLeaderboard.
     * @param {RunCrewLeaderboardUpsertArgs} args - Arguments to update or create a RunCrewLeaderboard.
     * @example
     * // Update or create a RunCrewLeaderboard
     * const runCrewLeaderboard = await prisma.runCrewLeaderboard.upsert({
     *   create: {
     *     // ... data to create a RunCrewLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewLeaderboardUpsertArgs>(args: SelectSubset<T, RunCrewLeaderboardUpsertArgs<ExtArgs>>): Prisma__RunCrewLeaderboardClient<$Result.GetResult<Prisma.$RunCrewLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardCountArgs} args - Arguments to filter RunCrewLeaderboards to count.
     * @example
     * // Count the number of RunCrewLeaderboards
     * const count = await prisma.runCrewLeaderboard.count({
     *   where: {
     *     // ... the filter for the RunCrewLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends RunCrewLeaderboardCountArgs>(
      args?: Subset<T, RunCrewLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewLeaderboardAggregateArgs>(args: Subset<T, RunCrewLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetRunCrewLeaderboardAggregateType<T>>

    /**
     * Group by RunCrewLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewLeaderboard model
   */
  readonly fields: RunCrewLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewLeaderboard model
   */
  interface RunCrewLeaderboardFieldRefs {
    readonly id: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly runCrewId: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly athleteId: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly period: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly periodStart: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly periodEnd: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly totalMiles: FieldRef<"RunCrewLeaderboard", 'Float'>
    readonly totalRuns: FieldRef<"RunCrewLeaderboard", 'Int'>
    readonly bestPace: FieldRef<"RunCrewLeaderboard", 'String'>
    readonly totalCalories: FieldRef<"RunCrewLeaderboard", 'Int'>
    readonly totalElevation: FieldRef<"RunCrewLeaderboard", 'Float'>
    readonly calculatedAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly createdAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewLeaderboard findUnique
   */
  export type RunCrewLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard findUniqueOrThrow
   */
  export type RunCrewLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard findFirst
   */
  export type RunCrewLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewLeaderboards.
     */
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard findFirstOrThrow
   */
  export type RunCrewLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboard to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewLeaderboards.
     */
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard findMany
   */
  export type RunCrewLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewLeaderboards to fetch.
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewLeaderboards to fetch.
     */
    orderBy?: RunCrewLeaderboardOrderByWithRelationInput | RunCrewLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewLeaderboards.
     */
    cursor?: RunCrewLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewLeaderboards.
     */
    skip?: number
    distinct?: RunCrewLeaderboardScalarFieldEnum | RunCrewLeaderboardScalarFieldEnum[]
  }

  /**
   * RunCrewLeaderboard create
   */
  export type RunCrewLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewLeaderboard.
     */
    data: XOR<RunCrewLeaderboardCreateInput, RunCrewLeaderboardUncheckedCreateInput>
  }

  /**
   * RunCrewLeaderboard createMany
   */
  export type RunCrewLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewLeaderboards.
     */
    data: RunCrewLeaderboardCreateManyInput | RunCrewLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewLeaderboard createManyAndReturn
   */
  export type RunCrewLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewLeaderboards.
     */
    data: RunCrewLeaderboardCreateManyInput | RunCrewLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewLeaderboard update
   */
  export type RunCrewLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewLeaderboard.
     */
    data: XOR<RunCrewLeaderboardUpdateInput, RunCrewLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which RunCrewLeaderboard to update.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard updateMany
   */
  export type RunCrewLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewLeaderboards.
     */
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewLeaderboards to update
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to update.
     */
    limit?: number
  }

  /**
   * RunCrewLeaderboard updateManyAndReturn
   */
  export type RunCrewLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewLeaderboards.
     */
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewLeaderboards to update
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewLeaderboard upsert
   */
  export type RunCrewLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewLeaderboard to update in case it exists.
     */
    where: RunCrewLeaderboardWhereUniqueInput
    /**
     * In case the RunCrewLeaderboard found by the `where` argument doesn't exist, create a new RunCrewLeaderboard with this data.
     */
    create: XOR<RunCrewLeaderboardCreateInput, RunCrewLeaderboardUncheckedCreateInput>
    /**
     * In case the RunCrewLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewLeaderboardUpdateInput, RunCrewLeaderboardUncheckedUpdateInput>
  }

  /**
   * RunCrewLeaderboard delete
   */
  export type RunCrewLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which RunCrewLeaderboard to delete.
     */
    where: RunCrewLeaderboardWhereUniqueInput
  }

  /**
   * RunCrewLeaderboard deleteMany
   */
  export type RunCrewLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewLeaderboards to delete
     */
    where?: RunCrewLeaderboardWhereInput
    /**
     * Limit how many RunCrewLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * RunCrewLeaderboard without action
   */
  export type RunCrewLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewLeaderboard
     */
    select?: RunCrewLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewLeaderboard
     */
    omit?: RunCrewLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewRun
   */

  export type AggregateRunCrewRun = {
    _count: RunCrewRunCountAggregateOutputType | null
    _avg: RunCrewRunAvgAggregateOutputType | null
    _sum: RunCrewRunSumAggregateOutputType | null
    _min: RunCrewRunMinAggregateOutputType | null
    _max: RunCrewRunMaxAggregateOutputType | null
  }

  export type RunCrewRunAvgAggregateOutputType = {
    totalMiles: number | null
  }

  export type RunCrewRunSumAggregateOutputType = {
    totalMiles: number | null
  }

  export type RunCrewRunMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    createdById: string | null
    title: string | null
    date: Date | null
    startTime: string | null
    location: string | null
    address: string | null
    totalMiles: number | null
    pace: string | null
    stravaMapUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewRunMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    createdById: string | null
    title: string | null
    date: Date | null
    startTime: string | null
    location: string | null
    address: string | null
    totalMiles: number | null
    pace: string | null
    stravaMapUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewRunCountAggregateOutputType = {
    id: number
    runCrewId: number
    createdById: number
    title: number
    date: number
    startTime: number
    location: number
    address: number
    totalMiles: number
    pace: number
    stravaMapUrl: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewRunAvgAggregateInputType = {
    totalMiles?: true
  }

  export type RunCrewRunSumAggregateInputType = {
    totalMiles?: true
  }

  export type RunCrewRunMinAggregateInputType = {
    id?: true
    runCrewId?: true
    createdById?: true
    title?: true
    date?: true
    startTime?: true
    location?: true
    address?: true
    totalMiles?: true
    pace?: true
    stravaMapUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewRunMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    createdById?: true
    title?: true
    date?: true
    startTime?: true
    location?: true
    address?: true
    totalMiles?: true
    pace?: true
    stravaMapUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewRunCountAggregateInputType = {
    id?: true
    runCrewId?: true
    createdById?: true
    title?: true
    date?: true
    startTime?: true
    location?: true
    address?: true
    totalMiles?: true
    pace?: true
    stravaMapUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewRun to aggregate.
     */
    where?: RunCrewRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRuns to fetch.
     */
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewRuns
    **/
    _count?: true | RunCrewRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RunCrewRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RunCrewRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewRunMaxAggregateInputType
  }

  export type GetRunCrewRunAggregateType<T extends RunCrewRunAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewRun[P]>
      : GetScalarType<T[P], AggregateRunCrewRun[P]>
  }




  export type RunCrewRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunWhereInput
    orderBy?: RunCrewRunOrderByWithAggregationInput | RunCrewRunOrderByWithAggregationInput[]
    by: RunCrewRunScalarFieldEnum[] | RunCrewRunScalarFieldEnum
    having?: RunCrewRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewRunCountAggregateInputType | true
    _avg?: RunCrewRunAvgAggregateInputType
    _sum?: RunCrewRunSumAggregateInputType
    _min?: RunCrewRunMinAggregateInputType
    _max?: RunCrewRunMaxAggregateInputType
  }

  export type RunCrewRunGroupByOutputType = {
    id: string
    runCrewId: string
    createdById: string
    title: string
    date: Date
    startTime: string
    location: string
    address: string | null
    totalMiles: number | null
    pace: string | null
    stravaMapUrl: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RunCrewRunCountAggregateOutputType | null
    _avg: RunCrewRunAvgAggregateOutputType | null
    _sum: RunCrewRunSumAggregateOutputType | null
    _min: RunCrewRunMinAggregateOutputType | null
    _max: RunCrewRunMaxAggregateOutputType | null
  }

  type GetRunCrewRunGroupByPayload<T extends RunCrewRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewRunGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewRunGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    createdById?: boolean
    title?: boolean
    date?: boolean
    startTime?: boolean
    location?: boolean
    address?: boolean
    totalMiles?: boolean
    pace?: boolean
    stravaMapUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
    rsvps?: boolean | RunCrewRun$rsvpsArgs<ExtArgs>
    _count?: boolean | RunCrewRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRun"]>

  export type RunCrewRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    createdById?: boolean
    title?: boolean
    date?: boolean
    startTime?: boolean
    location?: boolean
    address?: boolean
    totalMiles?: boolean
    pace?: boolean
    stravaMapUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRun"]>

  export type RunCrewRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    createdById?: boolean
    title?: boolean
    date?: boolean
    startTime?: boolean
    location?: boolean
    address?: boolean
    totalMiles?: boolean
    pace?: boolean
    stravaMapUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRun"]>

  export type RunCrewRunSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    createdById?: boolean
    title?: boolean
    date?: boolean
    startTime?: boolean
    location?: boolean
    address?: boolean
    totalMiles?: boolean
    pace?: boolean
    stravaMapUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "createdById" | "title" | "date" | "startTime" | "location" | "address" | "totalMiles" | "pace" | "stravaMapUrl" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewRun"]>
  export type RunCrewRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
    rsvps?: boolean | RunCrewRun$rsvpsArgs<ExtArgs>
    _count?: boolean | RunCrewRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunCrewRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    createdBy?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewRun"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      createdBy: Prisma.$AthletePayload<ExtArgs>
      rsvps: Prisma.$RunCrewRunRSVPPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      createdById: string
      title: string
      date: Date
      startTime: string
      location: string
      address: string | null
      totalMiles: number | null
      pace: string | null
      stravaMapUrl: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewRun"]>
    composites: {}
  }

  type RunCrewRunGetPayload<S extends boolean | null | undefined | RunCrewRunDefaultArgs> = $Result.GetResult<Prisma.$RunCrewRunPayload, S>

  type RunCrewRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewRunCountAggregateInputType | true
    }

  export interface RunCrewRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewRun'], meta: { name: 'RunCrewRun' } }
    /**
     * Find zero or one RunCrewRun that matches the filter.
     * @param {RunCrewRunFindUniqueArgs} args - Arguments to find a RunCrewRun
     * @example
     * // Get one RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewRunFindUniqueArgs>(args: SelectSubset<T, RunCrewRunFindUniqueArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewRunFindUniqueOrThrowArgs} args - Arguments to find a RunCrewRun
     * @example
     * // Get one RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewRunFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunFindFirstArgs} args - Arguments to find a RunCrewRun
     * @example
     * // Get one RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewRunFindFirstArgs>(args?: SelectSubset<T, RunCrewRunFindFirstArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunFindFirstOrThrowArgs} args - Arguments to find a RunCrewRun
     * @example
     * // Get one RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewRunFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewRuns
     * const runCrewRuns = await prisma.runCrewRun.findMany()
     * 
     * // Get first 10 RunCrewRuns
     * const runCrewRuns = await prisma.runCrewRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewRunWithIdOnly = await prisma.runCrewRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewRunFindManyArgs>(args?: SelectSubset<T, RunCrewRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewRun.
     * @param {RunCrewRunCreateArgs} args - Arguments to create a RunCrewRun.
     * @example
     * // Create one RunCrewRun
     * const RunCrewRun = await prisma.runCrewRun.create({
     *   data: {
     *     // ... data to create a RunCrewRun
     *   }
     * })
     * 
     */
    create<T extends RunCrewRunCreateArgs>(args: SelectSubset<T, RunCrewRunCreateArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewRuns.
     * @param {RunCrewRunCreateManyArgs} args - Arguments to create many RunCrewRuns.
     * @example
     * // Create many RunCrewRuns
     * const runCrewRun = await prisma.runCrewRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewRunCreateManyArgs>(args?: SelectSubset<T, RunCrewRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewRuns and returns the data saved in the database.
     * @param {RunCrewRunCreateManyAndReturnArgs} args - Arguments to create many RunCrewRuns.
     * @example
     * // Create many RunCrewRuns
     * const runCrewRun = await prisma.runCrewRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewRuns and only return the `id`
     * const runCrewRunWithIdOnly = await prisma.runCrewRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewRunCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewRun.
     * @param {RunCrewRunDeleteArgs} args - Arguments to delete one RunCrewRun.
     * @example
     * // Delete one RunCrewRun
     * const RunCrewRun = await prisma.runCrewRun.delete({
     *   where: {
     *     // ... filter to delete one RunCrewRun
     *   }
     * })
     * 
     */
    delete<T extends RunCrewRunDeleteArgs>(args: SelectSubset<T, RunCrewRunDeleteArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewRun.
     * @param {RunCrewRunUpdateArgs} args - Arguments to update one RunCrewRun.
     * @example
     * // Update one RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewRunUpdateArgs>(args: SelectSubset<T, RunCrewRunUpdateArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewRuns.
     * @param {RunCrewRunDeleteManyArgs} args - Arguments to filter RunCrewRuns to delete.
     * @example
     * // Delete a few RunCrewRuns
     * const { count } = await prisma.runCrewRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewRunDeleteManyArgs>(args?: SelectSubset<T, RunCrewRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewRuns
     * const runCrewRun = await prisma.runCrewRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewRunUpdateManyArgs>(args: SelectSubset<T, RunCrewRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewRuns and returns the data updated in the database.
     * @param {RunCrewRunUpdateManyAndReturnArgs} args - Arguments to update many RunCrewRuns.
     * @example
     * // Update many RunCrewRuns
     * const runCrewRun = await prisma.runCrewRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewRuns and only return the `id`
     * const runCrewRunWithIdOnly = await prisma.runCrewRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewRunUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewRun.
     * @param {RunCrewRunUpsertArgs} args - Arguments to update or create a RunCrewRun.
     * @example
     * // Update or create a RunCrewRun
     * const runCrewRun = await prisma.runCrewRun.upsert({
     *   create: {
     *     // ... data to create a RunCrewRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewRun we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewRunUpsertArgs>(args: SelectSubset<T, RunCrewRunUpsertArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunCountArgs} args - Arguments to filter RunCrewRuns to count.
     * @example
     * // Count the number of RunCrewRuns
     * const count = await prisma.runCrewRun.count({
     *   where: {
     *     // ... the filter for the RunCrewRuns we want to count
     *   }
     * })
    **/
    count<T extends RunCrewRunCountArgs>(
      args?: Subset<T, RunCrewRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewRunAggregateArgs>(args: Subset<T, RunCrewRunAggregateArgs>): Prisma.PrismaPromise<GetRunCrewRunAggregateType<T>>

    /**
     * Group by RunCrewRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewRunGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewRun model
   */
  readonly fields: RunCrewRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rsvps<T extends RunCrewRun$rsvpsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewRun$rsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewRun model
   */
  interface RunCrewRunFieldRefs {
    readonly id: FieldRef<"RunCrewRun", 'String'>
    readonly runCrewId: FieldRef<"RunCrewRun", 'String'>
    readonly createdById: FieldRef<"RunCrewRun", 'String'>
    readonly title: FieldRef<"RunCrewRun", 'String'>
    readonly date: FieldRef<"RunCrewRun", 'DateTime'>
    readonly startTime: FieldRef<"RunCrewRun", 'String'>
    readonly location: FieldRef<"RunCrewRun", 'String'>
    readonly address: FieldRef<"RunCrewRun", 'String'>
    readonly totalMiles: FieldRef<"RunCrewRun", 'Float'>
    readonly pace: FieldRef<"RunCrewRun", 'String'>
    readonly stravaMapUrl: FieldRef<"RunCrewRun", 'String'>
    readonly description: FieldRef<"RunCrewRun", 'String'>
    readonly createdAt: FieldRef<"RunCrewRun", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewRun findUnique
   */
  export type RunCrewRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRun to fetch.
     */
    where: RunCrewRunWhereUniqueInput
  }

  /**
   * RunCrewRun findUniqueOrThrow
   */
  export type RunCrewRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRun to fetch.
     */
    where: RunCrewRunWhereUniqueInput
  }

  /**
   * RunCrewRun findFirst
   */
  export type RunCrewRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRun to fetch.
     */
    where?: RunCrewRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRuns to fetch.
     */
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewRuns.
     */
    cursor?: RunCrewRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewRuns.
     */
    distinct?: RunCrewRunScalarFieldEnum | RunCrewRunScalarFieldEnum[]
  }

  /**
   * RunCrewRun findFirstOrThrow
   */
  export type RunCrewRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRun to fetch.
     */
    where?: RunCrewRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRuns to fetch.
     */
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewRuns.
     */
    cursor?: RunCrewRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewRuns.
     */
    distinct?: RunCrewRunScalarFieldEnum | RunCrewRunScalarFieldEnum[]
  }

  /**
   * RunCrewRun findMany
   */
  export type RunCrewRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRuns to fetch.
     */
    where?: RunCrewRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRuns to fetch.
     */
    orderBy?: RunCrewRunOrderByWithRelationInput | RunCrewRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewRuns.
     */
    cursor?: RunCrewRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRuns.
     */
    skip?: number
    distinct?: RunCrewRunScalarFieldEnum | RunCrewRunScalarFieldEnum[]
  }

  /**
   * RunCrewRun create
   */
  export type RunCrewRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewRun.
     */
    data: XOR<RunCrewRunCreateInput, RunCrewRunUncheckedCreateInput>
  }

  /**
   * RunCrewRun createMany
   */
  export type RunCrewRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewRuns.
     */
    data: RunCrewRunCreateManyInput | RunCrewRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewRun createManyAndReturn
   */
  export type RunCrewRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewRuns.
     */
    data: RunCrewRunCreateManyInput | RunCrewRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewRun update
   */
  export type RunCrewRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewRun.
     */
    data: XOR<RunCrewRunUpdateInput, RunCrewRunUncheckedUpdateInput>
    /**
     * Choose, which RunCrewRun to update.
     */
    where: RunCrewRunWhereUniqueInput
  }

  /**
   * RunCrewRun updateMany
   */
  export type RunCrewRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewRuns.
     */
    data: XOR<RunCrewRunUpdateManyMutationInput, RunCrewRunUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewRuns to update
     */
    where?: RunCrewRunWhereInput
    /**
     * Limit how many RunCrewRuns to update.
     */
    limit?: number
  }

  /**
   * RunCrewRun updateManyAndReturn
   */
  export type RunCrewRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewRuns.
     */
    data: XOR<RunCrewRunUpdateManyMutationInput, RunCrewRunUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewRuns to update
     */
    where?: RunCrewRunWhereInput
    /**
     * Limit how many RunCrewRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewRun upsert
   */
  export type RunCrewRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewRun to update in case it exists.
     */
    where: RunCrewRunWhereUniqueInput
    /**
     * In case the RunCrewRun found by the `where` argument doesn't exist, create a new RunCrewRun with this data.
     */
    create: XOR<RunCrewRunCreateInput, RunCrewRunUncheckedCreateInput>
    /**
     * In case the RunCrewRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewRunUpdateInput, RunCrewRunUncheckedUpdateInput>
  }

  /**
   * RunCrewRun delete
   */
  export type RunCrewRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
    /**
     * Filter which RunCrewRun to delete.
     */
    where: RunCrewRunWhereUniqueInput
  }

  /**
   * RunCrewRun deleteMany
   */
  export type RunCrewRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewRuns to delete
     */
    where?: RunCrewRunWhereInput
    /**
     * Limit how many RunCrewRuns to delete.
     */
    limit?: number
  }

  /**
   * RunCrewRun.rsvps
   */
  export type RunCrewRun$rsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    where?: RunCrewRunRSVPWhereInput
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    cursor?: RunCrewRunRSVPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewRunRSVPScalarFieldEnum | RunCrewRunRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewRun without action
   */
  export type RunCrewRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRun
     */
    select?: RunCrewRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRun
     */
    omit?: RunCrewRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewRunRSVP
   */

  export type AggregateRunCrewRunRSVP = {
    _count: RunCrewRunRSVPCountAggregateOutputType | null
    _min: RunCrewRunRSVPMinAggregateOutputType | null
    _max: RunCrewRunRSVPMaxAggregateOutputType | null
  }

  export type RunCrewRunRSVPMinAggregateOutputType = {
    id: string | null
    runId: string | null
    athleteId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type RunCrewRunRSVPMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    athleteId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type RunCrewRunRSVPCountAggregateOutputType = {
    id: number
    runId: number
    athleteId: number
    status: number
    createdAt: number
    _all: number
  }


  export type RunCrewRunRSVPMinAggregateInputType = {
    id?: true
    runId?: true
    athleteId?: true
    status?: true
    createdAt?: true
  }

  export type RunCrewRunRSVPMaxAggregateInputType = {
    id?: true
    runId?: true
    athleteId?: true
    status?: true
    createdAt?: true
  }

  export type RunCrewRunRSVPCountAggregateInputType = {
    id?: true
    runId?: true
    athleteId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type RunCrewRunRSVPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewRunRSVP to aggregate.
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRunRSVPS to fetch.
     */
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewRunRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRunRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRunRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewRunRSVPS
    **/
    _count?: true | RunCrewRunRSVPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewRunRSVPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewRunRSVPMaxAggregateInputType
  }

  export type GetRunCrewRunRSVPAggregateType<T extends RunCrewRunRSVPAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewRunRSVP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewRunRSVP[P]>
      : GetScalarType<T[P], AggregateRunCrewRunRSVP[P]>
  }




  export type RunCrewRunRSVPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewRunRSVPWhereInput
    orderBy?: RunCrewRunRSVPOrderByWithAggregationInput | RunCrewRunRSVPOrderByWithAggregationInput[]
    by: RunCrewRunRSVPScalarFieldEnum[] | RunCrewRunRSVPScalarFieldEnum
    having?: RunCrewRunRSVPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewRunRSVPCountAggregateInputType | true
    _min?: RunCrewRunRSVPMinAggregateInputType
    _max?: RunCrewRunRSVPMaxAggregateInputType
  }

  export type RunCrewRunRSVPGroupByOutputType = {
    id: string
    runId: string
    athleteId: string
    status: string
    createdAt: Date
    _count: RunCrewRunRSVPCountAggregateOutputType | null
    _min: RunCrewRunRSVPMinAggregateOutputType | null
    _max: RunCrewRunRSVPMaxAggregateOutputType | null
  }

  type GetRunCrewRunRSVPGroupByPayload<T extends RunCrewRunRSVPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewRunRSVPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewRunRSVPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewRunRSVPGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewRunRSVPGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewRunRSVPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRunRSVP"]>

  export type RunCrewRunRSVPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRunRSVP"]>

  export type RunCrewRunRSVPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewRunRSVP"]>

  export type RunCrewRunRSVPSelectScalar = {
    id?: boolean
    runId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type RunCrewRunRSVPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "athleteId" | "status" | "createdAt", ExtArgs["result"]["runCrewRunRSVP"]>
  export type RunCrewRunRSVPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewRunRSVPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewRunRSVPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | RunCrewRunDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewRunRSVPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewRunRSVP"
    objects: {
      run: Prisma.$RunCrewRunPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      athleteId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["runCrewRunRSVP"]>
    composites: {}
  }

  type RunCrewRunRSVPGetPayload<S extends boolean | null | undefined | RunCrewRunRSVPDefaultArgs> = $Result.GetResult<Prisma.$RunCrewRunRSVPPayload, S>

  type RunCrewRunRSVPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewRunRSVPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewRunRSVPCountAggregateInputType | true
    }

  export interface RunCrewRunRSVPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewRunRSVP'], meta: { name: 'RunCrewRunRSVP' } }
    /**
     * Find zero or one RunCrewRunRSVP that matches the filter.
     * @param {RunCrewRunRSVPFindUniqueArgs} args - Arguments to find a RunCrewRunRSVP
     * @example
     * // Get one RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewRunRSVPFindUniqueArgs>(args: SelectSubset<T, RunCrewRunRSVPFindUniqueArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewRunRSVP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewRunRSVPFindUniqueOrThrowArgs} args - Arguments to find a RunCrewRunRSVP
     * @example
     * // Get one RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewRunRSVPFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewRunRSVPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewRunRSVP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPFindFirstArgs} args - Arguments to find a RunCrewRunRSVP
     * @example
     * // Get one RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewRunRSVPFindFirstArgs>(args?: SelectSubset<T, RunCrewRunRSVPFindFirstArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewRunRSVP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPFindFirstOrThrowArgs} args - Arguments to find a RunCrewRunRSVP
     * @example
     * // Get one RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewRunRSVPFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewRunRSVPFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewRunRSVPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewRunRSVPS
     * const runCrewRunRSVPS = await prisma.runCrewRunRSVP.findMany()
     * 
     * // Get first 10 RunCrewRunRSVPS
     * const runCrewRunRSVPS = await prisma.runCrewRunRSVP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewRunRSVPWithIdOnly = await prisma.runCrewRunRSVP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewRunRSVPFindManyArgs>(args?: SelectSubset<T, RunCrewRunRSVPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewRunRSVP.
     * @param {RunCrewRunRSVPCreateArgs} args - Arguments to create a RunCrewRunRSVP.
     * @example
     * // Create one RunCrewRunRSVP
     * const RunCrewRunRSVP = await prisma.runCrewRunRSVP.create({
     *   data: {
     *     // ... data to create a RunCrewRunRSVP
     *   }
     * })
     * 
     */
    create<T extends RunCrewRunRSVPCreateArgs>(args: SelectSubset<T, RunCrewRunRSVPCreateArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewRunRSVPS.
     * @param {RunCrewRunRSVPCreateManyArgs} args - Arguments to create many RunCrewRunRSVPS.
     * @example
     * // Create many RunCrewRunRSVPS
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewRunRSVPCreateManyArgs>(args?: SelectSubset<T, RunCrewRunRSVPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewRunRSVPS and returns the data saved in the database.
     * @param {RunCrewRunRSVPCreateManyAndReturnArgs} args - Arguments to create many RunCrewRunRSVPS.
     * @example
     * // Create many RunCrewRunRSVPS
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewRunRSVPS and only return the `id`
     * const runCrewRunRSVPWithIdOnly = await prisma.runCrewRunRSVP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewRunRSVPCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewRunRSVPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewRunRSVP.
     * @param {RunCrewRunRSVPDeleteArgs} args - Arguments to delete one RunCrewRunRSVP.
     * @example
     * // Delete one RunCrewRunRSVP
     * const RunCrewRunRSVP = await prisma.runCrewRunRSVP.delete({
     *   where: {
     *     // ... filter to delete one RunCrewRunRSVP
     *   }
     * })
     * 
     */
    delete<T extends RunCrewRunRSVPDeleteArgs>(args: SelectSubset<T, RunCrewRunRSVPDeleteArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewRunRSVP.
     * @param {RunCrewRunRSVPUpdateArgs} args - Arguments to update one RunCrewRunRSVP.
     * @example
     * // Update one RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewRunRSVPUpdateArgs>(args: SelectSubset<T, RunCrewRunRSVPUpdateArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewRunRSVPS.
     * @param {RunCrewRunRSVPDeleteManyArgs} args - Arguments to filter RunCrewRunRSVPS to delete.
     * @example
     * // Delete a few RunCrewRunRSVPS
     * const { count } = await prisma.runCrewRunRSVP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewRunRSVPDeleteManyArgs>(args?: SelectSubset<T, RunCrewRunRSVPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewRunRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewRunRSVPS
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewRunRSVPUpdateManyArgs>(args: SelectSubset<T, RunCrewRunRSVPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewRunRSVPS and returns the data updated in the database.
     * @param {RunCrewRunRSVPUpdateManyAndReturnArgs} args - Arguments to update many RunCrewRunRSVPS.
     * @example
     * // Update many RunCrewRunRSVPS
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewRunRSVPS and only return the `id`
     * const runCrewRunRSVPWithIdOnly = await prisma.runCrewRunRSVP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewRunRSVPUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewRunRSVPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewRunRSVP.
     * @param {RunCrewRunRSVPUpsertArgs} args - Arguments to update or create a RunCrewRunRSVP.
     * @example
     * // Update or create a RunCrewRunRSVP
     * const runCrewRunRSVP = await prisma.runCrewRunRSVP.upsert({
     *   create: {
     *     // ... data to create a RunCrewRunRSVP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewRunRSVP we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewRunRSVPUpsertArgs>(args: SelectSubset<T, RunCrewRunRSVPUpsertArgs<ExtArgs>>): Prisma__RunCrewRunRSVPClient<$Result.GetResult<Prisma.$RunCrewRunRSVPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewRunRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPCountArgs} args - Arguments to filter RunCrewRunRSVPS to count.
     * @example
     * // Count the number of RunCrewRunRSVPS
     * const count = await prisma.runCrewRunRSVP.count({
     *   where: {
     *     // ... the filter for the RunCrewRunRSVPS we want to count
     *   }
     * })
    **/
    count<T extends RunCrewRunRSVPCountArgs>(
      args?: Subset<T, RunCrewRunRSVPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewRunRSVPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewRunRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewRunRSVPAggregateArgs>(args: Subset<T, RunCrewRunRSVPAggregateArgs>): Prisma.PrismaPromise<GetRunCrewRunRSVPAggregateType<T>>

    /**
     * Group by RunCrewRunRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewRunRSVPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewRunRSVPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewRunRSVPGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewRunRSVPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewRunRSVPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewRunRSVPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewRunRSVP model
   */
  readonly fields: RunCrewRunRSVPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewRunRSVP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewRunRSVPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends RunCrewRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewRunDefaultArgs<ExtArgs>>): Prisma__RunCrewRunClient<$Result.GetResult<Prisma.$RunCrewRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewRunRSVP model
   */
  interface RunCrewRunRSVPFieldRefs {
    readonly id: FieldRef<"RunCrewRunRSVP", 'String'>
    readonly runId: FieldRef<"RunCrewRunRSVP", 'String'>
    readonly athleteId: FieldRef<"RunCrewRunRSVP", 'String'>
    readonly status: FieldRef<"RunCrewRunRSVP", 'String'>
    readonly createdAt: FieldRef<"RunCrewRunRSVP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewRunRSVP findUnique
   */
  export type RunCrewRunRSVPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRunRSVP to fetch.
     */
    where: RunCrewRunRSVPWhereUniqueInput
  }

  /**
   * RunCrewRunRSVP findUniqueOrThrow
   */
  export type RunCrewRunRSVPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRunRSVP to fetch.
     */
    where: RunCrewRunRSVPWhereUniqueInput
  }

  /**
   * RunCrewRunRSVP findFirst
   */
  export type RunCrewRunRSVPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRunRSVP to fetch.
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRunRSVPS to fetch.
     */
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewRunRSVPS.
     */
    cursor?: RunCrewRunRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRunRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRunRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewRunRSVPS.
     */
    distinct?: RunCrewRunRSVPScalarFieldEnum | RunCrewRunRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewRunRSVP findFirstOrThrow
   */
  export type RunCrewRunRSVPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRunRSVP to fetch.
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRunRSVPS to fetch.
     */
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewRunRSVPS.
     */
    cursor?: RunCrewRunRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRunRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRunRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewRunRSVPS.
     */
    distinct?: RunCrewRunRSVPScalarFieldEnum | RunCrewRunRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewRunRSVP findMany
   */
  export type RunCrewRunRSVPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewRunRSVPS to fetch.
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewRunRSVPS to fetch.
     */
    orderBy?: RunCrewRunRSVPOrderByWithRelationInput | RunCrewRunRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewRunRSVPS.
     */
    cursor?: RunCrewRunRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewRunRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewRunRSVPS.
     */
    skip?: number
    distinct?: RunCrewRunRSVPScalarFieldEnum | RunCrewRunRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewRunRSVP create
   */
  export type RunCrewRunRSVPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewRunRSVP.
     */
    data: XOR<RunCrewRunRSVPCreateInput, RunCrewRunRSVPUncheckedCreateInput>
  }

  /**
   * RunCrewRunRSVP createMany
   */
  export type RunCrewRunRSVPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewRunRSVPS.
     */
    data: RunCrewRunRSVPCreateManyInput | RunCrewRunRSVPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewRunRSVP createManyAndReturn
   */
  export type RunCrewRunRSVPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewRunRSVPS.
     */
    data: RunCrewRunRSVPCreateManyInput | RunCrewRunRSVPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewRunRSVP update
   */
  export type RunCrewRunRSVPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewRunRSVP.
     */
    data: XOR<RunCrewRunRSVPUpdateInput, RunCrewRunRSVPUncheckedUpdateInput>
    /**
     * Choose, which RunCrewRunRSVP to update.
     */
    where: RunCrewRunRSVPWhereUniqueInput
  }

  /**
   * RunCrewRunRSVP updateMany
   */
  export type RunCrewRunRSVPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewRunRSVPS.
     */
    data: XOR<RunCrewRunRSVPUpdateManyMutationInput, RunCrewRunRSVPUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewRunRSVPS to update
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * Limit how many RunCrewRunRSVPS to update.
     */
    limit?: number
  }

  /**
   * RunCrewRunRSVP updateManyAndReturn
   */
  export type RunCrewRunRSVPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewRunRSVPS.
     */
    data: XOR<RunCrewRunRSVPUpdateManyMutationInput, RunCrewRunRSVPUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewRunRSVPS to update
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * Limit how many RunCrewRunRSVPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewRunRSVP upsert
   */
  export type RunCrewRunRSVPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewRunRSVP to update in case it exists.
     */
    where: RunCrewRunRSVPWhereUniqueInput
    /**
     * In case the RunCrewRunRSVP found by the `where` argument doesn't exist, create a new RunCrewRunRSVP with this data.
     */
    create: XOR<RunCrewRunRSVPCreateInput, RunCrewRunRSVPUncheckedCreateInput>
    /**
     * In case the RunCrewRunRSVP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewRunRSVPUpdateInput, RunCrewRunRSVPUncheckedUpdateInput>
  }

  /**
   * RunCrewRunRSVP delete
   */
  export type RunCrewRunRSVPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
    /**
     * Filter which RunCrewRunRSVP to delete.
     */
    where: RunCrewRunRSVPWhereUniqueInput
  }

  /**
   * RunCrewRunRSVP deleteMany
   */
  export type RunCrewRunRSVPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewRunRSVPS to delete
     */
    where?: RunCrewRunRSVPWhereInput
    /**
     * Limit how many RunCrewRunRSVPS to delete.
     */
    limit?: number
  }

  /**
   * RunCrewRunRSVP without action
   */
  export type RunCrewRunRSVPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewRunRSVP
     */
    select?: RunCrewRunRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewRunRSVP
     */
    omit?: RunCrewRunRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewRunRSVPInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewEvent
   */

  export type AggregateRunCrewEvent = {
    _count: RunCrewEventCountAggregateOutputType | null
    _min: RunCrewEventMinAggregateOutputType | null
    _max: RunCrewEventMaxAggregateOutputType | null
  }

  export type RunCrewEventMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    organizerId: string | null
    title: string | null
    date: Date | null
    time: string | null
    location: string | null
    address: string | null
    description: string | null
    eventType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewEventMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    organizerId: string | null
    title: string | null
    date: Date | null
    time: string | null
    location: string | null
    address: string | null
    description: string | null
    eventType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RunCrewEventCountAggregateOutputType = {
    id: number
    runCrewId: number
    organizerId: number
    title: number
    date: number
    time: number
    location: number
    address: number
    description: number
    eventType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RunCrewEventMinAggregateInputType = {
    id?: true
    runCrewId?: true
    organizerId?: true
    title?: true
    date?: true
    time?: true
    location?: true
    address?: true
    description?: true
    eventType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewEventMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    organizerId?: true
    title?: true
    date?: true
    time?: true
    location?: true
    address?: true
    description?: true
    eventType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RunCrewEventCountAggregateInputType = {
    id?: true
    runCrewId?: true
    organizerId?: true
    title?: true
    date?: true
    time?: true
    location?: true
    address?: true
    description?: true
    eventType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RunCrewEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewEvent to aggregate.
     */
    where?: RunCrewEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEvents to fetch.
     */
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewEvents
    **/
    _count?: true | RunCrewEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewEventMaxAggregateInputType
  }

  export type GetRunCrewEventAggregateType<T extends RunCrewEventAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewEvent[P]>
      : GetScalarType<T[P], AggregateRunCrewEvent[P]>
  }




  export type RunCrewEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventWhereInput
    orderBy?: RunCrewEventOrderByWithAggregationInput | RunCrewEventOrderByWithAggregationInput[]
    by: RunCrewEventScalarFieldEnum[] | RunCrewEventScalarFieldEnum
    having?: RunCrewEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewEventCountAggregateInputType | true
    _min?: RunCrewEventMinAggregateInputType
    _max?: RunCrewEventMaxAggregateInputType
  }

  export type RunCrewEventGroupByOutputType = {
    id: string
    runCrewId: string
    organizerId: string
    title: string
    date: Date
    time: string
    location: string
    address: string | null
    description: string | null
    eventType: string | null
    createdAt: Date
    updatedAt: Date
    _count: RunCrewEventCountAggregateOutputType | null
    _min: RunCrewEventMinAggregateOutputType | null
    _max: RunCrewEventMaxAggregateOutputType | null
  }

  type GetRunCrewEventGroupByPayload<T extends RunCrewEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewEventGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewEventGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    organizerId?: boolean
    title?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    address?: boolean
    description?: boolean
    eventType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
    rsvps?: boolean | RunCrewEvent$rsvpsArgs<ExtArgs>
    _count?: boolean | RunCrewEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEvent"]>

  export type RunCrewEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    organizerId?: boolean
    title?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    address?: boolean
    description?: boolean
    eventType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEvent"]>

  export type RunCrewEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    organizerId?: boolean
    title?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    address?: boolean
    description?: boolean
    eventType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEvent"]>

  export type RunCrewEventSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    organizerId?: boolean
    title?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    address?: boolean
    description?: boolean
    eventType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RunCrewEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "organizerId" | "title" | "date" | "time" | "location" | "address" | "description" | "eventType" | "createdAt" | "updatedAt", ExtArgs["result"]["runCrewEvent"]>
  export type RunCrewEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
    rsvps?: boolean | RunCrewEvent$rsvpsArgs<ExtArgs>
    _count?: boolean | RunCrewEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunCrewEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    organizer?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewEvent"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      organizer: Prisma.$AthletePayload<ExtArgs>
      rsvps: Prisma.$RunCrewEventRSVPPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      organizerId: string
      title: string
      date: Date
      time: string
      location: string
      address: string | null
      description: string | null
      eventType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["runCrewEvent"]>
    composites: {}
  }

  type RunCrewEventGetPayload<S extends boolean | null | undefined | RunCrewEventDefaultArgs> = $Result.GetResult<Prisma.$RunCrewEventPayload, S>

  type RunCrewEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewEventCountAggregateInputType | true
    }

  export interface RunCrewEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewEvent'], meta: { name: 'RunCrewEvent' } }
    /**
     * Find zero or one RunCrewEvent that matches the filter.
     * @param {RunCrewEventFindUniqueArgs} args - Arguments to find a RunCrewEvent
     * @example
     * // Get one RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewEventFindUniqueArgs>(args: SelectSubset<T, RunCrewEventFindUniqueArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewEventFindUniqueOrThrowArgs} args - Arguments to find a RunCrewEvent
     * @example
     * // Get one RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewEventFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventFindFirstArgs} args - Arguments to find a RunCrewEvent
     * @example
     * // Get one RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewEventFindFirstArgs>(args?: SelectSubset<T, RunCrewEventFindFirstArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventFindFirstOrThrowArgs} args - Arguments to find a RunCrewEvent
     * @example
     * // Get one RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewEventFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewEvents
     * const runCrewEvents = await prisma.runCrewEvent.findMany()
     * 
     * // Get first 10 RunCrewEvents
     * const runCrewEvents = await prisma.runCrewEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewEventWithIdOnly = await prisma.runCrewEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewEventFindManyArgs>(args?: SelectSubset<T, RunCrewEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewEvent.
     * @param {RunCrewEventCreateArgs} args - Arguments to create a RunCrewEvent.
     * @example
     * // Create one RunCrewEvent
     * const RunCrewEvent = await prisma.runCrewEvent.create({
     *   data: {
     *     // ... data to create a RunCrewEvent
     *   }
     * })
     * 
     */
    create<T extends RunCrewEventCreateArgs>(args: SelectSubset<T, RunCrewEventCreateArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewEvents.
     * @param {RunCrewEventCreateManyArgs} args - Arguments to create many RunCrewEvents.
     * @example
     * // Create many RunCrewEvents
     * const runCrewEvent = await prisma.runCrewEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewEventCreateManyArgs>(args?: SelectSubset<T, RunCrewEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewEvents and returns the data saved in the database.
     * @param {RunCrewEventCreateManyAndReturnArgs} args - Arguments to create many RunCrewEvents.
     * @example
     * // Create many RunCrewEvents
     * const runCrewEvent = await prisma.runCrewEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewEvents and only return the `id`
     * const runCrewEventWithIdOnly = await prisma.runCrewEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewEventCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewEvent.
     * @param {RunCrewEventDeleteArgs} args - Arguments to delete one RunCrewEvent.
     * @example
     * // Delete one RunCrewEvent
     * const RunCrewEvent = await prisma.runCrewEvent.delete({
     *   where: {
     *     // ... filter to delete one RunCrewEvent
     *   }
     * })
     * 
     */
    delete<T extends RunCrewEventDeleteArgs>(args: SelectSubset<T, RunCrewEventDeleteArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewEvent.
     * @param {RunCrewEventUpdateArgs} args - Arguments to update one RunCrewEvent.
     * @example
     * // Update one RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewEventUpdateArgs>(args: SelectSubset<T, RunCrewEventUpdateArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewEvents.
     * @param {RunCrewEventDeleteManyArgs} args - Arguments to filter RunCrewEvents to delete.
     * @example
     * // Delete a few RunCrewEvents
     * const { count } = await prisma.runCrewEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewEventDeleteManyArgs>(args?: SelectSubset<T, RunCrewEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewEvents
     * const runCrewEvent = await prisma.runCrewEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewEventUpdateManyArgs>(args: SelectSubset<T, RunCrewEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewEvents and returns the data updated in the database.
     * @param {RunCrewEventUpdateManyAndReturnArgs} args - Arguments to update many RunCrewEvents.
     * @example
     * // Update many RunCrewEvents
     * const runCrewEvent = await prisma.runCrewEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewEvents and only return the `id`
     * const runCrewEventWithIdOnly = await prisma.runCrewEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewEventUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewEvent.
     * @param {RunCrewEventUpsertArgs} args - Arguments to update or create a RunCrewEvent.
     * @example
     * // Update or create a RunCrewEvent
     * const runCrewEvent = await prisma.runCrewEvent.upsert({
     *   create: {
     *     // ... data to create a RunCrewEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewEvent we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewEventUpsertArgs>(args: SelectSubset<T, RunCrewEventUpsertArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventCountArgs} args - Arguments to filter RunCrewEvents to count.
     * @example
     * // Count the number of RunCrewEvents
     * const count = await prisma.runCrewEvent.count({
     *   where: {
     *     // ... the filter for the RunCrewEvents we want to count
     *   }
     * })
    **/
    count<T extends RunCrewEventCountArgs>(
      args?: Subset<T, RunCrewEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewEventAggregateArgs>(args: Subset<T, RunCrewEventAggregateArgs>): Prisma.PrismaPromise<GetRunCrewEventAggregateType<T>>

    /**
     * Group by RunCrewEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewEventGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewEvent model
   */
  readonly fields: RunCrewEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organizer<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rsvps<T extends RunCrewEvent$rsvpsArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewEvent$rsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewEvent model
   */
  interface RunCrewEventFieldRefs {
    readonly id: FieldRef<"RunCrewEvent", 'String'>
    readonly runCrewId: FieldRef<"RunCrewEvent", 'String'>
    readonly organizerId: FieldRef<"RunCrewEvent", 'String'>
    readonly title: FieldRef<"RunCrewEvent", 'String'>
    readonly date: FieldRef<"RunCrewEvent", 'DateTime'>
    readonly time: FieldRef<"RunCrewEvent", 'String'>
    readonly location: FieldRef<"RunCrewEvent", 'String'>
    readonly address: FieldRef<"RunCrewEvent", 'String'>
    readonly description: FieldRef<"RunCrewEvent", 'String'>
    readonly eventType: FieldRef<"RunCrewEvent", 'String'>
    readonly createdAt: FieldRef<"RunCrewEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"RunCrewEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewEvent findUnique
   */
  export type RunCrewEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEvent to fetch.
     */
    where: RunCrewEventWhereUniqueInput
  }

  /**
   * RunCrewEvent findUniqueOrThrow
   */
  export type RunCrewEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEvent to fetch.
     */
    where: RunCrewEventWhereUniqueInput
  }

  /**
   * RunCrewEvent findFirst
   */
  export type RunCrewEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEvent to fetch.
     */
    where?: RunCrewEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEvents to fetch.
     */
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewEvents.
     */
    cursor?: RunCrewEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewEvents.
     */
    distinct?: RunCrewEventScalarFieldEnum | RunCrewEventScalarFieldEnum[]
  }

  /**
   * RunCrewEvent findFirstOrThrow
   */
  export type RunCrewEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEvent to fetch.
     */
    where?: RunCrewEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEvents to fetch.
     */
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewEvents.
     */
    cursor?: RunCrewEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewEvents.
     */
    distinct?: RunCrewEventScalarFieldEnum | RunCrewEventScalarFieldEnum[]
  }

  /**
   * RunCrewEvent findMany
   */
  export type RunCrewEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEvents to fetch.
     */
    where?: RunCrewEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEvents to fetch.
     */
    orderBy?: RunCrewEventOrderByWithRelationInput | RunCrewEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewEvents.
     */
    cursor?: RunCrewEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEvents.
     */
    skip?: number
    distinct?: RunCrewEventScalarFieldEnum | RunCrewEventScalarFieldEnum[]
  }

  /**
   * RunCrewEvent create
   */
  export type RunCrewEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewEvent.
     */
    data: XOR<RunCrewEventCreateInput, RunCrewEventUncheckedCreateInput>
  }

  /**
   * RunCrewEvent createMany
   */
  export type RunCrewEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewEvents.
     */
    data: RunCrewEventCreateManyInput | RunCrewEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewEvent createManyAndReturn
   */
  export type RunCrewEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewEvents.
     */
    data: RunCrewEventCreateManyInput | RunCrewEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewEvent update
   */
  export type RunCrewEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewEvent.
     */
    data: XOR<RunCrewEventUpdateInput, RunCrewEventUncheckedUpdateInput>
    /**
     * Choose, which RunCrewEvent to update.
     */
    where: RunCrewEventWhereUniqueInput
  }

  /**
   * RunCrewEvent updateMany
   */
  export type RunCrewEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewEvents.
     */
    data: XOR<RunCrewEventUpdateManyMutationInput, RunCrewEventUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewEvents to update
     */
    where?: RunCrewEventWhereInput
    /**
     * Limit how many RunCrewEvents to update.
     */
    limit?: number
  }

  /**
   * RunCrewEvent updateManyAndReturn
   */
  export type RunCrewEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewEvents.
     */
    data: XOR<RunCrewEventUpdateManyMutationInput, RunCrewEventUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewEvents to update
     */
    where?: RunCrewEventWhereInput
    /**
     * Limit how many RunCrewEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewEvent upsert
   */
  export type RunCrewEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewEvent to update in case it exists.
     */
    where: RunCrewEventWhereUniqueInput
    /**
     * In case the RunCrewEvent found by the `where` argument doesn't exist, create a new RunCrewEvent with this data.
     */
    create: XOR<RunCrewEventCreateInput, RunCrewEventUncheckedCreateInput>
    /**
     * In case the RunCrewEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewEventUpdateInput, RunCrewEventUncheckedUpdateInput>
  }

  /**
   * RunCrewEvent delete
   */
  export type RunCrewEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
    /**
     * Filter which RunCrewEvent to delete.
     */
    where: RunCrewEventWhereUniqueInput
  }

  /**
   * RunCrewEvent deleteMany
   */
  export type RunCrewEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewEvents to delete
     */
    where?: RunCrewEventWhereInput
    /**
     * Limit how many RunCrewEvents to delete.
     */
    limit?: number
  }

  /**
   * RunCrewEvent.rsvps
   */
  export type RunCrewEvent$rsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    where?: RunCrewEventRSVPWhereInput
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    cursor?: RunCrewEventRSVPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunCrewEventRSVPScalarFieldEnum | RunCrewEventRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewEvent without action
   */
  export type RunCrewEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEvent
     */
    select?: RunCrewEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEvent
     */
    omit?: RunCrewEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewEventRSVP
   */

  export type AggregateRunCrewEventRSVP = {
    _count: RunCrewEventRSVPCountAggregateOutputType | null
    _min: RunCrewEventRSVPMinAggregateOutputType | null
    _max: RunCrewEventRSVPMaxAggregateOutputType | null
  }

  export type RunCrewEventRSVPMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    athleteId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type RunCrewEventRSVPMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    athleteId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type RunCrewEventRSVPCountAggregateOutputType = {
    id: number
    eventId: number
    athleteId: number
    status: number
    createdAt: number
    _all: number
  }


  export type RunCrewEventRSVPMinAggregateInputType = {
    id?: true
    eventId?: true
    athleteId?: true
    status?: true
    createdAt?: true
  }

  export type RunCrewEventRSVPMaxAggregateInputType = {
    id?: true
    eventId?: true
    athleteId?: true
    status?: true
    createdAt?: true
  }

  export type RunCrewEventRSVPCountAggregateInputType = {
    id?: true
    eventId?: true
    athleteId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type RunCrewEventRSVPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewEventRSVP to aggregate.
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEventRSVPS to fetch.
     */
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewEventRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEventRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEventRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewEventRSVPS
    **/
    _count?: true | RunCrewEventRSVPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewEventRSVPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewEventRSVPMaxAggregateInputType
  }

  export type GetRunCrewEventRSVPAggregateType<T extends RunCrewEventRSVPAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewEventRSVP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewEventRSVP[P]>
      : GetScalarType<T[P], AggregateRunCrewEventRSVP[P]>
  }




  export type RunCrewEventRSVPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewEventRSVPWhereInput
    orderBy?: RunCrewEventRSVPOrderByWithAggregationInput | RunCrewEventRSVPOrderByWithAggregationInput[]
    by: RunCrewEventRSVPScalarFieldEnum[] | RunCrewEventRSVPScalarFieldEnum
    having?: RunCrewEventRSVPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewEventRSVPCountAggregateInputType | true
    _min?: RunCrewEventRSVPMinAggregateInputType
    _max?: RunCrewEventRSVPMaxAggregateInputType
  }

  export type RunCrewEventRSVPGroupByOutputType = {
    id: string
    eventId: string
    athleteId: string
    status: string
    createdAt: Date
    _count: RunCrewEventRSVPCountAggregateOutputType | null
    _min: RunCrewEventRSVPMinAggregateOutputType | null
    _max: RunCrewEventRSVPMaxAggregateOutputType | null
  }

  type GetRunCrewEventRSVPGroupByPayload<T extends RunCrewEventRSVPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewEventRSVPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewEventRSVPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewEventRSVPGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewEventRSVPGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewEventRSVPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEventRSVP"]>

  export type RunCrewEventRSVPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEventRSVP"]>

  export type RunCrewEventRSVPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewEventRSVP"]>

  export type RunCrewEventRSVPSelectScalar = {
    id?: boolean
    eventId?: boolean
    athleteId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type RunCrewEventRSVPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "athleteId" | "status" | "createdAt", ExtArgs["result"]["runCrewEventRSVP"]>
  export type RunCrewEventRSVPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewEventRSVPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewEventRSVPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | RunCrewEventDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewEventRSVPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewEventRSVP"
    objects: {
      event: Prisma.$RunCrewEventPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      athleteId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["runCrewEventRSVP"]>
    composites: {}
  }

  type RunCrewEventRSVPGetPayload<S extends boolean | null | undefined | RunCrewEventRSVPDefaultArgs> = $Result.GetResult<Prisma.$RunCrewEventRSVPPayload, S>

  type RunCrewEventRSVPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewEventRSVPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewEventRSVPCountAggregateInputType | true
    }

  export interface RunCrewEventRSVPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewEventRSVP'], meta: { name: 'RunCrewEventRSVP' } }
    /**
     * Find zero or one RunCrewEventRSVP that matches the filter.
     * @param {RunCrewEventRSVPFindUniqueArgs} args - Arguments to find a RunCrewEventRSVP
     * @example
     * // Get one RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewEventRSVPFindUniqueArgs>(args: SelectSubset<T, RunCrewEventRSVPFindUniqueArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewEventRSVP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewEventRSVPFindUniqueOrThrowArgs} args - Arguments to find a RunCrewEventRSVP
     * @example
     * // Get one RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewEventRSVPFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewEventRSVPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewEventRSVP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPFindFirstArgs} args - Arguments to find a RunCrewEventRSVP
     * @example
     * // Get one RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewEventRSVPFindFirstArgs>(args?: SelectSubset<T, RunCrewEventRSVPFindFirstArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewEventRSVP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPFindFirstOrThrowArgs} args - Arguments to find a RunCrewEventRSVP
     * @example
     * // Get one RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewEventRSVPFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewEventRSVPFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewEventRSVPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewEventRSVPS
     * const runCrewEventRSVPS = await prisma.runCrewEventRSVP.findMany()
     * 
     * // Get first 10 RunCrewEventRSVPS
     * const runCrewEventRSVPS = await prisma.runCrewEventRSVP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewEventRSVPWithIdOnly = await prisma.runCrewEventRSVP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewEventRSVPFindManyArgs>(args?: SelectSubset<T, RunCrewEventRSVPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewEventRSVP.
     * @param {RunCrewEventRSVPCreateArgs} args - Arguments to create a RunCrewEventRSVP.
     * @example
     * // Create one RunCrewEventRSVP
     * const RunCrewEventRSVP = await prisma.runCrewEventRSVP.create({
     *   data: {
     *     // ... data to create a RunCrewEventRSVP
     *   }
     * })
     * 
     */
    create<T extends RunCrewEventRSVPCreateArgs>(args: SelectSubset<T, RunCrewEventRSVPCreateArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewEventRSVPS.
     * @param {RunCrewEventRSVPCreateManyArgs} args - Arguments to create many RunCrewEventRSVPS.
     * @example
     * // Create many RunCrewEventRSVPS
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewEventRSVPCreateManyArgs>(args?: SelectSubset<T, RunCrewEventRSVPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewEventRSVPS and returns the data saved in the database.
     * @param {RunCrewEventRSVPCreateManyAndReturnArgs} args - Arguments to create many RunCrewEventRSVPS.
     * @example
     * // Create many RunCrewEventRSVPS
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewEventRSVPS and only return the `id`
     * const runCrewEventRSVPWithIdOnly = await prisma.runCrewEventRSVP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewEventRSVPCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewEventRSVPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewEventRSVP.
     * @param {RunCrewEventRSVPDeleteArgs} args - Arguments to delete one RunCrewEventRSVP.
     * @example
     * // Delete one RunCrewEventRSVP
     * const RunCrewEventRSVP = await prisma.runCrewEventRSVP.delete({
     *   where: {
     *     // ... filter to delete one RunCrewEventRSVP
     *   }
     * })
     * 
     */
    delete<T extends RunCrewEventRSVPDeleteArgs>(args: SelectSubset<T, RunCrewEventRSVPDeleteArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewEventRSVP.
     * @param {RunCrewEventRSVPUpdateArgs} args - Arguments to update one RunCrewEventRSVP.
     * @example
     * // Update one RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewEventRSVPUpdateArgs>(args: SelectSubset<T, RunCrewEventRSVPUpdateArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewEventRSVPS.
     * @param {RunCrewEventRSVPDeleteManyArgs} args - Arguments to filter RunCrewEventRSVPS to delete.
     * @example
     * // Delete a few RunCrewEventRSVPS
     * const { count } = await prisma.runCrewEventRSVP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewEventRSVPDeleteManyArgs>(args?: SelectSubset<T, RunCrewEventRSVPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewEventRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewEventRSVPS
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewEventRSVPUpdateManyArgs>(args: SelectSubset<T, RunCrewEventRSVPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewEventRSVPS and returns the data updated in the database.
     * @param {RunCrewEventRSVPUpdateManyAndReturnArgs} args - Arguments to update many RunCrewEventRSVPS.
     * @example
     * // Update many RunCrewEventRSVPS
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewEventRSVPS and only return the `id`
     * const runCrewEventRSVPWithIdOnly = await prisma.runCrewEventRSVP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewEventRSVPUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewEventRSVPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewEventRSVP.
     * @param {RunCrewEventRSVPUpsertArgs} args - Arguments to update or create a RunCrewEventRSVP.
     * @example
     * // Update or create a RunCrewEventRSVP
     * const runCrewEventRSVP = await prisma.runCrewEventRSVP.upsert({
     *   create: {
     *     // ... data to create a RunCrewEventRSVP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewEventRSVP we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewEventRSVPUpsertArgs>(args: SelectSubset<T, RunCrewEventRSVPUpsertArgs<ExtArgs>>): Prisma__RunCrewEventRSVPClient<$Result.GetResult<Prisma.$RunCrewEventRSVPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewEventRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPCountArgs} args - Arguments to filter RunCrewEventRSVPS to count.
     * @example
     * // Count the number of RunCrewEventRSVPS
     * const count = await prisma.runCrewEventRSVP.count({
     *   where: {
     *     // ... the filter for the RunCrewEventRSVPS we want to count
     *   }
     * })
    **/
    count<T extends RunCrewEventRSVPCountArgs>(
      args?: Subset<T, RunCrewEventRSVPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewEventRSVPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewEventRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewEventRSVPAggregateArgs>(args: Subset<T, RunCrewEventRSVPAggregateArgs>): Prisma.PrismaPromise<GetRunCrewEventRSVPAggregateType<T>>

    /**
     * Group by RunCrewEventRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewEventRSVPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewEventRSVPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewEventRSVPGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewEventRSVPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewEventRSVPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewEventRSVPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewEventRSVP model
   */
  readonly fields: RunCrewEventRSVPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewEventRSVP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewEventRSVPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends RunCrewEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewEventDefaultArgs<ExtArgs>>): Prisma__RunCrewEventClient<$Result.GetResult<Prisma.$RunCrewEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewEventRSVP model
   */
  interface RunCrewEventRSVPFieldRefs {
    readonly id: FieldRef<"RunCrewEventRSVP", 'String'>
    readonly eventId: FieldRef<"RunCrewEventRSVP", 'String'>
    readonly athleteId: FieldRef<"RunCrewEventRSVP", 'String'>
    readonly status: FieldRef<"RunCrewEventRSVP", 'String'>
    readonly createdAt: FieldRef<"RunCrewEventRSVP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewEventRSVP findUnique
   */
  export type RunCrewEventRSVPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEventRSVP to fetch.
     */
    where: RunCrewEventRSVPWhereUniqueInput
  }

  /**
   * RunCrewEventRSVP findUniqueOrThrow
   */
  export type RunCrewEventRSVPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEventRSVP to fetch.
     */
    where: RunCrewEventRSVPWhereUniqueInput
  }

  /**
   * RunCrewEventRSVP findFirst
   */
  export type RunCrewEventRSVPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEventRSVP to fetch.
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEventRSVPS to fetch.
     */
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewEventRSVPS.
     */
    cursor?: RunCrewEventRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEventRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEventRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewEventRSVPS.
     */
    distinct?: RunCrewEventRSVPScalarFieldEnum | RunCrewEventRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewEventRSVP findFirstOrThrow
   */
  export type RunCrewEventRSVPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEventRSVP to fetch.
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEventRSVPS to fetch.
     */
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewEventRSVPS.
     */
    cursor?: RunCrewEventRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEventRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEventRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewEventRSVPS.
     */
    distinct?: RunCrewEventRSVPScalarFieldEnum | RunCrewEventRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewEventRSVP findMany
   */
  export type RunCrewEventRSVPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewEventRSVPS to fetch.
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewEventRSVPS to fetch.
     */
    orderBy?: RunCrewEventRSVPOrderByWithRelationInput | RunCrewEventRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewEventRSVPS.
     */
    cursor?: RunCrewEventRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewEventRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewEventRSVPS.
     */
    skip?: number
    distinct?: RunCrewEventRSVPScalarFieldEnum | RunCrewEventRSVPScalarFieldEnum[]
  }

  /**
   * RunCrewEventRSVP create
   */
  export type RunCrewEventRSVPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewEventRSVP.
     */
    data: XOR<RunCrewEventRSVPCreateInput, RunCrewEventRSVPUncheckedCreateInput>
  }

  /**
   * RunCrewEventRSVP createMany
   */
  export type RunCrewEventRSVPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewEventRSVPS.
     */
    data: RunCrewEventRSVPCreateManyInput | RunCrewEventRSVPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewEventRSVP createManyAndReturn
   */
  export type RunCrewEventRSVPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewEventRSVPS.
     */
    data: RunCrewEventRSVPCreateManyInput | RunCrewEventRSVPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewEventRSVP update
   */
  export type RunCrewEventRSVPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewEventRSVP.
     */
    data: XOR<RunCrewEventRSVPUpdateInput, RunCrewEventRSVPUncheckedUpdateInput>
    /**
     * Choose, which RunCrewEventRSVP to update.
     */
    where: RunCrewEventRSVPWhereUniqueInput
  }

  /**
   * RunCrewEventRSVP updateMany
   */
  export type RunCrewEventRSVPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewEventRSVPS.
     */
    data: XOR<RunCrewEventRSVPUpdateManyMutationInput, RunCrewEventRSVPUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewEventRSVPS to update
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * Limit how many RunCrewEventRSVPS to update.
     */
    limit?: number
  }

  /**
   * RunCrewEventRSVP updateManyAndReturn
   */
  export type RunCrewEventRSVPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewEventRSVPS.
     */
    data: XOR<RunCrewEventRSVPUpdateManyMutationInput, RunCrewEventRSVPUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewEventRSVPS to update
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * Limit how many RunCrewEventRSVPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewEventRSVP upsert
   */
  export type RunCrewEventRSVPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewEventRSVP to update in case it exists.
     */
    where: RunCrewEventRSVPWhereUniqueInput
    /**
     * In case the RunCrewEventRSVP found by the `where` argument doesn't exist, create a new RunCrewEventRSVP with this data.
     */
    create: XOR<RunCrewEventRSVPCreateInput, RunCrewEventRSVPUncheckedCreateInput>
    /**
     * In case the RunCrewEventRSVP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewEventRSVPUpdateInput, RunCrewEventRSVPUncheckedUpdateInput>
  }

  /**
   * RunCrewEventRSVP delete
   */
  export type RunCrewEventRSVPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
    /**
     * Filter which RunCrewEventRSVP to delete.
     */
    where: RunCrewEventRSVPWhereUniqueInput
  }

  /**
   * RunCrewEventRSVP deleteMany
   */
  export type RunCrewEventRSVPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewEventRSVPS to delete
     */
    where?: RunCrewEventRSVPWhereInput
    /**
     * Limit how many RunCrewEventRSVPS to delete.
     */
    limit?: number
  }

  /**
   * RunCrewEventRSVP without action
   */
  export type RunCrewEventRSVPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewEventRSVP
     */
    select?: RunCrewEventRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewEventRSVP
     */
    omit?: RunCrewEventRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewEventRSVPInclude<ExtArgs> | null
  }


  /**
   * Model RunCrewManager
   */

  export type AggregateRunCrewManager = {
    _count: RunCrewManagerCountAggregateOutputType | null
    _min: RunCrewManagerMinAggregateOutputType | null
    _max: RunCrewManagerMaxAggregateOutputType | null
  }

  export type RunCrewManagerMinAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type RunCrewManagerMaxAggregateOutputType = {
    id: string | null
    runCrewId: string | null
    athleteId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type RunCrewManagerCountAggregateOutputType = {
    id: number
    runCrewId: number
    athleteId: number
    role: number
    createdAt: number
    _all: number
  }


  export type RunCrewManagerMinAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    role?: true
    createdAt?: true
  }

  export type RunCrewManagerMaxAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    role?: true
    createdAt?: true
  }

  export type RunCrewManagerCountAggregateInputType = {
    id?: true
    runCrewId?: true
    athleteId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type RunCrewManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewManager to aggregate.
     */
    where?: RunCrewManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewManagers to fetch.
     */
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCrewManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCrewManagers
    **/
    _count?: true | RunCrewManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCrewManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCrewManagerMaxAggregateInputType
  }

  export type GetRunCrewManagerAggregateType<T extends RunCrewManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCrewManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCrewManager[P]>
      : GetScalarType<T[P], AggregateRunCrewManager[P]>
  }




  export type RunCrewManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCrewManagerWhereInput
    orderBy?: RunCrewManagerOrderByWithAggregationInput | RunCrewManagerOrderByWithAggregationInput[]
    by: RunCrewManagerScalarFieldEnum[] | RunCrewManagerScalarFieldEnum
    having?: RunCrewManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCrewManagerCountAggregateInputType | true
    _min?: RunCrewManagerMinAggregateInputType
    _max?: RunCrewManagerMaxAggregateInputType
  }

  export type RunCrewManagerGroupByOutputType = {
    id: string
    runCrewId: string
    athleteId: string
    role: string
    createdAt: Date
    _count: RunCrewManagerCountAggregateOutputType | null
    _min: RunCrewManagerMinAggregateOutputType | null
    _max: RunCrewManagerMaxAggregateOutputType | null
  }

  type GetRunCrewManagerGroupByPayload<T extends RunCrewManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCrewManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCrewManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCrewManagerGroupByOutputType[P]>
            : GetScalarType<T[P], RunCrewManagerGroupByOutputType[P]>
        }
      >
    >


  export type RunCrewManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    role?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewManager"]>

  export type RunCrewManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    role?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewManager"]>

  export type RunCrewManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    role?: boolean
    createdAt?: boolean
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["runCrewManager"]>

  export type RunCrewManagerSelectScalar = {
    id?: boolean
    runCrewId?: boolean
    athleteId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type RunCrewManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runCrewId" | "athleteId" | "role" | "createdAt", ExtArgs["result"]["runCrewManager"]>
  export type RunCrewManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type RunCrewManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runCrew?: boolean | RunCrewDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $RunCrewManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCrewManager"
    objects: {
      runCrew: Prisma.$RunCrewPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runCrewId: string
      athleteId: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["runCrewManager"]>
    composites: {}
  }

  type RunCrewManagerGetPayload<S extends boolean | null | undefined | RunCrewManagerDefaultArgs> = $Result.GetResult<Prisma.$RunCrewManagerPayload, S>

  type RunCrewManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCrewManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCrewManagerCountAggregateInputType | true
    }

  export interface RunCrewManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCrewManager'], meta: { name: 'RunCrewManager' } }
    /**
     * Find zero or one RunCrewManager that matches the filter.
     * @param {RunCrewManagerFindUniqueArgs} args - Arguments to find a RunCrewManager
     * @example
     * // Get one RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCrewManagerFindUniqueArgs>(args: SelectSubset<T, RunCrewManagerFindUniqueArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCrewManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCrewManagerFindUniqueOrThrowArgs} args - Arguments to find a RunCrewManager
     * @example
     * // Get one RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCrewManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCrewManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerFindFirstArgs} args - Arguments to find a RunCrewManager
     * @example
     * // Get one RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCrewManagerFindFirstArgs>(args?: SelectSubset<T, RunCrewManagerFindFirstArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCrewManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerFindFirstOrThrowArgs} args - Arguments to find a RunCrewManager
     * @example
     * // Get one RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCrewManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCrewManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCrewManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCrewManagers
     * const runCrewManagers = await prisma.runCrewManager.findMany()
     * 
     * // Get first 10 RunCrewManagers
     * const runCrewManagers = await prisma.runCrewManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCrewManagerWithIdOnly = await prisma.runCrewManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCrewManagerFindManyArgs>(args?: SelectSubset<T, RunCrewManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCrewManager.
     * @param {RunCrewManagerCreateArgs} args - Arguments to create a RunCrewManager.
     * @example
     * // Create one RunCrewManager
     * const RunCrewManager = await prisma.runCrewManager.create({
     *   data: {
     *     // ... data to create a RunCrewManager
     *   }
     * })
     * 
     */
    create<T extends RunCrewManagerCreateArgs>(args: SelectSubset<T, RunCrewManagerCreateArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCrewManagers.
     * @param {RunCrewManagerCreateManyArgs} args - Arguments to create many RunCrewManagers.
     * @example
     * // Create many RunCrewManagers
     * const runCrewManager = await prisma.runCrewManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCrewManagerCreateManyArgs>(args?: SelectSubset<T, RunCrewManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCrewManagers and returns the data saved in the database.
     * @param {RunCrewManagerCreateManyAndReturnArgs} args - Arguments to create many RunCrewManagers.
     * @example
     * // Create many RunCrewManagers
     * const runCrewManager = await prisma.runCrewManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCrewManagers and only return the `id`
     * const runCrewManagerWithIdOnly = await prisma.runCrewManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCrewManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCrewManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCrewManager.
     * @param {RunCrewManagerDeleteArgs} args - Arguments to delete one RunCrewManager.
     * @example
     * // Delete one RunCrewManager
     * const RunCrewManager = await prisma.runCrewManager.delete({
     *   where: {
     *     // ... filter to delete one RunCrewManager
     *   }
     * })
     * 
     */
    delete<T extends RunCrewManagerDeleteArgs>(args: SelectSubset<T, RunCrewManagerDeleteArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCrewManager.
     * @param {RunCrewManagerUpdateArgs} args - Arguments to update one RunCrewManager.
     * @example
     * // Update one RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCrewManagerUpdateArgs>(args: SelectSubset<T, RunCrewManagerUpdateArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCrewManagers.
     * @param {RunCrewManagerDeleteManyArgs} args - Arguments to filter RunCrewManagers to delete.
     * @example
     * // Delete a few RunCrewManagers
     * const { count } = await prisma.runCrewManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCrewManagerDeleteManyArgs>(args?: SelectSubset<T, RunCrewManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCrewManagers
     * const runCrewManager = await prisma.runCrewManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCrewManagerUpdateManyArgs>(args: SelectSubset<T, RunCrewManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCrewManagers and returns the data updated in the database.
     * @param {RunCrewManagerUpdateManyAndReturnArgs} args - Arguments to update many RunCrewManagers.
     * @example
     * // Update many RunCrewManagers
     * const runCrewManager = await prisma.runCrewManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCrewManagers and only return the `id`
     * const runCrewManagerWithIdOnly = await prisma.runCrewManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCrewManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCrewManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCrewManager.
     * @param {RunCrewManagerUpsertArgs} args - Arguments to update or create a RunCrewManager.
     * @example
     * // Update or create a RunCrewManager
     * const runCrewManager = await prisma.runCrewManager.upsert({
     *   create: {
     *     // ... data to create a RunCrewManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCrewManager we want to update
     *   }
     * })
     */
    upsert<T extends RunCrewManagerUpsertArgs>(args: SelectSubset<T, RunCrewManagerUpsertArgs<ExtArgs>>): Prisma__RunCrewManagerClient<$Result.GetResult<Prisma.$RunCrewManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCrewManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerCountArgs} args - Arguments to filter RunCrewManagers to count.
     * @example
     * // Count the number of RunCrewManagers
     * const count = await prisma.runCrewManager.count({
     *   where: {
     *     // ... the filter for the RunCrewManagers we want to count
     *   }
     * })
    **/
    count<T extends RunCrewManagerCountArgs>(
      args?: Subset<T, RunCrewManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCrewManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCrewManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCrewManagerAggregateArgs>(args: Subset<T, RunCrewManagerAggregateArgs>): Prisma.PrismaPromise<GetRunCrewManagerAggregateType<T>>

    /**
     * Group by RunCrewManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCrewManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCrewManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCrewManagerGroupByArgs['orderBy'] }
        : { orderBy?: RunCrewManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCrewManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCrewManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCrewManager model
   */
  readonly fields: RunCrewManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCrewManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCrewManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runCrew<T extends RunCrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunCrewDefaultArgs<ExtArgs>>): Prisma__RunCrewClient<$Result.GetResult<Prisma.$RunCrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCrewManager model
   */
  interface RunCrewManagerFieldRefs {
    readonly id: FieldRef<"RunCrewManager", 'String'>
    readonly runCrewId: FieldRef<"RunCrewManager", 'String'>
    readonly athleteId: FieldRef<"RunCrewManager", 'String'>
    readonly role: FieldRef<"RunCrewManager", 'String'>
    readonly createdAt: FieldRef<"RunCrewManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCrewManager findUnique
   */
  export type RunCrewManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewManager to fetch.
     */
    where: RunCrewManagerWhereUniqueInput
  }

  /**
   * RunCrewManager findUniqueOrThrow
   */
  export type RunCrewManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewManager to fetch.
     */
    where: RunCrewManagerWhereUniqueInput
  }

  /**
   * RunCrewManager findFirst
   */
  export type RunCrewManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewManager to fetch.
     */
    where?: RunCrewManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewManagers to fetch.
     */
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewManagers.
     */
    cursor?: RunCrewManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewManagers.
     */
    distinct?: RunCrewManagerScalarFieldEnum | RunCrewManagerScalarFieldEnum[]
  }

  /**
   * RunCrewManager findFirstOrThrow
   */
  export type RunCrewManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewManager to fetch.
     */
    where?: RunCrewManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewManagers to fetch.
     */
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCrewManagers.
     */
    cursor?: RunCrewManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCrewManagers.
     */
    distinct?: RunCrewManagerScalarFieldEnum | RunCrewManagerScalarFieldEnum[]
  }

  /**
   * RunCrewManager findMany
   */
  export type RunCrewManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter, which RunCrewManagers to fetch.
     */
    where?: RunCrewManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCrewManagers to fetch.
     */
    orderBy?: RunCrewManagerOrderByWithRelationInput | RunCrewManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCrewManagers.
     */
    cursor?: RunCrewManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCrewManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCrewManagers.
     */
    skip?: number
    distinct?: RunCrewManagerScalarFieldEnum | RunCrewManagerScalarFieldEnum[]
  }

  /**
   * RunCrewManager create
   */
  export type RunCrewManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a RunCrewManager.
     */
    data: XOR<RunCrewManagerCreateInput, RunCrewManagerUncheckedCreateInput>
  }

  /**
   * RunCrewManager createMany
   */
  export type RunCrewManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCrewManagers.
     */
    data: RunCrewManagerCreateManyInput | RunCrewManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RunCrewManager createManyAndReturn
   */
  export type RunCrewManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * The data used to create many RunCrewManagers.
     */
    data: RunCrewManagerCreateManyInput | RunCrewManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewManager update
   */
  export type RunCrewManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a RunCrewManager.
     */
    data: XOR<RunCrewManagerUpdateInput, RunCrewManagerUncheckedUpdateInput>
    /**
     * Choose, which RunCrewManager to update.
     */
    where: RunCrewManagerWhereUniqueInput
  }

  /**
   * RunCrewManager updateMany
   */
  export type RunCrewManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCrewManagers.
     */
    data: XOR<RunCrewManagerUpdateManyMutationInput, RunCrewManagerUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewManagers to update
     */
    where?: RunCrewManagerWhereInput
    /**
     * Limit how many RunCrewManagers to update.
     */
    limit?: number
  }

  /**
   * RunCrewManager updateManyAndReturn
   */
  export type RunCrewManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * The data used to update RunCrewManagers.
     */
    data: XOR<RunCrewManagerUpdateManyMutationInput, RunCrewManagerUncheckedUpdateManyInput>
    /**
     * Filter which RunCrewManagers to update
     */
    where?: RunCrewManagerWhereInput
    /**
     * Limit how many RunCrewManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RunCrewManager upsert
   */
  export type RunCrewManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the RunCrewManager to update in case it exists.
     */
    where: RunCrewManagerWhereUniqueInput
    /**
     * In case the RunCrewManager found by the `where` argument doesn't exist, create a new RunCrewManager with this data.
     */
    create: XOR<RunCrewManagerCreateInput, RunCrewManagerUncheckedCreateInput>
    /**
     * In case the RunCrewManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCrewManagerUpdateInput, RunCrewManagerUncheckedUpdateInput>
  }

  /**
   * RunCrewManager delete
   */
  export type RunCrewManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
    /**
     * Filter which RunCrewManager to delete.
     */
    where: RunCrewManagerWhereUniqueInput
  }

  /**
   * RunCrewManager deleteMany
   */
  export type RunCrewManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCrewManagers to delete
     */
    where?: RunCrewManagerWhereInput
    /**
     * Limit how many RunCrewManagers to delete.
     */
    limit?: number
  }

  /**
   * RunCrewManager without action
   */
  export type RunCrewManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCrewManager
     */
    select?: RunCrewManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCrewManager
     */
    omit?: RunCrewManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunCrewManagerInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    distanceMiles: number | null
  }

  export type RaceSumAggregateOutputType = {
    distanceMiles: number | null
  }

  export type RaceMinAggregateOutputType = {
    id: string | null
    raceName: string | null
    raceType: string | null
    raceDate: Date | null
    location: string | null
    distanceMiles: number | null
    registrationUrl: string | null
    description: string | null
    createdByAthleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceMaxAggregateOutputType = {
    id: string | null
    raceName: string | null
    raceType: string | null
    raceDate: Date | null
    location: string | null
    distanceMiles: number | null
    registrationUrl: string | null
    description: string | null
    createdByAthleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    raceName: number
    raceType: number
    raceDate: number
    location: number
    distanceMiles: number
    registrationUrl: number
    description: number
    courseProfile: number
    createdByAthleteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    distanceMiles?: true
  }

  export type RaceSumAggregateInputType = {
    distanceMiles?: true
  }

  export type RaceMinAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    raceName?: true
    raceType?: true
    raceDate?: true
    location?: true
    distanceMiles?: true
    registrationUrl?: true
    description?: true
    courseProfile?: true
    createdByAthleteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: string
    raceName: string
    raceType: string
    raceDate: Date
    location: string | null
    distanceMiles: number
    registrationUrl: string | null
    description: string | null
    courseProfile: JsonValue | null
    createdByAthleteId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
    trainingPlans?: boolean | Race$trainingPlansArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    id?: boolean
    raceName?: boolean
    raceType?: boolean
    raceDate?: boolean
    location?: boolean
    distanceMiles?: boolean
    registrationUrl?: boolean
    description?: boolean
    courseProfile?: boolean
    createdByAthleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raceName" | "raceType" | "raceDate" | "location" | "distanceMiles" | "registrationUrl" | "description" | "courseProfile" | "createdByAthleteId" | "createdAt" | "updatedAt", ExtArgs["result"]["race"]>
  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
    trainingPlans?: boolean | Race$trainingPlansArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }
  export type RaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAthlete?: boolean | Race$createdByAthleteArgs<ExtArgs>
  }

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      createdByAthlete: Prisma.$AthletePayload<ExtArgs> | null
      trainingPlans: Prisma.$TrainingPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      raceName: string
      raceType: string
      raceDate: Date
      location: string | null
      distanceMiles: number
      registrationUrl: string | null
      description: string | null
      courseProfile: Prisma.JsonValue | null
      createdByAthleteId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races and returns the data updated in the database.
     * @param {RaceUpdateManyAndReturnArgs} args - Arguments to update many Races.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByAthlete<T extends Race$createdByAthleteArgs<ExtArgs> = {}>(args?: Subset<T, Race$createdByAthleteArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trainingPlans<T extends Race$trainingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Race$trainingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'String'>
    readonly raceName: FieldRef<"Race", 'String'>
    readonly raceType: FieldRef<"Race", 'String'>
    readonly raceDate: FieldRef<"Race", 'DateTime'>
    readonly location: FieldRef<"Race", 'String'>
    readonly distanceMiles: FieldRef<"Race", 'Float'>
    readonly registrationUrl: FieldRef<"Race", 'String'>
    readonly description: FieldRef<"Race", 'String'>
    readonly courseProfile: FieldRef<"Race", 'Json'>
    readonly createdByAthleteId: FieldRef<"Race", 'String'>
    readonly createdAt: FieldRef<"Race", 'DateTime'>
    readonly updatedAt: FieldRef<"Race", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race updateManyAndReturn
   */
  export type RaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to delete.
     */
    limit?: number
  }

  /**
   * Race.createdByAthlete
   */
  export type Race$createdByAthleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Athlete
     */
    omit?: AthleteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleteInclude<ExtArgs> | null
    where?: AthleteWhereInput
  }

  /**
   * Race.trainingPlans
   */
  export type Race$trainingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    cursor?: TrainingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPlan
   */

  export type AggregateTrainingPlan = {
    _count: TrainingPlanCountAggregateOutputType | null
    _avg: TrainingPlanAvgAggregateOutputType | null
    _sum: TrainingPlanSumAggregateOutputType | null
    _min: TrainingPlanMinAggregateOutputType | null
    _max: TrainingPlanMaxAggregateOutputType | null
  }

  export type TrainingPlanAvgAggregateOutputType = {
    baselineWeeklyMileage: number | null
    totalWeeks: number | null
  }

  export type TrainingPlanSumAggregateOutputType = {
    baselineWeeklyMileage: number | null
    totalWeeks: number | null
  }

  export type TrainingPlanMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    raceId: string | null
    goalTime: string | null
    goalPace: string | null
    baseline5k: string | null
    baselineWeeklyMileage: number | null
    startDate: Date | null
    totalWeeks: number | null
    adaptive5kTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    raceId: string | null
    goalTime: string | null
    goalPace: string | null
    baseline5k: string | null
    baselineWeeklyMileage: number | null
    startDate: Date | null
    totalWeeks: number | null
    adaptive5kTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanCountAggregateOutputType = {
    id: number
    athleteId: number
    raceId: number
    goalTime: number
    goalPace: number
    baseline5k: number
    baselineWeeklyMileage: number
    startDate: number
    totalWeeks: number
    phaseOverview: number
    weeklyMileagePlan: number
    weeks: number
    adaptive5kTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingPlanAvgAggregateInputType = {
    baselineWeeklyMileage?: true
    totalWeeks?: true
  }

  export type TrainingPlanSumAggregateInputType = {
    baselineWeeklyMileage?: true
    totalWeeks?: true
  }

  export type TrainingPlanMinAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanMaxAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanCountAggregateInputType = {
    id?: true
    athleteId?: true
    raceId?: true
    goalTime?: true
    goalPace?: true
    baseline5k?: true
    baselineWeeklyMileage?: true
    startDate?: true
    totalWeeks?: true
    phaseOverview?: true
    weeklyMileagePlan?: true
    weeks?: true
    adaptive5kTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlan to aggregate.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPlans
    **/
    _count?: true | TrainingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPlanMaxAggregateInputType
  }

  export type GetTrainingPlanAggregateType<T extends TrainingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPlan[P]>
      : GetScalarType<T[P], AggregateTrainingPlan[P]>
  }




  export type TrainingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanWhereInput
    orderBy?: TrainingPlanOrderByWithAggregationInput | TrainingPlanOrderByWithAggregationInput[]
    by: TrainingPlanScalarFieldEnum[] | TrainingPlanScalarFieldEnum
    having?: TrainingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPlanCountAggregateInputType | true
    _avg?: TrainingPlanAvgAggregateInputType
    _sum?: TrainingPlanSumAggregateInputType
    _min?: TrainingPlanMinAggregateInputType
    _max?: TrainingPlanMaxAggregateInputType
  }

  export type TrainingPlanGroupByOutputType = {
    id: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace: string | null
    baseline5k: string
    baselineWeeklyMileage: number | null
    startDate: Date
    totalWeeks: number
    phaseOverview: JsonValue | null
    weeklyMileagePlan: JsonValue | null
    weeks: JsonValue | null
    adaptive5kTime: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingPlanCountAggregateOutputType | null
    _avg: TrainingPlanAvgAggregateOutputType | null
    _sum: TrainingPlanSumAggregateOutputType | null
    _min: TrainingPlanMinAggregateOutputType | null
    _max: TrainingPlanMaxAggregateOutputType | null
  }

  type GetTrainingPlanGroupByPayload<T extends TrainingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPlanGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    plannedDays?: boolean | TrainingPlan$plannedDaysArgs<ExtArgs>
    executions?: boolean | TrainingPlan$executionsArgs<ExtArgs>
    _count?: boolean | TrainingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlan"]>

  export type TrainingPlanSelectScalar = {
    id?: boolean
    athleteId?: boolean
    raceId?: boolean
    goalTime?: boolean
    goalPace?: boolean
    baseline5k?: boolean
    baselineWeeklyMileage?: boolean
    startDate?: boolean
    totalWeeks?: boolean
    phaseOverview?: boolean
    weeklyMileagePlan?: boolean
    weeks?: boolean
    adaptive5kTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "raceId" | "goalTime" | "goalPace" | "baseline5k" | "baselineWeeklyMileage" | "startDate" | "totalWeeks" | "phaseOverview" | "weeklyMileagePlan" | "weeks" | "adaptive5kTime" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingPlan"]>
  export type TrainingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    plannedDays?: boolean | TrainingPlan$plannedDaysArgs<ExtArgs>
    executions?: boolean | TrainingPlan$executionsArgs<ExtArgs>
    _count?: boolean | TrainingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type TrainingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $TrainingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPlan"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
      race: Prisma.$RacePayload<ExtArgs>
      plannedDays: Prisma.$TrainingDayPlannedPayload<ExtArgs>[]
      executions: Prisma.$TrainingPlanExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      raceId: string
      goalTime: string
      goalPace: string | null
      baseline5k: string
      baselineWeeklyMileage: number | null
      startDate: Date
      totalWeeks: number
      phaseOverview: Prisma.JsonValue | null
      weeklyMileagePlan: Prisma.JsonValue | null
      weeks: Prisma.JsonValue | null
      adaptive5kTime: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingPlan"]>
    composites: {}
  }

  type TrainingPlanGetPayload<S extends boolean | null | undefined | TrainingPlanDefaultArgs> = $Result.GetResult<Prisma.$TrainingPlanPayload, S>

  type TrainingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPlanCountAggregateInputType | true
    }

  export interface TrainingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPlan'], meta: { name: 'TrainingPlan' } }
    /**
     * Find zero or one TrainingPlan that matches the filter.
     * @param {TrainingPlanFindUniqueArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPlanFindUniqueArgs>(args: SelectSubset<T, TrainingPlanFindUniqueArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPlanFindUniqueOrThrowArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindFirstArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPlanFindFirstArgs>(args?: SelectSubset<T, TrainingPlanFindFirstArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindFirstOrThrowArgs} args - Arguments to find a TrainingPlan
     * @example
     * // Get one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPlans
     * const trainingPlans = await prisma.trainingPlan.findMany()
     * 
     * // Get first 10 TrainingPlans
     * const trainingPlans = await prisma.trainingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPlanFindManyArgs>(args?: SelectSubset<T, TrainingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPlan.
     * @param {TrainingPlanCreateArgs} args - Arguments to create a TrainingPlan.
     * @example
     * // Create one TrainingPlan
     * const TrainingPlan = await prisma.trainingPlan.create({
     *   data: {
     *     // ... data to create a TrainingPlan
     *   }
     * })
     * 
     */
    create<T extends TrainingPlanCreateArgs>(args: SelectSubset<T, TrainingPlanCreateArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPlans.
     * @param {TrainingPlanCreateManyArgs} args - Arguments to create many TrainingPlans.
     * @example
     * // Create many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPlanCreateManyArgs>(args?: SelectSubset<T, TrainingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPlans and returns the data saved in the database.
     * @param {TrainingPlanCreateManyAndReturnArgs} args - Arguments to create many TrainingPlans.
     * @example
     * // Create many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPlans and only return the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPlan.
     * @param {TrainingPlanDeleteArgs} args - Arguments to delete one TrainingPlan.
     * @example
     * // Delete one TrainingPlan
     * const TrainingPlan = await prisma.trainingPlan.delete({
     *   where: {
     *     // ... filter to delete one TrainingPlan
     *   }
     * })
     * 
     */
    delete<T extends TrainingPlanDeleteArgs>(args: SelectSubset<T, TrainingPlanDeleteArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPlan.
     * @param {TrainingPlanUpdateArgs} args - Arguments to update one TrainingPlan.
     * @example
     * // Update one TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPlanUpdateArgs>(args: SelectSubset<T, TrainingPlanUpdateArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPlans.
     * @param {TrainingPlanDeleteManyArgs} args - Arguments to filter TrainingPlans to delete.
     * @example
     * // Delete a few TrainingPlans
     * const { count } = await prisma.trainingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPlanDeleteManyArgs>(args?: SelectSubset<T, TrainingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPlanUpdateManyArgs>(args: SelectSubset<T, TrainingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlans and returns the data updated in the database.
     * @param {TrainingPlanUpdateManyAndReturnArgs} args - Arguments to update many TrainingPlans.
     * @example
     * // Update many TrainingPlans
     * const trainingPlan = await prisma.trainingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPlans and only return the `id`
     * const trainingPlanWithIdOnly = await prisma.trainingPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPlan.
     * @param {TrainingPlanUpsertArgs} args - Arguments to update or create a TrainingPlan.
     * @example
     * // Update or create a TrainingPlan
     * const trainingPlan = await prisma.trainingPlan.upsert({
     *   create: {
     *     // ... data to create a TrainingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPlan we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPlanUpsertArgs>(args: SelectSubset<T, TrainingPlanUpsertArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanCountArgs} args - Arguments to filter TrainingPlans to count.
     * @example
     * // Count the number of TrainingPlans
     * const count = await prisma.trainingPlan.count({
     *   where: {
     *     // ... the filter for the TrainingPlans we want to count
     *   }
     * })
    **/
    count<T extends TrainingPlanCountArgs>(
      args?: Subset<T, TrainingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPlanAggregateArgs>(args: Subset<T, TrainingPlanAggregateArgs>): Prisma.PrismaPromise<GetTrainingPlanAggregateType<T>>

    /**
     * Group by TrainingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPlanGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPlan model
   */
  readonly fields: TrainingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plannedDays<T extends TrainingPlan$plannedDaysArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlan$plannedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executions<T extends TrainingPlan$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlan$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPlan model
   */
  interface TrainingPlanFieldRefs {
    readonly id: FieldRef<"TrainingPlan", 'String'>
    readonly athleteId: FieldRef<"TrainingPlan", 'String'>
    readonly raceId: FieldRef<"TrainingPlan", 'String'>
    readonly goalTime: FieldRef<"TrainingPlan", 'String'>
    readonly goalPace: FieldRef<"TrainingPlan", 'String'>
    readonly baseline5k: FieldRef<"TrainingPlan", 'String'>
    readonly baselineWeeklyMileage: FieldRef<"TrainingPlan", 'Int'>
    readonly startDate: FieldRef<"TrainingPlan", 'DateTime'>
    readonly totalWeeks: FieldRef<"TrainingPlan", 'Int'>
    readonly phaseOverview: FieldRef<"TrainingPlan", 'Json'>
    readonly weeklyMileagePlan: FieldRef<"TrainingPlan", 'Json'>
    readonly weeks: FieldRef<"TrainingPlan", 'Json'>
    readonly adaptive5kTime: FieldRef<"TrainingPlan", 'String'>
    readonly createdAt: FieldRef<"TrainingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPlan findUnique
   */
  export type TrainingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan findUniqueOrThrow
   */
  export type TrainingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan findFirst
   */
  export type TrainingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlans.
     */
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan findFirstOrThrow
   */
  export type TrainingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlan to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlans.
     */
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan findMany
   */
  export type TrainingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlans to fetch.
     */
    where?: TrainingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlans to fetch.
     */
    orderBy?: TrainingPlanOrderByWithRelationInput | TrainingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPlans.
     */
    cursor?: TrainingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlans.
     */
    skip?: number
    distinct?: TrainingPlanScalarFieldEnum | TrainingPlanScalarFieldEnum[]
  }

  /**
   * TrainingPlan create
   */
  export type TrainingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPlan.
     */
    data: XOR<TrainingPlanCreateInput, TrainingPlanUncheckedCreateInput>
  }

  /**
   * TrainingPlan createMany
   */
  export type TrainingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPlans.
     */
    data: TrainingPlanCreateManyInput | TrainingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPlan createManyAndReturn
   */
  export type TrainingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPlans.
     */
    data: TrainingPlanCreateManyInput | TrainingPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlan update
   */
  export type TrainingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPlan.
     */
    data: XOR<TrainingPlanUpdateInput, TrainingPlanUncheckedUpdateInput>
    /**
     * Choose, which TrainingPlan to update.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan updateMany
   */
  export type TrainingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPlans.
     */
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlans to update
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to update.
     */
    limit?: number
  }

  /**
   * TrainingPlan updateManyAndReturn
   */
  export type TrainingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPlans.
     */
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlans to update
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlan upsert
   */
  export type TrainingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPlan to update in case it exists.
     */
    where: TrainingPlanWhereUniqueInput
    /**
     * In case the TrainingPlan found by the `where` argument doesn't exist, create a new TrainingPlan with this data.
     */
    create: XOR<TrainingPlanCreateInput, TrainingPlanUncheckedCreateInput>
    /**
     * In case the TrainingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPlanUpdateInput, TrainingPlanUncheckedUpdateInput>
  }

  /**
   * TrainingPlan delete
   */
  export type TrainingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
    /**
     * Filter which TrainingPlan to delete.
     */
    where: TrainingPlanWhereUniqueInput
  }

  /**
   * TrainingPlan deleteMany
   */
  export type TrainingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlans to delete
     */
    where?: TrainingPlanWhereInput
    /**
     * Limit how many TrainingPlans to delete.
     */
    limit?: number
  }

  /**
   * TrainingPlan.plannedDays
   */
  export type TrainingPlan$plannedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    cursor?: TrainingDayPlannedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingPlan.executions
   */
  export type TrainingPlan$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    where?: TrainingPlanExecutionWhereInput
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    cursor?: TrainingPlanExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlan without action
   */
  export type TrainingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlan
     */
    select?: TrainingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlan
     */
    omit?: TrainingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDayPlanned
   */

  export type AggregateTrainingDayPlanned = {
    _count: TrainingDayPlannedCountAggregateOutputType | null
    _avg: TrainingDayPlannedAvgAggregateOutputType | null
    _sum: TrainingDayPlannedSumAggregateOutputType | null
    _min: TrainingDayPlannedMinAggregateOutputType | null
    _max: TrainingDayPlannedMaxAggregateOutputType | null
  }

  export type TrainingDayPlannedAvgAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayPlannedSumAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayPlannedMinAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    athleteId: string | null
    date: Date | null
    weekIndex: number | null
    dayIndex: number | null
    dayName: string | null
    phase: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayPlannedMaxAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    athleteId: string | null
    date: Date | null
    weekIndex: number | null
    dayIndex: number | null
    dayName: string | null
    phase: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayPlannedCountAggregateOutputType = {
    id: number
    trainingPlanId: number
    athleteId: number
    date: number
    weekIndex: number
    dayIndex: number
    dayName: number
    phase: number
    plannedData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDayPlannedAvgAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayPlannedSumAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayPlannedMinAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayPlannedMaxAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayPlannedCountAggregateInputType = {
    id?: true
    trainingPlanId?: true
    athleteId?: true
    date?: true
    weekIndex?: true
    dayIndex?: true
    dayName?: true
    phase?: true
    plannedData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDayPlannedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayPlanned to aggregate.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDayPlanneds
    **/
    _count?: true | TrainingDayPlannedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDayPlannedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDayPlannedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDayPlannedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDayPlannedMaxAggregateInputType
  }

  export type GetTrainingDayPlannedAggregateType<T extends TrainingDayPlannedAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDayPlanned]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDayPlanned[P]>
      : GetScalarType<T[P], AggregateTrainingDayPlanned[P]>
  }




  export type TrainingDayPlannedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayPlannedWhereInput
    orderBy?: TrainingDayPlannedOrderByWithAggregationInput | TrainingDayPlannedOrderByWithAggregationInput[]
    by: TrainingDayPlannedScalarFieldEnum[] | TrainingDayPlannedScalarFieldEnum
    having?: TrainingDayPlannedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDayPlannedCountAggregateInputType | true
    _avg?: TrainingDayPlannedAvgAggregateInputType
    _sum?: TrainingDayPlannedSumAggregateInputType
    _min?: TrainingDayPlannedMinAggregateInputType
    _max?: TrainingDayPlannedMaxAggregateInputType
  }

  export type TrainingDayPlannedGroupByOutputType = {
    id: string
    trainingPlanId: string
    athleteId: string
    date: Date
    weekIndex: number
    dayIndex: number
    dayName: string | null
    phase: string
    plannedData: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TrainingDayPlannedCountAggregateOutputType | null
    _avg: TrainingDayPlannedAvgAggregateOutputType | null
    _sum: TrainingDayPlannedSumAggregateOutputType | null
    _min: TrainingDayPlannedMinAggregateOutputType | null
    _max: TrainingDayPlannedMaxAggregateOutputType | null
  }

  type GetTrainingDayPlannedGroupByPayload<T extends TrainingDayPlannedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDayPlannedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDayPlannedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDayPlannedGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDayPlannedGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDayPlannedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayPlanned"]>

  export type TrainingDayPlannedSelectScalar = {
    id?: boolean
    trainingPlanId?: boolean
    athleteId?: boolean
    date?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    dayName?: boolean
    phase?: boolean
    plannedData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDayPlannedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingPlanId" | "athleteId" | "date" | "weekIndex" | "dayIndex" | "dayName" | "phase" | "plannedData" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDayPlanned"]>
  export type TrainingDayPlannedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayPlannedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayPlannedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $TrainingDayPlannedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDayPlanned"
    objects: {
      trainingPlan: Prisma.$TrainingPlanPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingPlanId: string
      athleteId: string
      date: Date
      weekIndex: number
      dayIndex: number
      dayName: string | null
      phase: string
      plannedData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDayPlanned"]>
    composites: {}
  }

  type TrainingDayPlannedGetPayload<S extends boolean | null | undefined | TrainingDayPlannedDefaultArgs> = $Result.GetResult<Prisma.$TrainingDayPlannedPayload, S>

  type TrainingDayPlannedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDayPlannedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDayPlannedCountAggregateInputType | true
    }

  export interface TrainingDayPlannedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDayPlanned'], meta: { name: 'TrainingDayPlanned' } }
    /**
     * Find zero or one TrainingDayPlanned that matches the filter.
     * @param {TrainingDayPlannedFindUniqueArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDayPlannedFindUniqueArgs>(args: SelectSubset<T, TrainingDayPlannedFindUniqueArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDayPlanned that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDayPlannedFindUniqueOrThrowArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDayPlannedFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayPlanned that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindFirstArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDayPlannedFindFirstArgs>(args?: SelectSubset<T, TrainingDayPlannedFindFirstArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayPlanned that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindFirstOrThrowArgs} args - Arguments to find a TrainingDayPlanned
     * @example
     * // Get one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDayPlannedFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDayPlanneds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDayPlanneds
     * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany()
     * 
     * // Get first 10 TrainingDayPlanneds
     * const trainingDayPlanneds = await prisma.trainingDayPlanned.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDayPlannedFindManyArgs>(args?: SelectSubset<T, TrainingDayPlannedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDayPlanned.
     * @param {TrainingDayPlannedCreateArgs} args - Arguments to create a TrainingDayPlanned.
     * @example
     * // Create one TrainingDayPlanned
     * const TrainingDayPlanned = await prisma.trainingDayPlanned.create({
     *   data: {
     *     // ... data to create a TrainingDayPlanned
     *   }
     * })
     * 
     */
    create<T extends TrainingDayPlannedCreateArgs>(args: SelectSubset<T, TrainingDayPlannedCreateArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDayPlanneds.
     * @param {TrainingDayPlannedCreateManyArgs} args - Arguments to create many TrainingDayPlanneds.
     * @example
     * // Create many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDayPlannedCreateManyArgs>(args?: SelectSubset<T, TrainingDayPlannedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDayPlanneds and returns the data saved in the database.
     * @param {TrainingDayPlannedCreateManyAndReturnArgs} args - Arguments to create many TrainingDayPlanneds.
     * @example
     * // Create many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDayPlanneds and only return the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDayPlannedCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDayPlanned.
     * @param {TrainingDayPlannedDeleteArgs} args - Arguments to delete one TrainingDayPlanned.
     * @example
     * // Delete one TrainingDayPlanned
     * const TrainingDayPlanned = await prisma.trainingDayPlanned.delete({
     *   where: {
     *     // ... filter to delete one TrainingDayPlanned
     *   }
     * })
     * 
     */
    delete<T extends TrainingDayPlannedDeleteArgs>(args: SelectSubset<T, TrainingDayPlannedDeleteArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDayPlanned.
     * @param {TrainingDayPlannedUpdateArgs} args - Arguments to update one TrainingDayPlanned.
     * @example
     * // Update one TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDayPlannedUpdateArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDayPlanneds.
     * @param {TrainingDayPlannedDeleteManyArgs} args - Arguments to filter TrainingDayPlanneds to delete.
     * @example
     * // Delete a few TrainingDayPlanneds
     * const { count } = await prisma.trainingDayPlanned.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDayPlannedDeleteManyArgs>(args?: SelectSubset<T, TrainingDayPlannedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayPlanneds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDayPlannedUpdateManyArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayPlanneds and returns the data updated in the database.
     * @param {TrainingDayPlannedUpdateManyAndReturnArgs} args - Arguments to update many TrainingDayPlanneds.
     * @example
     * // Update many TrainingDayPlanneds
     * const trainingDayPlanned = await prisma.trainingDayPlanned.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDayPlanneds and only return the `id`
     * const trainingDayPlannedWithIdOnly = await prisma.trainingDayPlanned.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDayPlannedUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDayPlanned.
     * @param {TrainingDayPlannedUpsertArgs} args - Arguments to update or create a TrainingDayPlanned.
     * @example
     * // Update or create a TrainingDayPlanned
     * const trainingDayPlanned = await prisma.trainingDayPlanned.upsert({
     *   create: {
     *     // ... data to create a TrainingDayPlanned
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDayPlanned we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDayPlannedUpsertArgs>(args: SelectSubset<T, TrainingDayPlannedUpsertArgs<ExtArgs>>): Prisma__TrainingDayPlannedClient<$Result.GetResult<Prisma.$TrainingDayPlannedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDayPlanneds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedCountArgs} args - Arguments to filter TrainingDayPlanneds to count.
     * @example
     * // Count the number of TrainingDayPlanneds
     * const count = await prisma.trainingDayPlanned.count({
     *   where: {
     *     // ... the filter for the TrainingDayPlanneds we want to count
     *   }
     * })
    **/
    count<T extends TrainingDayPlannedCountArgs>(
      args?: Subset<T, TrainingDayPlannedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDayPlannedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDayPlanned.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDayPlannedAggregateArgs>(args: Subset<T, TrainingDayPlannedAggregateArgs>): Prisma.PrismaPromise<GetTrainingDayPlannedAggregateType<T>>

    /**
     * Group by TrainingDayPlanned.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayPlannedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDayPlannedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDayPlannedGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDayPlannedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDayPlannedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDayPlannedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDayPlanned model
   */
  readonly fields: TrainingDayPlannedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDayPlanned.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDayPlannedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainingPlan<T extends TrainingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanDefaultArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDayPlanned model
   */
  interface TrainingDayPlannedFieldRefs {
    readonly id: FieldRef<"TrainingDayPlanned", 'String'>
    readonly trainingPlanId: FieldRef<"TrainingDayPlanned", 'String'>
    readonly athleteId: FieldRef<"TrainingDayPlanned", 'String'>
    readonly date: FieldRef<"TrainingDayPlanned", 'DateTime'>
    readonly weekIndex: FieldRef<"TrainingDayPlanned", 'Int'>
    readonly dayIndex: FieldRef<"TrainingDayPlanned", 'Int'>
    readonly dayName: FieldRef<"TrainingDayPlanned", 'String'>
    readonly phase: FieldRef<"TrainingDayPlanned", 'String'>
    readonly plannedData: FieldRef<"TrainingDayPlanned", 'Json'>
    readonly createdAt: FieldRef<"TrainingDayPlanned", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDayPlanned", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDayPlanned findUnique
   */
  export type TrainingDayPlannedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned findUniqueOrThrow
   */
  export type TrainingDayPlannedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned findFirst
   */
  export type TrainingDayPlannedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayPlanneds.
     */
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned findFirstOrThrow
   */
  export type TrainingDayPlannedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanned to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayPlanneds.
     */
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned findMany
   */
  export type TrainingDayPlannedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayPlanneds to fetch.
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayPlanneds to fetch.
     */
    orderBy?: TrainingDayPlannedOrderByWithRelationInput | TrainingDayPlannedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDayPlanneds.
     */
    cursor?: TrainingDayPlannedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayPlanneds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayPlanneds.
     */
    skip?: number
    distinct?: TrainingDayPlannedScalarFieldEnum | TrainingDayPlannedScalarFieldEnum[]
  }

  /**
   * TrainingDayPlanned create
   */
  export type TrainingDayPlannedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDayPlanned.
     */
    data: XOR<TrainingDayPlannedCreateInput, TrainingDayPlannedUncheckedCreateInput>
  }

  /**
   * TrainingDayPlanned createMany
   */
  export type TrainingDayPlannedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDayPlanneds.
     */
    data: TrainingDayPlannedCreateManyInput | TrainingDayPlannedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDayPlanned createManyAndReturn
   */
  export type TrainingDayPlannedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDayPlanneds.
     */
    data: TrainingDayPlannedCreateManyInput | TrainingDayPlannedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayPlanned update
   */
  export type TrainingDayPlannedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDayPlanned.
     */
    data: XOR<TrainingDayPlannedUpdateInput, TrainingDayPlannedUncheckedUpdateInput>
    /**
     * Choose, which TrainingDayPlanned to update.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned updateMany
   */
  export type TrainingDayPlannedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDayPlanneds.
     */
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayPlanneds to update
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to update.
     */
    limit?: number
  }

  /**
   * TrainingDayPlanned updateManyAndReturn
   */
  export type TrainingDayPlannedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDayPlanneds.
     */
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayPlanneds to update
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayPlanned upsert
   */
  export type TrainingDayPlannedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDayPlanned to update in case it exists.
     */
    where: TrainingDayPlannedWhereUniqueInput
    /**
     * In case the TrainingDayPlanned found by the `where` argument doesn't exist, create a new TrainingDayPlanned with this data.
     */
    create: XOR<TrainingDayPlannedCreateInput, TrainingDayPlannedUncheckedCreateInput>
    /**
     * In case the TrainingDayPlanned was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDayPlannedUpdateInput, TrainingDayPlannedUncheckedUpdateInput>
  }

  /**
   * TrainingDayPlanned delete
   */
  export type TrainingDayPlannedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
    /**
     * Filter which TrainingDayPlanned to delete.
     */
    where: TrainingDayPlannedWhereUniqueInput
  }

  /**
   * TrainingDayPlanned deleteMany
   */
  export type TrainingDayPlannedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayPlanneds to delete
     */
    where?: TrainingDayPlannedWhereInput
    /**
     * Limit how many TrainingDayPlanneds to delete.
     */
    limit?: number
  }

  /**
   * TrainingDayPlanned without action
   */
  export type TrainingDayPlannedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayPlanned
     */
    select?: TrainingDayPlannedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayPlanned
     */
    omit?: TrainingDayPlannedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayPlannedInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPlanExecution
   */

  export type AggregateTrainingPlanExecution = {
    _count: TrainingPlanExecutionCountAggregateOutputType | null
    _min: TrainingPlanExecutionMinAggregateOutputType | null
    _max: TrainingPlanExecutionMaxAggregateOutputType | null
  }

  export type TrainingPlanExecutionMinAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    startedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanExecutionMaxAggregateOutputType = {
    id: string | null
    trainingPlanId: string | null
    startedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingPlanExecutionCountAggregateOutputType = {
    id: number
    trainingPlanId: number
    startedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingPlanExecutionMinAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanExecutionMaxAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingPlanExecutionCountAggregateInputType = {
    id?: true
    trainingPlanId?: true
    startedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingPlanExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlanExecution to aggregate.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPlanExecutions
    **/
    _count?: true | TrainingPlanExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPlanExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPlanExecutionMaxAggregateInputType
  }

  export type GetTrainingPlanExecutionAggregateType<T extends TrainingPlanExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPlanExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPlanExecution[P]>
      : GetScalarType<T[P], AggregateTrainingPlanExecution[P]>
  }




  export type TrainingPlanExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPlanExecutionWhereInput
    orderBy?: TrainingPlanExecutionOrderByWithAggregationInput | TrainingPlanExecutionOrderByWithAggregationInput[]
    by: TrainingPlanExecutionScalarFieldEnum[] | TrainingPlanExecutionScalarFieldEnum
    having?: TrainingPlanExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPlanExecutionCountAggregateInputType | true
    _min?: TrainingPlanExecutionMinAggregateInputType
    _max?: TrainingPlanExecutionMaxAggregateInputType
  }

  export type TrainingPlanExecutionGroupByOutputType = {
    id: string
    trainingPlanId: string
    startedAt: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingPlanExecutionCountAggregateOutputType | null
    _min: TrainingPlanExecutionMinAggregateOutputType | null
    _max: TrainingPlanExecutionMaxAggregateOutputType | null
  }

  type GetTrainingPlanExecutionGroupByPayload<T extends TrainingPlanExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPlanExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPlanExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPlanExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPlanExecutionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPlanExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    executedDays?: boolean | TrainingPlanExecution$executedDaysArgs<ExtArgs>
    _count?: boolean | TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPlanExecution"]>

  export type TrainingPlanExecutionSelectScalar = {
    id?: boolean
    trainingPlanId?: boolean
    startedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingPlanExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingPlanId" | "startedAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingPlanExecution"]>
  export type TrainingPlanExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
    executedDays?: boolean | TrainingPlanExecution$executedDaysArgs<ExtArgs>
    _count?: boolean | TrainingPlanExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingPlanExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }
  export type TrainingPlanExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingPlan?: boolean | TrainingPlanDefaultArgs<ExtArgs>
  }

  export type $TrainingPlanExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPlanExecution"
    objects: {
      trainingPlan: Prisma.$TrainingPlanPayload<ExtArgs>
      executedDays: Prisma.$TrainingDayExecutedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingPlanId: string
      startedAt: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingPlanExecution"]>
    composites: {}
  }

  type TrainingPlanExecutionGetPayload<S extends boolean | null | undefined | TrainingPlanExecutionDefaultArgs> = $Result.GetResult<Prisma.$TrainingPlanExecutionPayload, S>

  type TrainingPlanExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPlanExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPlanExecutionCountAggregateInputType | true
    }

  export interface TrainingPlanExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPlanExecution'], meta: { name: 'TrainingPlanExecution' } }
    /**
     * Find zero or one TrainingPlanExecution that matches the filter.
     * @param {TrainingPlanExecutionFindUniqueArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPlanExecutionFindUniqueArgs>(args: SelectSubset<T, TrainingPlanExecutionFindUniqueArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPlanExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPlanExecutionFindUniqueOrThrowArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPlanExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlanExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindFirstArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPlanExecutionFindFirstArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindFirstArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPlanExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindFirstOrThrowArgs} args - Arguments to find a TrainingPlanExecution
     * @example
     * // Get one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPlanExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPlanExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPlanExecutions
     * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany()
     * 
     * // Get first 10 TrainingPlanExecutions
     * const trainingPlanExecutions = await prisma.trainingPlanExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPlanExecutionFindManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPlanExecution.
     * @param {TrainingPlanExecutionCreateArgs} args - Arguments to create a TrainingPlanExecution.
     * @example
     * // Create one TrainingPlanExecution
     * const TrainingPlanExecution = await prisma.trainingPlanExecution.create({
     *   data: {
     *     // ... data to create a TrainingPlanExecution
     *   }
     * })
     * 
     */
    create<T extends TrainingPlanExecutionCreateArgs>(args: SelectSubset<T, TrainingPlanExecutionCreateArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPlanExecutions.
     * @param {TrainingPlanExecutionCreateManyArgs} args - Arguments to create many TrainingPlanExecutions.
     * @example
     * // Create many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPlanExecutionCreateManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPlanExecutions and returns the data saved in the database.
     * @param {TrainingPlanExecutionCreateManyAndReturnArgs} args - Arguments to create many TrainingPlanExecutions.
     * @example
     * // Create many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPlanExecutions and only return the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPlanExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPlanExecution.
     * @param {TrainingPlanExecutionDeleteArgs} args - Arguments to delete one TrainingPlanExecution.
     * @example
     * // Delete one TrainingPlanExecution
     * const TrainingPlanExecution = await prisma.trainingPlanExecution.delete({
     *   where: {
     *     // ... filter to delete one TrainingPlanExecution
     *   }
     * })
     * 
     */
    delete<T extends TrainingPlanExecutionDeleteArgs>(args: SelectSubset<T, TrainingPlanExecutionDeleteArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPlanExecution.
     * @param {TrainingPlanExecutionUpdateArgs} args - Arguments to update one TrainingPlanExecution.
     * @example
     * // Update one TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPlanExecutionUpdateArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPlanExecutions.
     * @param {TrainingPlanExecutionDeleteManyArgs} args - Arguments to filter TrainingPlanExecutions to delete.
     * @example
     * // Delete a few TrainingPlanExecutions
     * const { count } = await prisma.trainingPlanExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPlanExecutionDeleteManyArgs>(args?: SelectSubset<T, TrainingPlanExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlanExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPlanExecutionUpdateManyArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPlanExecutions and returns the data updated in the database.
     * @param {TrainingPlanExecutionUpdateManyAndReturnArgs} args - Arguments to update many TrainingPlanExecutions.
     * @example
     * // Update many TrainingPlanExecutions
     * const trainingPlanExecution = await prisma.trainingPlanExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPlanExecutions and only return the `id`
     * const trainingPlanExecutionWithIdOnly = await prisma.trainingPlanExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPlanExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPlanExecution.
     * @param {TrainingPlanExecutionUpsertArgs} args - Arguments to update or create a TrainingPlanExecution.
     * @example
     * // Update or create a TrainingPlanExecution
     * const trainingPlanExecution = await prisma.trainingPlanExecution.upsert({
     *   create: {
     *     // ... data to create a TrainingPlanExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPlanExecution we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPlanExecutionUpsertArgs>(args: SelectSubset<T, TrainingPlanExecutionUpsertArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPlanExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionCountArgs} args - Arguments to filter TrainingPlanExecutions to count.
     * @example
     * // Count the number of TrainingPlanExecutions
     * const count = await prisma.trainingPlanExecution.count({
     *   where: {
     *     // ... the filter for the TrainingPlanExecutions we want to count
     *   }
     * })
    **/
    count<T extends TrainingPlanExecutionCountArgs>(
      args?: Subset<T, TrainingPlanExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPlanExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPlanExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPlanExecutionAggregateArgs>(args: Subset<T, TrainingPlanExecutionAggregateArgs>): Prisma.PrismaPromise<GetTrainingPlanExecutionAggregateType<T>>

    /**
     * Group by TrainingPlanExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPlanExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPlanExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPlanExecutionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPlanExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPlanExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPlanExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPlanExecution model
   */
  readonly fields: TrainingPlanExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPlanExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPlanExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainingPlan<T extends TrainingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanDefaultArgs<ExtArgs>>): Prisma__TrainingPlanClient<$Result.GetResult<Prisma.$TrainingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executedDays<T extends TrainingPlanExecution$executedDaysArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanExecution$executedDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPlanExecution model
   */
  interface TrainingPlanExecutionFieldRefs {
    readonly id: FieldRef<"TrainingPlanExecution", 'String'>
    readonly trainingPlanId: FieldRef<"TrainingPlanExecution", 'String'>
    readonly startedAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
    readonly status: FieldRef<"TrainingPlanExecution", 'String'>
    readonly createdAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingPlanExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPlanExecution findUnique
   */
  export type TrainingPlanExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution findUniqueOrThrow
   */
  export type TrainingPlanExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution findFirst
   */
  export type TrainingPlanExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlanExecutions.
     */
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution findFirstOrThrow
   */
  export type TrainingPlanExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecution to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPlanExecutions.
     */
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution findMany
   */
  export type TrainingPlanExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPlanExecutions to fetch.
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPlanExecutions to fetch.
     */
    orderBy?: TrainingPlanExecutionOrderByWithRelationInput | TrainingPlanExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPlanExecutions.
     */
    cursor?: TrainingPlanExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPlanExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPlanExecutions.
     */
    skip?: number
    distinct?: TrainingPlanExecutionScalarFieldEnum | TrainingPlanExecutionScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution create
   */
  export type TrainingPlanExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPlanExecution.
     */
    data: XOR<TrainingPlanExecutionCreateInput, TrainingPlanExecutionUncheckedCreateInput>
  }

  /**
   * TrainingPlanExecution createMany
   */
  export type TrainingPlanExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPlanExecutions.
     */
    data: TrainingPlanExecutionCreateManyInput | TrainingPlanExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPlanExecution createManyAndReturn
   */
  export type TrainingPlanExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPlanExecutions.
     */
    data: TrainingPlanExecutionCreateManyInput | TrainingPlanExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlanExecution update
   */
  export type TrainingPlanExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPlanExecution.
     */
    data: XOR<TrainingPlanExecutionUpdateInput, TrainingPlanExecutionUncheckedUpdateInput>
    /**
     * Choose, which TrainingPlanExecution to update.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution updateMany
   */
  export type TrainingPlanExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPlanExecutions.
     */
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlanExecutions to update
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to update.
     */
    limit?: number
  }

  /**
   * TrainingPlanExecution updateManyAndReturn
   */
  export type TrainingPlanExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPlanExecutions.
     */
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPlanExecutions to update
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPlanExecution upsert
   */
  export type TrainingPlanExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPlanExecution to update in case it exists.
     */
    where: TrainingPlanExecutionWhereUniqueInput
    /**
     * In case the TrainingPlanExecution found by the `where` argument doesn't exist, create a new TrainingPlanExecution with this data.
     */
    create: XOR<TrainingPlanExecutionCreateInput, TrainingPlanExecutionUncheckedCreateInput>
    /**
     * In case the TrainingPlanExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPlanExecutionUpdateInput, TrainingPlanExecutionUncheckedUpdateInput>
  }

  /**
   * TrainingPlanExecution delete
   */
  export type TrainingPlanExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
    /**
     * Filter which TrainingPlanExecution to delete.
     */
    where: TrainingPlanExecutionWhereUniqueInput
  }

  /**
   * TrainingPlanExecution deleteMany
   */
  export type TrainingPlanExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPlanExecutions to delete
     */
    where?: TrainingPlanExecutionWhereInput
    /**
     * Limit how many TrainingPlanExecutions to delete.
     */
    limit?: number
  }

  /**
   * TrainingPlanExecution.executedDays
   */
  export type TrainingPlanExecution$executedDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    cursor?: TrainingDayExecutedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingPlanExecution without action
   */
  export type TrainingPlanExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPlanExecution
     */
    select?: TrainingPlanExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPlanExecution
     */
    omit?: TrainingPlanExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPlanExecutionInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDayExecuted
   */

  export type AggregateTrainingDayExecuted = {
    _count: TrainingDayExecutedCountAggregateOutputType | null
    _avg: TrainingDayExecutedAvgAggregateOutputType | null
    _sum: TrainingDayExecutedSumAggregateOutputType | null
    _min: TrainingDayExecutedMinAggregateOutputType | null
    _max: TrainingDayExecutedMaxAggregateOutputType | null
  }

  export type TrainingDayExecutedAvgAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayExecutedSumAggregateOutputType = {
    weekIndex: number | null
    dayIndex: number | null
  }

  export type TrainingDayExecutedMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    athleteId: string | null
    activityId: string | null
    weekIndex: number | null
    dayIndex: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayExecutedMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    athleteId: string | null
    activityId: string | null
    weekIndex: number | null
    dayIndex: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDayExecutedCountAggregateOutputType = {
    id: number
    executionId: number
    athleteId: number
    activityId: number
    weekIndex: number
    dayIndex: number
    date: number
    plannedData: number
    analysis: number
    feedback: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDayExecutedAvgAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayExecutedSumAggregateInputType = {
    weekIndex?: true
    dayIndex?: true
  }

  export type TrainingDayExecutedMinAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayExecutedMaxAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDayExecutedCountAggregateInputType = {
    id?: true
    executionId?: true
    athleteId?: true
    activityId?: true
    weekIndex?: true
    dayIndex?: true
    date?: true
    plannedData?: true
    analysis?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDayExecutedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayExecuted to aggregate.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDayExecuteds
    **/
    _count?: true | TrainingDayExecutedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDayExecutedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDayExecutedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDayExecutedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDayExecutedMaxAggregateInputType
  }

  export type GetTrainingDayExecutedAggregateType<T extends TrainingDayExecutedAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDayExecuted]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDayExecuted[P]>
      : GetScalarType<T[P], AggregateTrainingDayExecuted[P]>
  }




  export type TrainingDayExecutedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDayExecutedWhereInput
    orderBy?: TrainingDayExecutedOrderByWithAggregationInput | TrainingDayExecutedOrderByWithAggregationInput[]
    by: TrainingDayExecutedScalarFieldEnum[] | TrainingDayExecutedScalarFieldEnum
    having?: TrainingDayExecutedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDayExecutedCountAggregateInputType | true
    _avg?: TrainingDayExecutedAvgAggregateInputType
    _sum?: TrainingDayExecutedSumAggregateInputType
    _min?: TrainingDayExecutedMinAggregateInputType
    _max?: TrainingDayExecutedMaxAggregateInputType
  }

  export type TrainingDayExecutedGroupByOutputType = {
    id: string
    executionId: string
    athleteId: string
    activityId: string | null
    weekIndex: number
    dayIndex: number
    date: Date
    plannedData: JsonValue | null
    analysis: JsonValue | null
    feedback: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingDayExecutedCountAggregateOutputType | null
    _avg: TrainingDayExecutedAvgAggregateOutputType | null
    _sum: TrainingDayExecutedSumAggregateOutputType | null
    _min: TrainingDayExecutedMinAggregateOutputType | null
    _max: TrainingDayExecutedMaxAggregateOutputType | null
  }

  type GetTrainingDayExecutedGroupByPayload<T extends TrainingDayExecutedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDayExecutedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDayExecutedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDayExecutedGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDayExecutedGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDayExecutedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDayExecuted"]>

  export type TrainingDayExecutedSelectScalar = {
    id?: boolean
    executionId?: boolean
    athleteId?: boolean
    activityId?: boolean
    weekIndex?: boolean
    dayIndex?: boolean
    date?: boolean
    plannedData?: boolean
    analysis?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDayExecutedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executionId" | "athleteId" | "activityId" | "weekIndex" | "dayIndex" | "date" | "plannedData" | "analysis" | "feedback" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDayExecuted"]>
  export type TrainingDayExecutedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayExecutedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type TrainingDayExecutedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | TrainingPlanExecutionDefaultArgs<ExtArgs>
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $TrainingDayExecutedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDayExecuted"
    objects: {
      execution: Prisma.$TrainingPlanExecutionPayload<ExtArgs>
      athlete: Prisma.$AthletePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      athleteId: string
      activityId: string | null
      weekIndex: number
      dayIndex: number
      date: Date
      plannedData: Prisma.JsonValue | null
      analysis: Prisma.JsonValue | null
      feedback: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDayExecuted"]>
    composites: {}
  }

  type TrainingDayExecutedGetPayload<S extends boolean | null | undefined | TrainingDayExecutedDefaultArgs> = $Result.GetResult<Prisma.$TrainingDayExecutedPayload, S>

  type TrainingDayExecutedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDayExecutedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDayExecutedCountAggregateInputType | true
    }

  export interface TrainingDayExecutedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDayExecuted'], meta: { name: 'TrainingDayExecuted' } }
    /**
     * Find zero or one TrainingDayExecuted that matches the filter.
     * @param {TrainingDayExecutedFindUniqueArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDayExecutedFindUniqueArgs>(args: SelectSubset<T, TrainingDayExecutedFindUniqueArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDayExecuted that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDayExecutedFindUniqueOrThrowArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDayExecutedFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayExecuted that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindFirstArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDayExecutedFindFirstArgs>(args?: SelectSubset<T, TrainingDayExecutedFindFirstArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDayExecuted that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindFirstOrThrowArgs} args - Arguments to find a TrainingDayExecuted
     * @example
     * // Get one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDayExecutedFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDayExecuteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDayExecuteds
     * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany()
     * 
     * // Get first 10 TrainingDayExecuteds
     * const trainingDayExecuteds = await prisma.trainingDayExecuted.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDayExecutedFindManyArgs>(args?: SelectSubset<T, TrainingDayExecutedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDayExecuted.
     * @param {TrainingDayExecutedCreateArgs} args - Arguments to create a TrainingDayExecuted.
     * @example
     * // Create one TrainingDayExecuted
     * const TrainingDayExecuted = await prisma.trainingDayExecuted.create({
     *   data: {
     *     // ... data to create a TrainingDayExecuted
     *   }
     * })
     * 
     */
    create<T extends TrainingDayExecutedCreateArgs>(args: SelectSubset<T, TrainingDayExecutedCreateArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDayExecuteds.
     * @param {TrainingDayExecutedCreateManyArgs} args - Arguments to create many TrainingDayExecuteds.
     * @example
     * // Create many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDayExecutedCreateManyArgs>(args?: SelectSubset<T, TrainingDayExecutedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDayExecuteds and returns the data saved in the database.
     * @param {TrainingDayExecutedCreateManyAndReturnArgs} args - Arguments to create many TrainingDayExecuteds.
     * @example
     * // Create many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDayExecuteds and only return the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDayExecutedCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDayExecuted.
     * @param {TrainingDayExecutedDeleteArgs} args - Arguments to delete one TrainingDayExecuted.
     * @example
     * // Delete one TrainingDayExecuted
     * const TrainingDayExecuted = await prisma.trainingDayExecuted.delete({
     *   where: {
     *     // ... filter to delete one TrainingDayExecuted
     *   }
     * })
     * 
     */
    delete<T extends TrainingDayExecutedDeleteArgs>(args: SelectSubset<T, TrainingDayExecutedDeleteArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDayExecuted.
     * @param {TrainingDayExecutedUpdateArgs} args - Arguments to update one TrainingDayExecuted.
     * @example
     * // Update one TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDayExecutedUpdateArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDayExecuteds.
     * @param {TrainingDayExecutedDeleteManyArgs} args - Arguments to filter TrainingDayExecuteds to delete.
     * @example
     * // Delete a few TrainingDayExecuteds
     * const { count } = await prisma.trainingDayExecuted.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDayExecutedDeleteManyArgs>(args?: SelectSubset<T, TrainingDayExecutedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayExecuteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDayExecutedUpdateManyArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDayExecuteds and returns the data updated in the database.
     * @param {TrainingDayExecutedUpdateManyAndReturnArgs} args - Arguments to update many TrainingDayExecuteds.
     * @example
     * // Update many TrainingDayExecuteds
     * const trainingDayExecuted = await prisma.trainingDayExecuted.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDayExecuteds and only return the `id`
     * const trainingDayExecutedWithIdOnly = await prisma.trainingDayExecuted.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDayExecutedUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDayExecuted.
     * @param {TrainingDayExecutedUpsertArgs} args - Arguments to update or create a TrainingDayExecuted.
     * @example
     * // Update or create a TrainingDayExecuted
     * const trainingDayExecuted = await prisma.trainingDayExecuted.upsert({
     *   create: {
     *     // ... data to create a TrainingDayExecuted
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDayExecuted we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDayExecutedUpsertArgs>(args: SelectSubset<T, TrainingDayExecutedUpsertArgs<ExtArgs>>): Prisma__TrainingDayExecutedClient<$Result.GetResult<Prisma.$TrainingDayExecutedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDayExecuteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedCountArgs} args - Arguments to filter TrainingDayExecuteds to count.
     * @example
     * // Count the number of TrainingDayExecuteds
     * const count = await prisma.trainingDayExecuted.count({
     *   where: {
     *     // ... the filter for the TrainingDayExecuteds we want to count
     *   }
     * })
    **/
    count<T extends TrainingDayExecutedCountArgs>(
      args?: Subset<T, TrainingDayExecutedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDayExecutedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDayExecuted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDayExecutedAggregateArgs>(args: Subset<T, TrainingDayExecutedAggregateArgs>): Prisma.PrismaPromise<GetTrainingDayExecutedAggregateType<T>>

    /**
     * Group by TrainingDayExecuted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDayExecutedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDayExecutedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDayExecutedGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDayExecutedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDayExecutedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDayExecutedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDayExecuted model
   */
  readonly fields: TrainingDayExecutedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDayExecuted.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDayExecutedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends TrainingPlanExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingPlanExecutionDefaultArgs<ExtArgs>>): Prisma__TrainingPlanExecutionClient<$Result.GetResult<Prisma.$TrainingPlanExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDayExecuted model
   */
  interface TrainingDayExecutedFieldRefs {
    readonly id: FieldRef<"TrainingDayExecuted", 'String'>
    readonly executionId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly athleteId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly activityId: FieldRef<"TrainingDayExecuted", 'String'>
    readonly weekIndex: FieldRef<"TrainingDayExecuted", 'Int'>
    readonly dayIndex: FieldRef<"TrainingDayExecuted", 'Int'>
    readonly date: FieldRef<"TrainingDayExecuted", 'DateTime'>
    readonly plannedData: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly analysis: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly feedback: FieldRef<"TrainingDayExecuted", 'Json'>
    readonly createdAt: FieldRef<"TrainingDayExecuted", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDayExecuted", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDayExecuted findUnique
   */
  export type TrainingDayExecutedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted findUniqueOrThrow
   */
  export type TrainingDayExecutedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted findFirst
   */
  export type TrainingDayExecutedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayExecuteds.
     */
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted findFirstOrThrow
   */
  export type TrainingDayExecutedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuted to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDayExecuteds.
     */
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted findMany
   */
  export type TrainingDayExecutedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDayExecuteds to fetch.
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDayExecuteds to fetch.
     */
    orderBy?: TrainingDayExecutedOrderByWithRelationInput | TrainingDayExecutedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDayExecuteds.
     */
    cursor?: TrainingDayExecutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDayExecuteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDayExecuteds.
     */
    skip?: number
    distinct?: TrainingDayExecutedScalarFieldEnum | TrainingDayExecutedScalarFieldEnum[]
  }

  /**
   * TrainingDayExecuted create
   */
  export type TrainingDayExecutedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDayExecuted.
     */
    data: XOR<TrainingDayExecutedCreateInput, TrainingDayExecutedUncheckedCreateInput>
  }

  /**
   * TrainingDayExecuted createMany
   */
  export type TrainingDayExecutedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDayExecuteds.
     */
    data: TrainingDayExecutedCreateManyInput | TrainingDayExecutedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDayExecuted createManyAndReturn
   */
  export type TrainingDayExecutedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDayExecuteds.
     */
    data: TrainingDayExecutedCreateManyInput | TrainingDayExecutedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayExecuted update
   */
  export type TrainingDayExecutedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDayExecuted.
     */
    data: XOR<TrainingDayExecutedUpdateInput, TrainingDayExecutedUncheckedUpdateInput>
    /**
     * Choose, which TrainingDayExecuted to update.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted updateMany
   */
  export type TrainingDayExecutedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDayExecuteds.
     */
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayExecuteds to update
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to update.
     */
    limit?: number
  }

  /**
   * TrainingDayExecuted updateManyAndReturn
   */
  export type TrainingDayExecutedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDayExecuteds.
     */
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDayExecuteds to update
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDayExecuted upsert
   */
  export type TrainingDayExecutedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDayExecuted to update in case it exists.
     */
    where: TrainingDayExecutedWhereUniqueInput
    /**
     * In case the TrainingDayExecuted found by the `where` argument doesn't exist, create a new TrainingDayExecuted with this data.
     */
    create: XOR<TrainingDayExecutedCreateInput, TrainingDayExecutedUncheckedCreateInput>
    /**
     * In case the TrainingDayExecuted was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDayExecutedUpdateInput, TrainingDayExecutedUncheckedUpdateInput>
  }

  /**
   * TrainingDayExecuted delete
   */
  export type TrainingDayExecutedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
    /**
     * Filter which TrainingDayExecuted to delete.
     */
    where: TrainingDayExecutedWhereUniqueInput
  }

  /**
   * TrainingDayExecuted deleteMany
   */
  export type TrainingDayExecutedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDayExecuteds to delete
     */
    where?: TrainingDayExecutedWhereInput
    /**
     * Limit how many TrainingDayExecuteds to delete.
     */
    limit?: number
  }

  /**
   * TrainingDayExecuted without action
   */
  export type TrainingDayExecutedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDayExecuted
     */
    select?: TrainingDayExecutedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDayExecuted
     */
    omit?: TrainingDayExecutedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDayExecutedInclude<ExtArgs> | null
  }


  /**
   * Model Founder
   */

  export type AggregateFounder = {
    _count: FounderCountAggregateOutputType | null
    _min: FounderMinAggregateOutputType | null
    _max: FounderMaxAggregateOutputType | null
  }

  export type FounderMinAggregateOutputType = {
    id: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderMaxAggregateOutputType = {
    id: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderCountAggregateOutputType = {
    id: number
    athleteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FounderMinAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderMaxAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderCountAggregateInputType = {
    id?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FounderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Founder to aggregate.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Founders
    **/
    _count?: true | FounderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FounderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FounderMaxAggregateInputType
  }

  export type GetFounderAggregateType<T extends FounderAggregateArgs> = {
        [P in keyof T & keyof AggregateFounder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFounder[P]>
      : GetScalarType<T[P], AggregateFounder[P]>
  }




  export type FounderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderWhereInput
    orderBy?: FounderOrderByWithAggregationInput | FounderOrderByWithAggregationInput[]
    by: FounderScalarFieldEnum[] | FounderScalarFieldEnum
    having?: FounderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FounderCountAggregateInputType | true
    _min?: FounderMinAggregateInputType
    _max?: FounderMaxAggregateInputType
  }

  export type FounderGroupByOutputType = {
    id: string
    athleteId: string
    createdAt: Date
    updatedAt: Date
    _count: FounderCountAggregateOutputType | null
    _min: FounderMinAggregateOutputType | null
    _max: FounderMaxAggregateOutputType | null
  }

  type GetFounderGroupByPayload<T extends FounderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FounderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FounderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FounderGroupByOutputType[P]>
            : GetScalarType<T[P], FounderGroupByOutputType[P]>
        }
      >
    >


  export type FounderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    tasks?: boolean | Founder$tasksArgs<ExtArgs>
    crmContacts?: boolean | Founder$crmContactsArgs<ExtArgs>
    roadmapItems?: boolean | Founder$roadmapItemsArgs<ExtArgs>
    companyFounders?: boolean | Founder$companyFoundersArgs<ExtArgs>
    unifiedTasks?: boolean | Founder$unifiedTasksArgs<ExtArgs>
    _count?: boolean | FounderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founder"]>

  export type FounderSelectScalar = {
    id?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FounderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "athleteId" | "createdAt" | "updatedAt", ExtArgs["result"]["founder"]>
  export type FounderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
    tasks?: boolean | Founder$tasksArgs<ExtArgs>
    crmContacts?: boolean | Founder$crmContactsArgs<ExtArgs>
    roadmapItems?: boolean | Founder$roadmapItemsArgs<ExtArgs>
    companyFounders?: boolean | Founder$companyFoundersArgs<ExtArgs>
    unifiedTasks?: boolean | Founder$unifiedTasksArgs<ExtArgs>
    _count?: boolean | FounderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FounderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }
  export type FounderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athlete?: boolean | AthleteDefaultArgs<ExtArgs>
  }

  export type $FounderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Founder"
    objects: {
      athlete: Prisma.$AthletePayload<ExtArgs>
      tasks: Prisma.$FounderTaskPayload<ExtArgs>[]
      crmContacts: Prisma.$CrmContactPayload<ExtArgs>[]
      roadmapItems: Prisma.$RoadmapItemPayload<ExtArgs>[]
      companyFounders: Prisma.$CompanyFounderPayload<ExtArgs>[]
      unifiedTasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      athleteId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["founder"]>
    composites: {}
  }

  type FounderGetPayload<S extends boolean | null | undefined | FounderDefaultArgs> = $Result.GetResult<Prisma.$FounderPayload, S>

  type FounderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FounderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FounderCountAggregateInputType | true
    }

  export interface FounderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Founder'], meta: { name: 'Founder' } }
    /**
     * Find zero or one Founder that matches the filter.
     * @param {FounderFindUniqueArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FounderFindUniqueArgs>(args: SelectSubset<T, FounderFindUniqueArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Founder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FounderFindUniqueOrThrowArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FounderFindUniqueOrThrowArgs>(args: SelectSubset<T, FounderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Founder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindFirstArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FounderFindFirstArgs>(args?: SelectSubset<T, FounderFindFirstArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Founder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindFirstOrThrowArgs} args - Arguments to find a Founder
     * @example
     * // Get one Founder
     * const founder = await prisma.founder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FounderFindFirstOrThrowArgs>(args?: SelectSubset<T, FounderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Founders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Founders
     * const founders = await prisma.founder.findMany()
     * 
     * // Get first 10 Founders
     * const founders = await prisma.founder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const founderWithIdOnly = await prisma.founder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FounderFindManyArgs>(args?: SelectSubset<T, FounderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Founder.
     * @param {FounderCreateArgs} args - Arguments to create a Founder.
     * @example
     * // Create one Founder
     * const Founder = await prisma.founder.create({
     *   data: {
     *     // ... data to create a Founder
     *   }
     * })
     * 
     */
    create<T extends FounderCreateArgs>(args: SelectSubset<T, FounderCreateArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Founders.
     * @param {FounderCreateManyArgs} args - Arguments to create many Founders.
     * @example
     * // Create many Founders
     * const founder = await prisma.founder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FounderCreateManyArgs>(args?: SelectSubset<T, FounderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Founders and returns the data saved in the database.
     * @param {FounderCreateManyAndReturnArgs} args - Arguments to create many Founders.
     * @example
     * // Create many Founders
     * const founder = await prisma.founder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Founders and only return the `id`
     * const founderWithIdOnly = await prisma.founder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FounderCreateManyAndReturnArgs>(args?: SelectSubset<T, FounderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Founder.
     * @param {FounderDeleteArgs} args - Arguments to delete one Founder.
     * @example
     * // Delete one Founder
     * const Founder = await prisma.founder.delete({
     *   where: {
     *     // ... filter to delete one Founder
     *   }
     * })
     * 
     */
    delete<T extends FounderDeleteArgs>(args: SelectSubset<T, FounderDeleteArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Founder.
     * @param {FounderUpdateArgs} args - Arguments to update one Founder.
     * @example
     * // Update one Founder
     * const founder = await prisma.founder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FounderUpdateArgs>(args: SelectSubset<T, FounderUpdateArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Founders.
     * @param {FounderDeleteManyArgs} args - Arguments to filter Founders to delete.
     * @example
     * // Delete a few Founders
     * const { count } = await prisma.founder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FounderDeleteManyArgs>(args?: SelectSubset<T, FounderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Founders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Founders
     * const founder = await prisma.founder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FounderUpdateManyArgs>(args: SelectSubset<T, FounderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Founders and returns the data updated in the database.
     * @param {FounderUpdateManyAndReturnArgs} args - Arguments to update many Founders.
     * @example
     * // Update many Founders
     * const founder = await prisma.founder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Founders and only return the `id`
     * const founderWithIdOnly = await prisma.founder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FounderUpdateManyAndReturnArgs>(args: SelectSubset<T, FounderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Founder.
     * @param {FounderUpsertArgs} args - Arguments to update or create a Founder.
     * @example
     * // Update or create a Founder
     * const founder = await prisma.founder.upsert({
     *   create: {
     *     // ... data to create a Founder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Founder we want to update
     *   }
     * })
     */
    upsert<T extends FounderUpsertArgs>(args: SelectSubset<T, FounderUpsertArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Founders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderCountArgs} args - Arguments to filter Founders to count.
     * @example
     * // Count the number of Founders
     * const count = await prisma.founder.count({
     *   where: {
     *     // ... the filter for the Founders we want to count
     *   }
     * })
    **/
    count<T extends FounderCountArgs>(
      args?: Subset<T, FounderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FounderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Founder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FounderAggregateArgs>(args: Subset<T, FounderAggregateArgs>): Prisma.PrismaPromise<GetFounderAggregateType<T>>

    /**
     * Group by Founder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FounderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FounderGroupByArgs['orderBy'] }
        : { orderBy?: FounderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FounderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFounderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Founder model
   */
  readonly fields: FounderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Founder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FounderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athlete<T extends AthleteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AthleteDefaultArgs<ExtArgs>>): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Founder$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Founder$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crmContacts<T extends Founder$crmContactsArgs<ExtArgs> = {}>(args?: Subset<T, Founder$crmContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapItems<T extends Founder$roadmapItemsArgs<ExtArgs> = {}>(args?: Subset<T, Founder$roadmapItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyFounders<T extends Founder$companyFoundersArgs<ExtArgs> = {}>(args?: Subset<T, Founder$companyFoundersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unifiedTasks<T extends Founder$unifiedTasksArgs<ExtArgs> = {}>(args?: Subset<T, Founder$unifiedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Founder model
   */
  interface FounderFieldRefs {
    readonly id: FieldRef<"Founder", 'String'>
    readonly athleteId: FieldRef<"Founder", 'String'>
    readonly createdAt: FieldRef<"Founder", 'DateTime'>
    readonly updatedAt: FieldRef<"Founder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Founder findUnique
   */
  export type FounderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder findUniqueOrThrow
   */
  export type FounderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder findFirst
   */
  export type FounderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Founders.
     */
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder findFirstOrThrow
   */
  export type FounderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founder to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Founders.
     */
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder findMany
   */
  export type FounderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter, which Founders to fetch.
     */
    where?: FounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Founders to fetch.
     */
    orderBy?: FounderOrderByWithRelationInput | FounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Founders.
     */
    cursor?: FounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Founders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Founders.
     */
    skip?: number
    distinct?: FounderScalarFieldEnum | FounderScalarFieldEnum[]
  }

  /**
   * Founder create
   */
  export type FounderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The data needed to create a Founder.
     */
    data: XOR<FounderCreateInput, FounderUncheckedCreateInput>
  }

  /**
   * Founder createMany
   */
  export type FounderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Founders.
     */
    data: FounderCreateManyInput | FounderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Founder createManyAndReturn
   */
  export type FounderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * The data used to create many Founders.
     */
    data: FounderCreateManyInput | FounderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Founder update
   */
  export type FounderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The data needed to update a Founder.
     */
    data: XOR<FounderUpdateInput, FounderUncheckedUpdateInput>
    /**
     * Choose, which Founder to update.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder updateMany
   */
  export type FounderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Founders.
     */
    data: XOR<FounderUpdateManyMutationInput, FounderUncheckedUpdateManyInput>
    /**
     * Filter which Founders to update
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to update.
     */
    limit?: number
  }

  /**
   * Founder updateManyAndReturn
   */
  export type FounderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * The data used to update Founders.
     */
    data: XOR<FounderUpdateManyMutationInput, FounderUncheckedUpdateManyInput>
    /**
     * Filter which Founders to update
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Founder upsert
   */
  export type FounderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * The filter to search for the Founder to update in case it exists.
     */
    where: FounderWhereUniqueInput
    /**
     * In case the Founder found by the `where` argument doesn't exist, create a new Founder with this data.
     */
    create: XOR<FounderCreateInput, FounderUncheckedCreateInput>
    /**
     * In case the Founder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FounderUpdateInput, FounderUncheckedUpdateInput>
  }

  /**
   * Founder delete
   */
  export type FounderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    /**
     * Filter which Founder to delete.
     */
    where: FounderWhereUniqueInput
  }

  /**
   * Founder deleteMany
   */
  export type FounderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Founders to delete
     */
    where?: FounderWhereInput
    /**
     * Limit how many Founders to delete.
     */
    limit?: number
  }

  /**
   * Founder.tasks
   */
  export type Founder$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    where?: FounderTaskWhereInput
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    cursor?: FounderTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * Founder.crmContacts
   */
  export type Founder$crmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    where?: CrmContactWhereInput
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    cursor?: CrmContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * Founder.roadmapItems
   */
  export type Founder$roadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    cursor?: RoadmapItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * Founder.companyFounders
   */
  export type Founder$companyFoundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    where?: CompanyFounderWhereInput
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    cursor?: CompanyFounderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFounderScalarFieldEnum | CompanyFounderScalarFieldEnum[]
  }

  /**
   * Founder.unifiedTasks
   */
  export type Founder$unifiedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Founder without action
   */
  export type FounderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
  }


  /**
   * Model FounderTask
   */

  export type AggregateFounderTask = {
    _count: FounderTaskCountAggregateOutputType | null
    _min: FounderTaskMinAggregateOutputType | null
    _max: FounderTaskMaxAggregateOutputType | null
  }

  export type FounderTaskMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderTaskMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderTaskCountAggregateOutputType = {
    id: number
    founderId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FounderTaskMinAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderTaskMaxAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderTaskCountAggregateInputType = {
    id?: true
    founderId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FounderTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderTask to aggregate.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FounderTasks
    **/
    _count?: true | FounderTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FounderTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FounderTaskMaxAggregateInputType
  }

  export type GetFounderTaskAggregateType<T extends FounderTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateFounderTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFounderTask[P]>
      : GetScalarType<T[P], AggregateFounderTask[P]>
  }




  export type FounderTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderTaskWhereInput
    orderBy?: FounderTaskOrderByWithAggregationInput | FounderTaskOrderByWithAggregationInput[]
    by: FounderTaskScalarFieldEnum[] | FounderTaskScalarFieldEnum
    having?: FounderTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FounderTaskCountAggregateInputType | true
    _min?: FounderTaskMinAggregateInputType
    _max?: FounderTaskMaxAggregateInputType
  }

  export type FounderTaskGroupByOutputType = {
    id: string
    founderId: string
    title: string
    description: string | null
    status: string
    priority: string
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FounderTaskCountAggregateOutputType | null
    _min: FounderTaskMinAggregateOutputType | null
    _max: FounderTaskMaxAggregateOutputType | null
  }

  type GetFounderTaskGroupByPayload<T extends FounderTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FounderTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FounderTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FounderTaskGroupByOutputType[P]>
            : GetScalarType<T[P], FounderTaskGroupByOutputType[P]>
        }
      >
    >


  export type FounderTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderTask"]>

  export type FounderTaskSelectScalar = {
    id?: boolean
    founderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FounderTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "title" | "description" | "status" | "priority" | "dueDate" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["founderTask"]>
  export type FounderTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type FounderTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type FounderTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $FounderTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FounderTask"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      title: string
      description: string | null
      status: string
      priority: string
      dueDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["founderTask"]>
    composites: {}
  }

  type FounderTaskGetPayload<S extends boolean | null | undefined | FounderTaskDefaultArgs> = $Result.GetResult<Prisma.$FounderTaskPayload, S>

  type FounderTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FounderTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FounderTaskCountAggregateInputType | true
    }

  export interface FounderTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FounderTask'], meta: { name: 'FounderTask' } }
    /**
     * Find zero or one FounderTask that matches the filter.
     * @param {FounderTaskFindUniqueArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FounderTaskFindUniqueArgs>(args: SelectSubset<T, FounderTaskFindUniqueArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FounderTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FounderTaskFindUniqueOrThrowArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FounderTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, FounderTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FounderTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindFirstArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FounderTaskFindFirstArgs>(args?: SelectSubset<T, FounderTaskFindFirstArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FounderTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindFirstOrThrowArgs} args - Arguments to find a FounderTask
     * @example
     * // Get one FounderTask
     * const founderTask = await prisma.founderTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FounderTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, FounderTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FounderTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FounderTasks
     * const founderTasks = await prisma.founderTask.findMany()
     * 
     * // Get first 10 FounderTasks
     * const founderTasks = await prisma.founderTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FounderTaskFindManyArgs>(args?: SelectSubset<T, FounderTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FounderTask.
     * @param {FounderTaskCreateArgs} args - Arguments to create a FounderTask.
     * @example
     * // Create one FounderTask
     * const FounderTask = await prisma.founderTask.create({
     *   data: {
     *     // ... data to create a FounderTask
     *   }
     * })
     * 
     */
    create<T extends FounderTaskCreateArgs>(args: SelectSubset<T, FounderTaskCreateArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FounderTasks.
     * @param {FounderTaskCreateManyArgs} args - Arguments to create many FounderTasks.
     * @example
     * // Create many FounderTasks
     * const founderTask = await prisma.founderTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FounderTaskCreateManyArgs>(args?: SelectSubset<T, FounderTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FounderTasks and returns the data saved in the database.
     * @param {FounderTaskCreateManyAndReturnArgs} args - Arguments to create many FounderTasks.
     * @example
     * // Create many FounderTasks
     * const founderTask = await prisma.founderTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FounderTasks and only return the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FounderTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, FounderTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FounderTask.
     * @param {FounderTaskDeleteArgs} args - Arguments to delete one FounderTask.
     * @example
     * // Delete one FounderTask
     * const FounderTask = await prisma.founderTask.delete({
     *   where: {
     *     // ... filter to delete one FounderTask
     *   }
     * })
     * 
     */
    delete<T extends FounderTaskDeleteArgs>(args: SelectSubset<T, FounderTaskDeleteArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FounderTask.
     * @param {FounderTaskUpdateArgs} args - Arguments to update one FounderTask.
     * @example
     * // Update one FounderTask
     * const founderTask = await prisma.founderTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FounderTaskUpdateArgs>(args: SelectSubset<T, FounderTaskUpdateArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FounderTasks.
     * @param {FounderTaskDeleteManyArgs} args - Arguments to filter FounderTasks to delete.
     * @example
     * // Delete a few FounderTasks
     * const { count } = await prisma.founderTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FounderTaskDeleteManyArgs>(args?: SelectSubset<T, FounderTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FounderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FounderTasks
     * const founderTask = await prisma.founderTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FounderTaskUpdateManyArgs>(args: SelectSubset<T, FounderTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FounderTasks and returns the data updated in the database.
     * @param {FounderTaskUpdateManyAndReturnArgs} args - Arguments to update many FounderTasks.
     * @example
     * // Update many FounderTasks
     * const founderTask = await prisma.founderTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FounderTasks and only return the `id`
     * const founderTaskWithIdOnly = await prisma.founderTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FounderTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, FounderTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FounderTask.
     * @param {FounderTaskUpsertArgs} args - Arguments to update or create a FounderTask.
     * @example
     * // Update or create a FounderTask
     * const founderTask = await prisma.founderTask.upsert({
     *   create: {
     *     // ... data to create a FounderTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FounderTask we want to update
     *   }
     * })
     */
    upsert<T extends FounderTaskUpsertArgs>(args: SelectSubset<T, FounderTaskUpsertArgs<ExtArgs>>): Prisma__FounderTaskClient<$Result.GetResult<Prisma.$FounderTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FounderTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskCountArgs} args - Arguments to filter FounderTasks to count.
     * @example
     * // Count the number of FounderTasks
     * const count = await prisma.founderTask.count({
     *   where: {
     *     // ... the filter for the FounderTasks we want to count
     *   }
     * })
    **/
    count<T extends FounderTaskCountArgs>(
      args?: Subset<T, FounderTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FounderTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FounderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FounderTaskAggregateArgs>(args: Subset<T, FounderTaskAggregateArgs>): Prisma.PrismaPromise<GetFounderTaskAggregateType<T>>

    /**
     * Group by FounderTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FounderTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FounderTaskGroupByArgs['orderBy'] }
        : { orderBy?: FounderTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FounderTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFounderTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FounderTask model
   */
  readonly fields: FounderTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FounderTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FounderTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FounderTask model
   */
  interface FounderTaskFieldRefs {
    readonly id: FieldRef<"FounderTask", 'String'>
    readonly founderId: FieldRef<"FounderTask", 'String'>
    readonly title: FieldRef<"FounderTask", 'String'>
    readonly description: FieldRef<"FounderTask", 'String'>
    readonly status: FieldRef<"FounderTask", 'String'>
    readonly priority: FieldRef<"FounderTask", 'String'>
    readonly dueDate: FieldRef<"FounderTask", 'DateTime'>
    readonly completedAt: FieldRef<"FounderTask", 'DateTime'>
    readonly createdAt: FieldRef<"FounderTask", 'DateTime'>
    readonly updatedAt: FieldRef<"FounderTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FounderTask findUnique
   */
  export type FounderTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask findUniqueOrThrow
   */
  export type FounderTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask findFirst
   */
  export type FounderTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderTasks.
     */
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask findFirstOrThrow
   */
  export type FounderTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTask to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderTasks.
     */
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask findMany
   */
  export type FounderTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter, which FounderTasks to fetch.
     */
    where?: FounderTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderTasks to fetch.
     */
    orderBy?: FounderTaskOrderByWithRelationInput | FounderTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FounderTasks.
     */
    cursor?: FounderTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderTasks.
     */
    skip?: number
    distinct?: FounderTaskScalarFieldEnum | FounderTaskScalarFieldEnum[]
  }

  /**
   * FounderTask create
   */
  export type FounderTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a FounderTask.
     */
    data: XOR<FounderTaskCreateInput, FounderTaskUncheckedCreateInput>
  }

  /**
   * FounderTask createMany
   */
  export type FounderTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FounderTasks.
     */
    data: FounderTaskCreateManyInput | FounderTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FounderTask createManyAndReturn
   */
  export type FounderTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * The data used to create many FounderTasks.
     */
    data: FounderTaskCreateManyInput | FounderTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FounderTask update
   */
  export type FounderTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a FounderTask.
     */
    data: XOR<FounderTaskUpdateInput, FounderTaskUncheckedUpdateInput>
    /**
     * Choose, which FounderTask to update.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask updateMany
   */
  export type FounderTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FounderTasks.
     */
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyInput>
    /**
     * Filter which FounderTasks to update
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to update.
     */
    limit?: number
  }

  /**
   * FounderTask updateManyAndReturn
   */
  export type FounderTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * The data used to update FounderTasks.
     */
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyInput>
    /**
     * Filter which FounderTasks to update
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FounderTask upsert
   */
  export type FounderTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the FounderTask to update in case it exists.
     */
    where: FounderTaskWhereUniqueInput
    /**
     * In case the FounderTask found by the `where` argument doesn't exist, create a new FounderTask with this data.
     */
    create: XOR<FounderTaskCreateInput, FounderTaskUncheckedCreateInput>
    /**
     * In case the FounderTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FounderTaskUpdateInput, FounderTaskUncheckedUpdateInput>
  }

  /**
   * FounderTask delete
   */
  export type FounderTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
    /**
     * Filter which FounderTask to delete.
     */
    where: FounderTaskWhereUniqueInput
  }

  /**
   * FounderTask deleteMany
   */
  export type FounderTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderTasks to delete
     */
    where?: FounderTaskWhereInput
    /**
     * Limit how many FounderTasks to delete.
     */
    limit?: number
  }

  /**
   * FounderTask without action
   */
  export type FounderTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderTask
     */
    select?: FounderTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FounderTask
     */
    omit?: FounderTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderTaskInclude<ExtArgs> | null
  }


  /**
   * Model CrmContact
   */

  export type AggregateCrmContact = {
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  export type CrmContactMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    name: string | null
    role: string | null
    email: string | null
    company: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    name: string | null
    role: string | null
    email: string | null
    company: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactCountAggregateOutputType = {
    id: number
    founderId: number
    name: number
    role: number
    email: number
    company: number
    pipeline: number
    status: number
    nextStep: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrmContactMinAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactMaxAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactCountAggregateInputType = {
    id?: true
    founderId?: true
    name?: true
    role?: true
    email?: true
    company?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrmContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContact to aggregate.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmContacts
    **/
    _count?: true | CrmContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmContactMaxAggregateInputType
  }

  export type GetCrmContactAggregateType<T extends CrmContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmContact[P]>
      : GetScalarType<T[P], AggregateCrmContact[P]>
  }




  export type CrmContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmContactWhereInput
    orderBy?: CrmContactOrderByWithAggregationInput | CrmContactOrderByWithAggregationInput[]
    by: CrmContactScalarFieldEnum[] | CrmContactScalarFieldEnum
    having?: CrmContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmContactCountAggregateInputType | true
    _min?: CrmContactMinAggregateInputType
    _max?: CrmContactMaxAggregateInputType
  }

  export type CrmContactGroupByOutputType = {
    id: string
    founderId: string
    name: string
    role: string | null
    email: string | null
    company: string | null
    pipeline: string
    status: string
    nextStep: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  type GetCrmContactGroupByPayload<T extends CrmContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
            : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
        }
      >
    >


  export type CrmContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectScalar = {
    id?: boolean
    founderId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    company?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrmContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "name" | "role" | "email" | "company" | "pipeline" | "status" | "nextStep" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["crmContact"]>
  export type CrmContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CrmContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CrmContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $CrmContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmContact"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      name: string
      role: string | null
      email: string | null
      company: string | null
      pipeline: string
      status: string
      nextStep: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crmContact"]>
    composites: {}
  }

  type CrmContactGetPayload<S extends boolean | null | undefined | CrmContactDefaultArgs> = $Result.GetResult<Prisma.$CrmContactPayload, S>

  type CrmContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrmContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrmContactCountAggregateInputType | true
    }

  export interface CrmContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmContact'], meta: { name: 'CrmContact' } }
    /**
     * Find zero or one CrmContact that matches the filter.
     * @param {CrmContactFindUniqueArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmContactFindUniqueArgs>(args: SelectSubset<T, CrmContactFindUniqueArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrmContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrmContactFindUniqueOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrmContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmContactFindFirstArgs>(args?: SelectSubset<T, CrmContactFindFirstArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrmContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrmContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmContacts
     * const crmContacts = await prisma.crmContact.findMany()
     * 
     * // Get first 10 CrmContacts
     * const crmContacts = await prisma.crmContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmContactFindManyArgs>(args?: SelectSubset<T, CrmContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrmContact.
     * @param {CrmContactCreateArgs} args - Arguments to create a CrmContact.
     * @example
     * // Create one CrmContact
     * const CrmContact = await prisma.crmContact.create({
     *   data: {
     *     // ... data to create a CrmContact
     *   }
     * })
     * 
     */
    create<T extends CrmContactCreateArgs>(args: SelectSubset<T, CrmContactCreateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrmContacts.
     * @param {CrmContactCreateManyArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmContactCreateManyArgs>(args?: SelectSubset<T, CrmContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmContacts and returns the data saved in the database.
     * @param {CrmContactCreateManyAndReturnArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmContacts and only return the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrmContact.
     * @param {CrmContactDeleteArgs} args - Arguments to delete one CrmContact.
     * @example
     * // Delete one CrmContact
     * const CrmContact = await prisma.crmContact.delete({
     *   where: {
     *     // ... filter to delete one CrmContact
     *   }
     * })
     * 
     */
    delete<T extends CrmContactDeleteArgs>(args: SelectSubset<T, CrmContactDeleteArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrmContact.
     * @param {CrmContactUpdateArgs} args - Arguments to update one CrmContact.
     * @example
     * // Update one CrmContact
     * const crmContact = await prisma.crmContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmContactUpdateArgs>(args: SelectSubset<T, CrmContactUpdateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrmContacts.
     * @param {CrmContactDeleteManyArgs} args - Arguments to filter CrmContacts to delete.
     * @example
     * // Delete a few CrmContacts
     * const { count } = await prisma.crmContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmContactDeleteManyArgs>(args?: SelectSubset<T, CrmContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmContacts
     * const crmContact = await prisma.crmContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmContactUpdateManyArgs>(args: SelectSubset<T, CrmContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmContacts and returns the data updated in the database.
     * @param {CrmContactUpdateManyAndReturnArgs} args - Arguments to update many CrmContacts.
     * @example
     * // Update many CrmContacts
     * const crmContact = await prisma.crmContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrmContacts and only return the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrmContactUpdateManyAndReturnArgs>(args: SelectSubset<T, CrmContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrmContact.
     * @param {CrmContactUpsertArgs} args - Arguments to update or create a CrmContact.
     * @example
     * // Update or create a CrmContact
     * const crmContact = await prisma.crmContact.upsert({
     *   create: {
     *     // ... data to create a CrmContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmContact we want to update
     *   }
     * })
     */
    upsert<T extends CrmContactUpsertArgs>(args: SelectSubset<T, CrmContactUpsertArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactCountArgs} args - Arguments to filter CrmContacts to count.
     * @example
     * // Count the number of CrmContacts
     * const count = await prisma.crmContact.count({
     *   where: {
     *     // ... the filter for the CrmContacts we want to count
     *   }
     * })
    **/
    count<T extends CrmContactCountArgs>(
      args?: Subset<T, CrmContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmContactAggregateArgs>(args: Subset<T, CrmContactAggregateArgs>): Prisma.PrismaPromise<GetCrmContactAggregateType<T>>

    /**
     * Group by CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmContactGroupByArgs['orderBy'] }
        : { orderBy?: CrmContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmContact model
   */
  readonly fields: CrmContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmContact model
   */
  interface CrmContactFieldRefs {
    readonly id: FieldRef<"CrmContact", 'String'>
    readonly founderId: FieldRef<"CrmContact", 'String'>
    readonly name: FieldRef<"CrmContact", 'String'>
    readonly role: FieldRef<"CrmContact", 'String'>
    readonly email: FieldRef<"CrmContact", 'String'>
    readonly company: FieldRef<"CrmContact", 'String'>
    readonly pipeline: FieldRef<"CrmContact", 'String'>
    readonly status: FieldRef<"CrmContact", 'String'>
    readonly nextStep: FieldRef<"CrmContact", 'String'>
    readonly notes: FieldRef<"CrmContact", 'String'>
    readonly createdAt: FieldRef<"CrmContact", 'DateTime'>
    readonly updatedAt: FieldRef<"CrmContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmContact findUnique
   */
  export type CrmContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findUniqueOrThrow
   */
  export type CrmContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findFirst
   */
  export type CrmContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findFirstOrThrow
   */
  export type CrmContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findMany
   */
  export type CrmContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContacts to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact create
   */
  export type CrmContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmContact.
     */
    data: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
  }

  /**
   * CrmContact createMany
   */
  export type CrmContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmContact createManyAndReturn
   */
  export type CrmContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmContact update
   */
  export type CrmContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmContact.
     */
    data: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
    /**
     * Choose, which CrmContact to update.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact updateMany
   */
  export type CrmContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmContacts.
     */
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CrmContacts to update
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to update.
     */
    limit?: number
  }

  /**
   * CrmContact updateManyAndReturn
   */
  export type CrmContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * The data used to update CrmContacts.
     */
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CrmContacts to update
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmContact upsert
   */
  export type CrmContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmContact to update in case it exists.
     */
    where: CrmContactWhereUniqueInput
    /**
     * In case the CrmContact found by the `where` argument doesn't exist, create a new CrmContact with this data.
     */
    create: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
    /**
     * In case the CrmContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
  }

  /**
   * CrmContact delete
   */
  export type CrmContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter which CrmContact to delete.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact deleteMany
   */
  export type CrmContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContacts to delete
     */
    where?: CrmContactWhereInput
    /**
     * Limit how many CrmContacts to delete.
     */
    limit?: number
  }

  /**
   * CrmContact without action
   */
  export type CrmContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrmContact
     */
    omit?: CrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapItem
   */

  export type AggregateRoadmapItem = {
    _count: RoadmapItemCountAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  export type RoadmapItemMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    roadmapType: string | null
    quarter: string | null
    category: string | null
    title: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    roadmapType: string | null
    quarter: string | null
    category: string | null
    title: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemCountAggregateOutputType = {
    id: number
    founderId: number
    roadmapType: number
    quarter: number
    category: number
    title: number
    description: number
    status: number
    dueDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapItemMinAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemMaxAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemCountAggregateInputType = {
    id?: true
    founderId?: true
    roadmapType?: true
    quarter?: true
    category?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItem to aggregate.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapItems
    **/
    _count?: true | RoadmapItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type GetRoadmapItemAggregateType<T extends RoadmapItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapItem[P]>
      : GetScalarType<T[P], AggregateRoadmapItem[P]>
  }




  export type RoadmapItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithAggregationInput | RoadmapItemOrderByWithAggregationInput[]
    by: RoadmapItemScalarFieldEnum[] | RoadmapItemScalarFieldEnum
    having?: RoadmapItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapItemCountAggregateInputType | true
    _min?: RoadmapItemMinAggregateInputType
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type RoadmapItemGroupByOutputType = {
    id: string
    founderId: string
    roadmapType: string
    quarter: string | null
    category: string | null
    title: string
    description: string | null
    status: string
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoadmapItemCountAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  type GetRoadmapItemGroupByPayload<T extends RoadmapItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>

  export type RoadmapItemSelectScalar = {
    id?: boolean
    founderId?: boolean
    roadmapType?: boolean
    quarter?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "roadmapType" | "quarter" | "category" | "title" | "description" | "status" | "dueDate" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["roadmapItem"]>
  export type RoadmapItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type RoadmapItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type RoadmapItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $RoadmapItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapItem"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      roadmapType: string
      quarter: string | null
      category: string | null
      title: string
      description: string | null
      status: string
      dueDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapItem"]>
    composites: {}
  }

  type RoadmapItemGetPayload<S extends boolean | null | undefined | RoadmapItemDefaultArgs> = $Result.GetResult<Prisma.$RoadmapItemPayload, S>

  type RoadmapItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapItemCountAggregateInputType | true
    }

  export interface RoadmapItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapItem'], meta: { name: 'RoadmapItem' } }
    /**
     * Find zero or one RoadmapItem that matches the filter.
     * @param {RoadmapItemFindUniqueArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapItemFindUniqueArgs>(args: SelectSubset<T, RoadmapItemFindUniqueArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapItemFindUniqueOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapItemFindFirstArgs>(args?: SelectSubset<T, RoadmapItemFindFirstArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany()
     * 
     * // Get first 10 RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapItemFindManyArgs>(args?: SelectSubset<T, RoadmapItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapItem.
     * @param {RoadmapItemCreateArgs} args - Arguments to create a RoadmapItem.
     * @example
     * // Create one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.create({
     *   data: {
     *     // ... data to create a RoadmapItem
     *   }
     * })
     * 
     */
    create<T extends RoadmapItemCreateArgs>(args: SelectSubset<T, RoadmapItemCreateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapItems.
     * @param {RoadmapItemCreateManyArgs} args - Arguments to create many RoadmapItems.
     * @example
     * // Create many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapItemCreateManyArgs>(args?: SelectSubset<T, RoadmapItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapItems and returns the data saved in the database.
     * @param {RoadmapItemCreateManyAndReturnArgs} args - Arguments to create many RoadmapItems.
     * @example
     * // Create many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapItems and only return the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoadmapItem.
     * @param {RoadmapItemDeleteArgs} args - Arguments to delete one RoadmapItem.
     * @example
     * // Delete one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.delete({
     *   where: {
     *     // ... filter to delete one RoadmapItem
     *   }
     * })
     * 
     */
    delete<T extends RoadmapItemDeleteArgs>(args: SelectSubset<T, RoadmapItemDeleteArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapItem.
     * @param {RoadmapItemUpdateArgs} args - Arguments to update one RoadmapItem.
     * @example
     * // Update one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapItemUpdateArgs>(args: SelectSubset<T, RoadmapItemUpdateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapItems.
     * @param {RoadmapItemDeleteManyArgs} args - Arguments to filter RoadmapItems to delete.
     * @example
     * // Delete a few RoadmapItems
     * const { count } = await prisma.roadmapItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapItemDeleteManyArgs>(args?: SelectSubset<T, RoadmapItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapItemUpdateManyArgs>(args: SelectSubset<T, RoadmapItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapItems and returns the data updated in the database.
     * @param {RoadmapItemUpdateManyAndReturnArgs} args - Arguments to update many RoadmapItems.
     * @example
     * // Update many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoadmapItems and only return the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoadmapItem.
     * @param {RoadmapItemUpsertArgs} args - Arguments to update or create a RoadmapItem.
     * @example
     * // Update or create a RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.upsert({
     *   create: {
     *     // ... data to create a RoadmapItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapItem we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapItemUpsertArgs>(args: SelectSubset<T, RoadmapItemUpsertArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemCountArgs} args - Arguments to filter RoadmapItems to count.
     * @example
     * // Count the number of RoadmapItems
     * const count = await prisma.roadmapItem.count({
     *   where: {
     *     // ... the filter for the RoadmapItems we want to count
     *   }
     * })
    **/
    count<T extends RoadmapItemCountArgs>(
      args?: Subset<T, RoadmapItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapItemAggregateArgs>(args: Subset<T, RoadmapItemAggregateArgs>): Prisma.PrismaPromise<GetRoadmapItemAggregateType<T>>

    /**
     * Group by RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapItemGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapItem model
   */
  readonly fields: RoadmapItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapItem model
   */
  interface RoadmapItemFieldRefs {
    readonly id: FieldRef<"RoadmapItem", 'String'>
    readonly founderId: FieldRef<"RoadmapItem", 'String'>
    readonly roadmapType: FieldRef<"RoadmapItem", 'String'>
    readonly quarter: FieldRef<"RoadmapItem", 'String'>
    readonly category: FieldRef<"RoadmapItem", 'String'>
    readonly title: FieldRef<"RoadmapItem", 'String'>
    readonly description: FieldRef<"RoadmapItem", 'String'>
    readonly status: FieldRef<"RoadmapItem", 'String'>
    readonly dueDate: FieldRef<"RoadmapItem", 'DateTime'>
    readonly completedAt: FieldRef<"RoadmapItem", 'DateTime'>
    readonly createdAt: FieldRef<"RoadmapItem", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapItem findUnique
   */
  export type RoadmapItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findUniqueOrThrow
   */
  export type RoadmapItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findFirst
   */
  export type RoadmapItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findFirstOrThrow
   */
  export type RoadmapItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findMany
   */
  export type RoadmapItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItems to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem create
   */
  export type RoadmapItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapItem.
     */
    data: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
  }

  /**
   * RoadmapItem createMany
   */
  export type RoadmapItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapItems.
     */
    data: RoadmapItemCreateManyInput | RoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapItem createManyAndReturn
   */
  export type RoadmapItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to create many RoadmapItems.
     */
    data: RoadmapItemCreateManyInput | RoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapItem update
   */
  export type RoadmapItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapItem.
     */
    data: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
    /**
     * Choose, which RoadmapItem to update.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem updateMany
   */
  export type RoadmapItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapItems.
     */
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapItems to update
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to update.
     */
    limit?: number
  }

  /**
   * RoadmapItem updateManyAndReturn
   */
  export type RoadmapItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to update RoadmapItems.
     */
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapItems to update
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapItem upsert
   */
  export type RoadmapItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapItem to update in case it exists.
     */
    where: RoadmapItemWhereUniqueInput
    /**
     * In case the RoadmapItem found by the `where` argument doesn't exist, create a new RoadmapItem with this data.
     */
    create: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
    /**
     * In case the RoadmapItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
  }

  /**
   * RoadmapItem delete
   */
  export type RoadmapItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter which RoadmapItem to delete.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem deleteMany
   */
  export type RoadmapItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItems to delete
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to delete.
     */
    limit?: number
  }

  /**
   * RoadmapItem without action
   */
  export type RoadmapItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    website: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    address: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founders?: boolean | Company$foundersArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    roadmapItems?: boolean | Company$roadmapItemsArgs<ExtArgs>
    tasks?: boolean | Company$tasksArgs<ExtArgs>
    crmContacts?: boolean | Company$crmContactsArgs<ExtArgs>
    financialSpends?: boolean | Company$financialSpendsArgs<ExtArgs>
    financialProjections?: boolean | Company$financialProjectionsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "website" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founders?: boolean | Company$foundersArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    roadmapItems?: boolean | Company$roadmapItemsArgs<ExtArgs>
    tasks?: boolean | Company$tasksArgs<ExtArgs>
    crmContacts?: boolean | Company$crmContactsArgs<ExtArgs>
    financialSpends?: boolean | Company$financialSpendsArgs<ExtArgs>
    financialProjections?: boolean | Company$financialProjectionsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      founders: Prisma.$CompanyFounderPayload<ExtArgs>[]
      employees: Prisma.$CompanyEmployeePayload<ExtArgs>[]
      roadmapItems: Prisma.$CompanyRoadmapItemPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      crmContacts: Prisma.$CompanyCrmContactPayload<ExtArgs>[]
      financialSpends: Prisma.$CompanyFinancialSpendPayload<ExtArgs>[]
      financialProjections: Prisma.$CompanyFinancialProjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      website: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founders<T extends Company$foundersArgs<ExtArgs> = {}>(args?: Subset<T, Company$foundersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Company$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Company$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapItems<T extends Company$roadmapItemsArgs<ExtArgs> = {}>(args?: Subset<T, Company$roadmapItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Company$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Company$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crmContacts<T extends Company$crmContactsArgs<ExtArgs> = {}>(args?: Subset<T, Company$crmContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialSpends<T extends Company$financialSpendsArgs<ExtArgs> = {}>(args?: Subset<T, Company$financialSpendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialProjections<T extends Company$financialProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$financialProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.founders
   */
  export type Company$foundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    where?: CompanyFounderWhereInput
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    cursor?: CompanyFounderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFounderScalarFieldEnum | CompanyFounderScalarFieldEnum[]
  }

  /**
   * Company.employees
   */
  export type Company$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    where?: CompanyEmployeeWhereInput
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    cursor?: CompanyEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * Company.roadmapItems
   */
  export type Company$roadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    where?: CompanyRoadmapItemWhereInput
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    cursor?: CompanyRoadmapItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyRoadmapItemScalarFieldEnum | CompanyRoadmapItemScalarFieldEnum[]
  }

  /**
   * Company.tasks
   */
  export type Company$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Company.crmContacts
   */
  export type Company$crmContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    where?: CompanyCrmContactWhereInput
    orderBy?: CompanyCrmContactOrderByWithRelationInput | CompanyCrmContactOrderByWithRelationInput[]
    cursor?: CompanyCrmContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyCrmContactScalarFieldEnum | CompanyCrmContactScalarFieldEnum[]
  }

  /**
   * Company.financialSpends
   */
  export type Company$financialSpendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    where?: CompanyFinancialSpendWhereInput
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    cursor?: CompanyFinancialSpendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFinancialSpendScalarFieldEnum | CompanyFinancialSpendScalarFieldEnum[]
  }

  /**
   * Company.financialProjections
   */
  export type Company$financialProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    where?: CompanyFinancialProjectionWhereInput
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFinancialProjectionScalarFieldEnum | CompanyFinancialProjectionScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyFounder
   */

  export type AggregateCompanyFounder = {
    _count: CompanyFounderCountAggregateOutputType | null
    _min: CompanyFounderMinAggregateOutputType | null
    _max: CompanyFounderMaxAggregateOutputType | null
  }

  export type CompanyFounderMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    founderId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type CompanyFounderMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    founderId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type CompanyFounderCountAggregateOutputType = {
    id: number
    companyId: number
    founderId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type CompanyFounderMinAggregateInputType = {
    id?: true
    companyId?: true
    founderId?: true
    role?: true
    joinedAt?: true
  }

  export type CompanyFounderMaxAggregateInputType = {
    id?: true
    companyId?: true
    founderId?: true
    role?: true
    joinedAt?: true
  }

  export type CompanyFounderCountAggregateInputType = {
    id?: true
    companyId?: true
    founderId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type CompanyFounderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFounder to aggregate.
     */
    where?: CompanyFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFounders to fetch.
     */
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyFounders
    **/
    _count?: true | CompanyFounderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyFounderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyFounderMaxAggregateInputType
  }

  export type GetCompanyFounderAggregateType<T extends CompanyFounderAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyFounder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyFounder[P]>
      : GetScalarType<T[P], AggregateCompanyFounder[P]>
  }




  export type CompanyFounderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFounderWhereInput
    orderBy?: CompanyFounderOrderByWithAggregationInput | CompanyFounderOrderByWithAggregationInput[]
    by: CompanyFounderScalarFieldEnum[] | CompanyFounderScalarFieldEnum
    having?: CompanyFounderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyFounderCountAggregateInputType | true
    _min?: CompanyFounderMinAggregateInputType
    _max?: CompanyFounderMaxAggregateInputType
  }

  export type CompanyFounderGroupByOutputType = {
    id: string
    companyId: string
    founderId: string
    role: string | null
    joinedAt: Date
    _count: CompanyFounderCountAggregateOutputType | null
    _min: CompanyFounderMinAggregateOutputType | null
    _max: CompanyFounderMaxAggregateOutputType | null
  }

  type GetCompanyFounderGroupByPayload<T extends CompanyFounderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyFounderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyFounderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyFounderGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyFounderGroupByOutputType[P]>
        }
      >
    >


  export type CompanyFounderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    founderId?: boolean
    role?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFounder"]>

  export type CompanyFounderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    founderId?: boolean
    role?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFounder"]>

  export type CompanyFounderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    founderId?: boolean
    role?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFounder"]>

  export type CompanyFounderSelectScalar = {
    id?: boolean
    companyId?: boolean
    founderId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type CompanyFounderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "founderId" | "role" | "joinedAt", ExtArgs["result"]["companyFounder"]>
  export type CompanyFounderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CompanyFounderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }
  export type CompanyFounderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    founder?: boolean | FounderDefaultArgs<ExtArgs>
  }

  export type $CompanyFounderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyFounder"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      founder: Prisma.$FounderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      founderId: string
      role: string | null
      joinedAt: Date
    }, ExtArgs["result"]["companyFounder"]>
    composites: {}
  }

  type CompanyFounderGetPayload<S extends boolean | null | undefined | CompanyFounderDefaultArgs> = $Result.GetResult<Prisma.$CompanyFounderPayload, S>

  type CompanyFounderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFounderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyFounderCountAggregateInputType | true
    }

  export interface CompanyFounderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyFounder'], meta: { name: 'CompanyFounder' } }
    /**
     * Find zero or one CompanyFounder that matches the filter.
     * @param {CompanyFounderFindUniqueArgs} args - Arguments to find a CompanyFounder
     * @example
     * // Get one CompanyFounder
     * const companyFounder = await prisma.companyFounder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFounderFindUniqueArgs>(args: SelectSubset<T, CompanyFounderFindUniqueArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyFounder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFounderFindUniqueOrThrowArgs} args - Arguments to find a CompanyFounder
     * @example
     * // Get one CompanyFounder
     * const companyFounder = await prisma.companyFounder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFounderFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFounderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFounder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderFindFirstArgs} args - Arguments to find a CompanyFounder
     * @example
     * // Get one CompanyFounder
     * const companyFounder = await prisma.companyFounder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFounderFindFirstArgs>(args?: SelectSubset<T, CompanyFounderFindFirstArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFounder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderFindFirstOrThrowArgs} args - Arguments to find a CompanyFounder
     * @example
     * // Get one CompanyFounder
     * const companyFounder = await prisma.companyFounder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFounderFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFounderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyFounders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyFounders
     * const companyFounders = await prisma.companyFounder.findMany()
     * 
     * // Get first 10 CompanyFounders
     * const companyFounders = await prisma.companyFounder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyFounderWithIdOnly = await prisma.companyFounder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFounderFindManyArgs>(args?: SelectSubset<T, CompanyFounderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyFounder.
     * @param {CompanyFounderCreateArgs} args - Arguments to create a CompanyFounder.
     * @example
     * // Create one CompanyFounder
     * const CompanyFounder = await prisma.companyFounder.create({
     *   data: {
     *     // ... data to create a CompanyFounder
     *   }
     * })
     * 
     */
    create<T extends CompanyFounderCreateArgs>(args: SelectSubset<T, CompanyFounderCreateArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyFounders.
     * @param {CompanyFounderCreateManyArgs} args - Arguments to create many CompanyFounders.
     * @example
     * // Create many CompanyFounders
     * const companyFounder = await prisma.companyFounder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyFounderCreateManyArgs>(args?: SelectSubset<T, CompanyFounderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyFounders and returns the data saved in the database.
     * @param {CompanyFounderCreateManyAndReturnArgs} args - Arguments to create many CompanyFounders.
     * @example
     * // Create many CompanyFounders
     * const companyFounder = await prisma.companyFounder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyFounders and only return the `id`
     * const companyFounderWithIdOnly = await prisma.companyFounder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyFounderCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyFounderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyFounder.
     * @param {CompanyFounderDeleteArgs} args - Arguments to delete one CompanyFounder.
     * @example
     * // Delete one CompanyFounder
     * const CompanyFounder = await prisma.companyFounder.delete({
     *   where: {
     *     // ... filter to delete one CompanyFounder
     *   }
     * })
     * 
     */
    delete<T extends CompanyFounderDeleteArgs>(args: SelectSubset<T, CompanyFounderDeleteArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyFounder.
     * @param {CompanyFounderUpdateArgs} args - Arguments to update one CompanyFounder.
     * @example
     * // Update one CompanyFounder
     * const companyFounder = await prisma.companyFounder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyFounderUpdateArgs>(args: SelectSubset<T, CompanyFounderUpdateArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyFounders.
     * @param {CompanyFounderDeleteManyArgs} args - Arguments to filter CompanyFounders to delete.
     * @example
     * // Delete a few CompanyFounders
     * const { count } = await prisma.companyFounder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyFounderDeleteManyArgs>(args?: SelectSubset<T, CompanyFounderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFounders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyFounders
     * const companyFounder = await prisma.companyFounder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyFounderUpdateManyArgs>(args: SelectSubset<T, CompanyFounderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFounders and returns the data updated in the database.
     * @param {CompanyFounderUpdateManyAndReturnArgs} args - Arguments to update many CompanyFounders.
     * @example
     * // Update many CompanyFounders
     * const companyFounder = await prisma.companyFounder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyFounders and only return the `id`
     * const companyFounderWithIdOnly = await prisma.companyFounder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyFounderUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyFounderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyFounder.
     * @param {CompanyFounderUpsertArgs} args - Arguments to update or create a CompanyFounder.
     * @example
     * // Update or create a CompanyFounder
     * const companyFounder = await prisma.companyFounder.upsert({
     *   create: {
     *     // ... data to create a CompanyFounder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyFounder we want to update
     *   }
     * })
     */
    upsert<T extends CompanyFounderUpsertArgs>(args: SelectSubset<T, CompanyFounderUpsertArgs<ExtArgs>>): Prisma__CompanyFounderClient<$Result.GetResult<Prisma.$CompanyFounderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyFounders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderCountArgs} args - Arguments to filter CompanyFounders to count.
     * @example
     * // Count the number of CompanyFounders
     * const count = await prisma.companyFounder.count({
     *   where: {
     *     // ... the filter for the CompanyFounders we want to count
     *   }
     * })
    **/
    count<T extends CompanyFounderCountArgs>(
      args?: Subset<T, CompanyFounderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyFounderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyFounder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyFounderAggregateArgs>(args: Subset<T, CompanyFounderAggregateArgs>): Prisma.PrismaPromise<GetCompanyFounderAggregateType<T>>

    /**
     * Group by CompanyFounder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFounderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyFounderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyFounderGroupByArgs['orderBy'] }
        : { orderBy?: CompanyFounderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyFounderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyFounderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyFounder model
   */
  readonly fields: CompanyFounderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyFounder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyFounderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    founder<T extends FounderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderDefaultArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyFounder model
   */
  interface CompanyFounderFieldRefs {
    readonly id: FieldRef<"CompanyFounder", 'String'>
    readonly companyId: FieldRef<"CompanyFounder", 'String'>
    readonly founderId: FieldRef<"CompanyFounder", 'String'>
    readonly role: FieldRef<"CompanyFounder", 'String'>
    readonly joinedAt: FieldRef<"CompanyFounder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyFounder findUnique
   */
  export type CompanyFounderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFounder to fetch.
     */
    where: CompanyFounderWhereUniqueInput
  }

  /**
   * CompanyFounder findUniqueOrThrow
   */
  export type CompanyFounderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFounder to fetch.
     */
    where: CompanyFounderWhereUniqueInput
  }

  /**
   * CompanyFounder findFirst
   */
  export type CompanyFounderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFounder to fetch.
     */
    where?: CompanyFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFounders to fetch.
     */
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFounders.
     */
    cursor?: CompanyFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFounders.
     */
    distinct?: CompanyFounderScalarFieldEnum | CompanyFounderScalarFieldEnum[]
  }

  /**
   * CompanyFounder findFirstOrThrow
   */
  export type CompanyFounderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFounder to fetch.
     */
    where?: CompanyFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFounders to fetch.
     */
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFounders.
     */
    cursor?: CompanyFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFounders.
     */
    distinct?: CompanyFounderScalarFieldEnum | CompanyFounderScalarFieldEnum[]
  }

  /**
   * CompanyFounder findMany
   */
  export type CompanyFounderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFounders to fetch.
     */
    where?: CompanyFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFounders to fetch.
     */
    orderBy?: CompanyFounderOrderByWithRelationInput | CompanyFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyFounders.
     */
    cursor?: CompanyFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFounders.
     */
    skip?: number
    distinct?: CompanyFounderScalarFieldEnum | CompanyFounderScalarFieldEnum[]
  }

  /**
   * CompanyFounder create
   */
  export type CompanyFounderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyFounder.
     */
    data: XOR<CompanyFounderCreateInput, CompanyFounderUncheckedCreateInput>
  }

  /**
   * CompanyFounder createMany
   */
  export type CompanyFounderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyFounders.
     */
    data: CompanyFounderCreateManyInput | CompanyFounderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyFounder createManyAndReturn
   */
  export type CompanyFounderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyFounders.
     */
    data: CompanyFounderCreateManyInput | CompanyFounderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFounder update
   */
  export type CompanyFounderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyFounder.
     */
    data: XOR<CompanyFounderUpdateInput, CompanyFounderUncheckedUpdateInput>
    /**
     * Choose, which CompanyFounder to update.
     */
    where: CompanyFounderWhereUniqueInput
  }

  /**
   * CompanyFounder updateMany
   */
  export type CompanyFounderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyFounders.
     */
    data: XOR<CompanyFounderUpdateManyMutationInput, CompanyFounderUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFounders to update
     */
    where?: CompanyFounderWhereInput
    /**
     * Limit how many CompanyFounders to update.
     */
    limit?: number
  }

  /**
   * CompanyFounder updateManyAndReturn
   */
  export type CompanyFounderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * The data used to update CompanyFounders.
     */
    data: XOR<CompanyFounderUpdateManyMutationInput, CompanyFounderUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFounders to update
     */
    where?: CompanyFounderWhereInput
    /**
     * Limit how many CompanyFounders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFounder upsert
   */
  export type CompanyFounderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyFounder to update in case it exists.
     */
    where: CompanyFounderWhereUniqueInput
    /**
     * In case the CompanyFounder found by the `where` argument doesn't exist, create a new CompanyFounder with this data.
     */
    create: XOR<CompanyFounderCreateInput, CompanyFounderUncheckedCreateInput>
    /**
     * In case the CompanyFounder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyFounderUpdateInput, CompanyFounderUncheckedUpdateInput>
  }

  /**
   * CompanyFounder delete
   */
  export type CompanyFounderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
    /**
     * Filter which CompanyFounder to delete.
     */
    where: CompanyFounderWhereUniqueInput
  }

  /**
   * CompanyFounder deleteMany
   */
  export type CompanyFounderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFounders to delete
     */
    where?: CompanyFounderWhereInput
    /**
     * Limit how many CompanyFounders to delete.
     */
    limit?: number
  }

  /**
   * CompanyFounder without action
   */
  export type CompanyFounderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFounder
     */
    select?: CompanyFounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFounder
     */
    omit?: CompanyFounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFounderInclude<ExtArgs> | null
  }


  /**
   * Model CompanyEmployee
   */

  export type AggregateCompanyEmployee = {
    _count: CompanyEmployeeCountAggregateOutputType | null
    _min: CompanyEmployeeMinAggregateOutputType | null
    _max: CompanyEmployeeMaxAggregateOutputType | null
  }

  export type CompanyEmployeeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    email: string | null
    name: string | null
    role: string | null
    department: string | null
    phoneNumber: string | null
    joinedAt: Date | null
  }

  export type CompanyEmployeeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    email: string | null
    name: string | null
    role: string | null
    department: string | null
    phoneNumber: string | null
    joinedAt: Date | null
  }

  export type CompanyEmployeeCountAggregateOutputType = {
    id: number
    companyId: number
    email: number
    name: number
    role: number
    department: number
    phoneNumber: number
    joinedAt: number
    _all: number
  }


  export type CompanyEmployeeMinAggregateInputType = {
    id?: true
    companyId?: true
    email?: true
    name?: true
    role?: true
    department?: true
    phoneNumber?: true
    joinedAt?: true
  }

  export type CompanyEmployeeMaxAggregateInputType = {
    id?: true
    companyId?: true
    email?: true
    name?: true
    role?: true
    department?: true
    phoneNumber?: true
    joinedAt?: true
  }

  export type CompanyEmployeeCountAggregateInputType = {
    id?: true
    companyId?: true
    email?: true
    name?: true
    role?: true
    department?: true
    phoneNumber?: true
    joinedAt?: true
    _all?: true
  }

  export type CompanyEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEmployee to aggregate.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyEmployees
    **/
    _count?: true | CompanyEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyEmployeeMaxAggregateInputType
  }

  export type GetCompanyEmployeeAggregateType<T extends CompanyEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyEmployee[P]>
      : GetScalarType<T[P], AggregateCompanyEmployee[P]>
  }




  export type CompanyEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEmployeeWhereInput
    orderBy?: CompanyEmployeeOrderByWithAggregationInput | CompanyEmployeeOrderByWithAggregationInput[]
    by: CompanyEmployeeScalarFieldEnum[] | CompanyEmployeeScalarFieldEnum
    having?: CompanyEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyEmployeeCountAggregateInputType | true
    _min?: CompanyEmployeeMinAggregateInputType
    _max?: CompanyEmployeeMaxAggregateInputType
  }

  export type CompanyEmployeeGroupByOutputType = {
    id: string
    companyId: string
    email: string
    name: string
    role: string | null
    department: string | null
    phoneNumber: string | null
    joinedAt: Date
    _count: CompanyEmployeeCountAggregateOutputType | null
    _min: CompanyEmployeeMinAggregateOutputType | null
    _max: CompanyEmployeeMaxAggregateOutputType | null
  }

  type GetCompanyEmployeeGroupByPayload<T extends CompanyEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type CompanyEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    phoneNumber?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEmployee"]>

  export type CompanyEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    phoneNumber?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEmployee"]>

  export type CompanyEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    phoneNumber?: boolean
    joinedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEmployee"]>

  export type CompanyEmployeeSelectScalar = {
    id?: boolean
    companyId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    phoneNumber?: boolean
    joinedAt?: boolean
  }

  export type CompanyEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "email" | "name" | "role" | "department" | "phoneNumber" | "joinedAt", ExtArgs["result"]["companyEmployee"]>
  export type CompanyEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyEmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyEmployee"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      email: string
      name: string
      role: string | null
      department: string | null
      phoneNumber: string | null
      joinedAt: Date
    }, ExtArgs["result"]["companyEmployee"]>
    composites: {}
  }

  type CompanyEmployeeGetPayload<S extends boolean | null | undefined | CompanyEmployeeDefaultArgs> = $Result.GetResult<Prisma.$CompanyEmployeePayload, S>

  type CompanyEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyEmployeeCountAggregateInputType | true
    }

  export interface CompanyEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyEmployee'], meta: { name: 'CompanyEmployee' } }
    /**
     * Find zero or one CompanyEmployee that matches the filter.
     * @param {CompanyEmployeeFindUniqueArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyEmployeeFindUniqueArgs>(args: SelectSubset<T, CompanyEmployeeFindUniqueArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyEmployeeFindUniqueOrThrowArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindFirstArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyEmployeeFindFirstArgs>(args?: SelectSubset<T, CompanyEmployeeFindFirstArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindFirstOrThrowArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyEmployees
     * const companyEmployees = await prisma.companyEmployee.findMany()
     * 
     * // Get first 10 CompanyEmployees
     * const companyEmployees = await prisma.companyEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyEmployeeWithIdOnly = await prisma.companyEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyEmployeeFindManyArgs>(args?: SelectSubset<T, CompanyEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyEmployee.
     * @param {CompanyEmployeeCreateArgs} args - Arguments to create a CompanyEmployee.
     * @example
     * // Create one CompanyEmployee
     * const CompanyEmployee = await prisma.companyEmployee.create({
     *   data: {
     *     // ... data to create a CompanyEmployee
     *   }
     * })
     * 
     */
    create<T extends CompanyEmployeeCreateArgs>(args: SelectSubset<T, CompanyEmployeeCreateArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyEmployees.
     * @param {CompanyEmployeeCreateManyArgs} args - Arguments to create many CompanyEmployees.
     * @example
     * // Create many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyEmployeeCreateManyArgs>(args?: SelectSubset<T, CompanyEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyEmployees and returns the data saved in the database.
     * @param {CompanyEmployeeCreateManyAndReturnArgs} args - Arguments to create many CompanyEmployees.
     * @example
     * // Create many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyEmployees and only return the `id`
     * const companyEmployeeWithIdOnly = await prisma.companyEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyEmployee.
     * @param {CompanyEmployeeDeleteArgs} args - Arguments to delete one CompanyEmployee.
     * @example
     * // Delete one CompanyEmployee
     * const CompanyEmployee = await prisma.companyEmployee.delete({
     *   where: {
     *     // ... filter to delete one CompanyEmployee
     *   }
     * })
     * 
     */
    delete<T extends CompanyEmployeeDeleteArgs>(args: SelectSubset<T, CompanyEmployeeDeleteArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyEmployee.
     * @param {CompanyEmployeeUpdateArgs} args - Arguments to update one CompanyEmployee.
     * @example
     * // Update one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyEmployeeUpdateArgs>(args: SelectSubset<T, CompanyEmployeeUpdateArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyEmployees.
     * @param {CompanyEmployeeDeleteManyArgs} args - Arguments to filter CompanyEmployees to delete.
     * @example
     * // Delete a few CompanyEmployees
     * const { count } = await prisma.companyEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyEmployeeDeleteManyArgs>(args?: SelectSubset<T, CompanyEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyEmployeeUpdateManyArgs>(args: SelectSubset<T, CompanyEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyEmployees and returns the data updated in the database.
     * @param {CompanyEmployeeUpdateManyAndReturnArgs} args - Arguments to update many CompanyEmployees.
     * @example
     * // Update many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyEmployees and only return the `id`
     * const companyEmployeeWithIdOnly = await prisma.companyEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyEmployee.
     * @param {CompanyEmployeeUpsertArgs} args - Arguments to update or create a CompanyEmployee.
     * @example
     * // Update or create a CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.upsert({
     *   create: {
     *     // ... data to create a CompanyEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyEmployee we want to update
     *   }
     * })
     */
    upsert<T extends CompanyEmployeeUpsertArgs>(args: SelectSubset<T, CompanyEmployeeUpsertArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeCountArgs} args - Arguments to filter CompanyEmployees to count.
     * @example
     * // Count the number of CompanyEmployees
     * const count = await prisma.companyEmployee.count({
     *   where: {
     *     // ... the filter for the CompanyEmployees we want to count
     *   }
     * })
    **/
    count<T extends CompanyEmployeeCountArgs>(
      args?: Subset<T, CompanyEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyEmployeeAggregateArgs>(args: Subset<T, CompanyEmployeeAggregateArgs>): Prisma.PrismaPromise<GetCompanyEmployeeAggregateType<T>>

    /**
     * Group by CompanyEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: CompanyEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyEmployee model
   */
  readonly fields: CompanyEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyEmployee model
   */
  interface CompanyEmployeeFieldRefs {
    readonly id: FieldRef<"CompanyEmployee", 'String'>
    readonly companyId: FieldRef<"CompanyEmployee", 'String'>
    readonly email: FieldRef<"CompanyEmployee", 'String'>
    readonly name: FieldRef<"CompanyEmployee", 'String'>
    readonly role: FieldRef<"CompanyEmployee", 'String'>
    readonly department: FieldRef<"CompanyEmployee", 'String'>
    readonly phoneNumber: FieldRef<"CompanyEmployee", 'String'>
    readonly joinedAt: FieldRef<"CompanyEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyEmployee findUnique
   */
  export type CompanyEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee findUniqueOrThrow
   */
  export type CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee findFirst
   */
  export type CompanyEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEmployees.
     */
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee findFirstOrThrow
   */
  export type CompanyEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEmployees.
     */
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee findMany
   */
  export type CompanyEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployees to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee create
   */
  export type CompanyEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyEmployee.
     */
    data: XOR<CompanyEmployeeCreateInput, CompanyEmployeeUncheckedCreateInput>
  }

  /**
   * CompanyEmployee createMany
   */
  export type CompanyEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyEmployees.
     */
    data: CompanyEmployeeCreateManyInput | CompanyEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyEmployee createManyAndReturn
   */
  export type CompanyEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyEmployees.
     */
    data: CompanyEmployeeCreateManyInput | CompanyEmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyEmployee update
   */
  export type CompanyEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyEmployee.
     */
    data: XOR<CompanyEmployeeUpdateInput, CompanyEmployeeUncheckedUpdateInput>
    /**
     * Choose, which CompanyEmployee to update.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee updateMany
   */
  export type CompanyEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyEmployees.
     */
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which CompanyEmployees to update
     */
    where?: CompanyEmployeeWhereInput
    /**
     * Limit how many CompanyEmployees to update.
     */
    limit?: number
  }

  /**
   * CompanyEmployee updateManyAndReturn
   */
  export type CompanyEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update CompanyEmployees.
     */
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which CompanyEmployees to update
     */
    where?: CompanyEmployeeWhereInput
    /**
     * Limit how many CompanyEmployees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyEmployee upsert
   */
  export type CompanyEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyEmployee to update in case it exists.
     */
    where: CompanyEmployeeWhereUniqueInput
    /**
     * In case the CompanyEmployee found by the `where` argument doesn't exist, create a new CompanyEmployee with this data.
     */
    create: XOR<CompanyEmployeeCreateInput, CompanyEmployeeUncheckedCreateInput>
    /**
     * In case the CompanyEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyEmployeeUpdateInput, CompanyEmployeeUncheckedUpdateInput>
  }

  /**
   * CompanyEmployee delete
   */
  export type CompanyEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter which CompanyEmployee to delete.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee deleteMany
   */
  export type CompanyEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEmployees to delete
     */
    where?: CompanyEmployeeWhereInput
    /**
     * Limit how many CompanyEmployees to delete.
     */
    limit?: number
  }

  /**
   * CompanyEmployee without action
   */
  export type CompanyEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyEmployee
     */
    omit?: CompanyEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model CompanyRoadmapItem
   */

  export type AggregateCompanyRoadmapItem = {
    _count: CompanyRoadmapItemCountAggregateOutputType | null
    _avg: CompanyRoadmapItemAvgAggregateOutputType | null
    _sum: CompanyRoadmapItemSumAggregateOutputType | null
    _min: CompanyRoadmapItemMinAggregateOutputType | null
    _max: CompanyRoadmapItemMaxAggregateOutputType | null
  }

  export type CompanyRoadmapItemAvgAggregateOutputType = {
    orderNumber: number | null
    hoursEstimated: number | null
    hoursSpent: number | null
  }

  export type CompanyRoadmapItemSumAggregateOutputType = {
    orderNumber: number | null
    hoursEstimated: number | null
    hoursSpent: number | null
  }

  export type CompanyRoadmapItemMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    itemType: string | null
    parentArchitecture: string | null
    roadmapType: string | null
    category: string | null
    title: string | null
    whatItDoes: string | null
    howItHelps: string | null
    fieldsData: string | null
    howToGet: string | null
    prerequisites: string | null
    visual: string | null
    orderNumber: number | null
    hoursEstimated: number | null
    hoursSpent: number | null
    targetDate: Date | null
    dueDate: Date | null
    status: string | null
    priority: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyRoadmapItemMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    itemType: string | null
    parentArchitecture: string | null
    roadmapType: string | null
    category: string | null
    title: string | null
    whatItDoes: string | null
    howItHelps: string | null
    fieldsData: string | null
    howToGet: string | null
    prerequisites: string | null
    visual: string | null
    orderNumber: number | null
    hoursEstimated: number | null
    hoursSpent: number | null
    targetDate: Date | null
    dueDate: Date | null
    status: string | null
    priority: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyRoadmapItemCountAggregateOutputType = {
    id: number
    companyId: number
    itemType: number
    parentArchitecture: number
    roadmapType: number
    category: number
    title: number
    whatItDoes: number
    howItHelps: number
    fieldsData: number
    howToGet: number
    prerequisites: number
    visual: number
    orderNumber: number
    hoursEstimated: number
    hoursSpent: number
    targetDate: number
    dueDate: number
    status: number
    priority: number
    completedAt: number
    createdAt: number
    updatedAt: number
    goFastCompanyId: number
    _all: number
  }


  export type CompanyRoadmapItemAvgAggregateInputType = {
    orderNumber?: true
    hoursEstimated?: true
    hoursSpent?: true
  }

  export type CompanyRoadmapItemSumAggregateInputType = {
    orderNumber?: true
    hoursEstimated?: true
    hoursSpent?: true
  }

  export type CompanyRoadmapItemMinAggregateInputType = {
    id?: true
    companyId?: true
    itemType?: true
    parentArchitecture?: true
    roadmapType?: true
    category?: true
    title?: true
    whatItDoes?: true
    howItHelps?: true
    fieldsData?: true
    howToGet?: true
    prerequisites?: true
    visual?: true
    orderNumber?: true
    hoursEstimated?: true
    hoursSpent?: true
    targetDate?: true
    dueDate?: true
    status?: true
    priority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyRoadmapItemMaxAggregateInputType = {
    id?: true
    companyId?: true
    itemType?: true
    parentArchitecture?: true
    roadmapType?: true
    category?: true
    title?: true
    whatItDoes?: true
    howItHelps?: true
    fieldsData?: true
    howToGet?: true
    prerequisites?: true
    visual?: true
    orderNumber?: true
    hoursEstimated?: true
    hoursSpent?: true
    targetDate?: true
    dueDate?: true
    status?: true
    priority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyRoadmapItemCountAggregateInputType = {
    id?: true
    companyId?: true
    itemType?: true
    parentArchitecture?: true
    roadmapType?: true
    category?: true
    title?: true
    whatItDoes?: true
    howItHelps?: true
    fieldsData?: true
    howToGet?: true
    prerequisites?: true
    visual?: true
    orderNumber?: true
    hoursEstimated?: true
    hoursSpent?: true
    targetDate?: true
    dueDate?: true
    status?: true
    priority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
    _all?: true
  }

  export type CompanyRoadmapItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRoadmapItem to aggregate.
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRoadmapItems to fetch.
     */
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyRoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyRoadmapItems
    **/
    _count?: true | CompanyRoadmapItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyRoadmapItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyRoadmapItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyRoadmapItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyRoadmapItemMaxAggregateInputType
  }

  export type GetCompanyRoadmapItemAggregateType<T extends CompanyRoadmapItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyRoadmapItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyRoadmapItem[P]>
      : GetScalarType<T[P], AggregateCompanyRoadmapItem[P]>
  }




  export type CompanyRoadmapItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRoadmapItemWhereInput
    orderBy?: CompanyRoadmapItemOrderByWithAggregationInput | CompanyRoadmapItemOrderByWithAggregationInput[]
    by: CompanyRoadmapItemScalarFieldEnum[] | CompanyRoadmapItemScalarFieldEnum
    having?: CompanyRoadmapItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyRoadmapItemCountAggregateInputType | true
    _avg?: CompanyRoadmapItemAvgAggregateInputType
    _sum?: CompanyRoadmapItemSumAggregateInputType
    _min?: CompanyRoadmapItemMinAggregateInputType
    _max?: CompanyRoadmapItemMaxAggregateInputType
  }

  export type CompanyRoadmapItemGroupByOutputType = {
    id: string
    companyId: string
    itemType: string
    parentArchitecture: string | null
    roadmapType: string
    category: string
    title: string
    whatItDoes: string | null
    howItHelps: string | null
    fieldsData: string | null
    howToGet: string | null
    prerequisites: string | null
    visual: string
    orderNumber: number | null
    hoursEstimated: number | null
    hoursSpent: number | null
    targetDate: Date | null
    dueDate: Date | null
    status: string
    priority: string
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    goFastCompanyId: string | null
    _count: CompanyRoadmapItemCountAggregateOutputType | null
    _avg: CompanyRoadmapItemAvgAggregateOutputType | null
    _sum: CompanyRoadmapItemSumAggregateOutputType | null
    _min: CompanyRoadmapItemMinAggregateOutputType | null
    _max: CompanyRoadmapItemMaxAggregateOutputType | null
  }

  type GetCompanyRoadmapItemGroupByPayload<T extends CompanyRoadmapItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyRoadmapItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyRoadmapItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyRoadmapItemGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyRoadmapItemGroupByOutputType[P]>
        }
      >
    >


  export type CompanyRoadmapItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    itemType?: boolean
    parentArchitecture?: boolean
    roadmapType?: boolean
    category?: boolean
    title?: boolean
    whatItDoes?: boolean
    howItHelps?: boolean
    fieldsData?: boolean
    howToGet?: boolean
    prerequisites?: boolean
    visual?: boolean
    orderNumber?: boolean
    hoursEstimated?: boolean
    hoursSpent?: boolean
    targetDate?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyRoadmapItem"]>

  export type CompanyRoadmapItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    itemType?: boolean
    parentArchitecture?: boolean
    roadmapType?: boolean
    category?: boolean
    title?: boolean
    whatItDoes?: boolean
    howItHelps?: boolean
    fieldsData?: boolean
    howToGet?: boolean
    prerequisites?: boolean
    visual?: boolean
    orderNumber?: boolean
    hoursEstimated?: boolean
    hoursSpent?: boolean
    targetDate?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyRoadmapItem"]>

  export type CompanyRoadmapItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    itemType?: boolean
    parentArchitecture?: boolean
    roadmapType?: boolean
    category?: boolean
    title?: boolean
    whatItDoes?: boolean
    howItHelps?: boolean
    fieldsData?: boolean
    howToGet?: boolean
    prerequisites?: boolean
    visual?: boolean
    orderNumber?: boolean
    hoursEstimated?: boolean
    hoursSpent?: boolean
    targetDate?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyRoadmapItem"]>

  export type CompanyRoadmapItemSelectScalar = {
    id?: boolean
    companyId?: boolean
    itemType?: boolean
    parentArchitecture?: boolean
    roadmapType?: boolean
    category?: boolean
    title?: boolean
    whatItDoes?: boolean
    howItHelps?: boolean
    fieldsData?: boolean
    howToGet?: boolean
    prerequisites?: boolean
    visual?: boolean
    orderNumber?: boolean
    hoursEstimated?: boolean
    hoursSpent?: boolean
    targetDate?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
  }

  export type CompanyRoadmapItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "itemType" | "parentArchitecture" | "roadmapType" | "category" | "title" | "whatItDoes" | "howItHelps" | "fieldsData" | "howToGet" | "prerequisites" | "visual" | "orderNumber" | "hoursEstimated" | "hoursSpent" | "targetDate" | "dueDate" | "status" | "priority" | "completedAt" | "createdAt" | "updatedAt" | "goFastCompanyId", ExtArgs["result"]["companyRoadmapItem"]>
  export type CompanyRoadmapItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyRoadmapItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyRoadmapItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>
  }

  export type $CompanyRoadmapItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyRoadmapItem"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      GoFastCompany: Prisma.$GoFastCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      itemType: string
      parentArchitecture: string | null
      roadmapType: string
      category: string
      title: string
      whatItDoes: string | null
      howItHelps: string | null
      fieldsData: string | null
      howToGet: string | null
      prerequisites: string | null
      visual: string
      orderNumber: number | null
      hoursEstimated: number | null
      hoursSpent: number | null
      targetDate: Date | null
      dueDate: Date | null
      status: string
      priority: string
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      goFastCompanyId: string | null
    }, ExtArgs["result"]["companyRoadmapItem"]>
    composites: {}
  }

  type CompanyRoadmapItemGetPayload<S extends boolean | null | undefined | CompanyRoadmapItemDefaultArgs> = $Result.GetResult<Prisma.$CompanyRoadmapItemPayload, S>

  type CompanyRoadmapItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyRoadmapItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyRoadmapItemCountAggregateInputType | true
    }

  export interface CompanyRoadmapItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyRoadmapItem'], meta: { name: 'CompanyRoadmapItem' } }
    /**
     * Find zero or one CompanyRoadmapItem that matches the filter.
     * @param {CompanyRoadmapItemFindUniqueArgs} args - Arguments to find a CompanyRoadmapItem
     * @example
     * // Get one CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyRoadmapItemFindUniqueArgs>(args: SelectSubset<T, CompanyRoadmapItemFindUniqueArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyRoadmapItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyRoadmapItemFindUniqueOrThrowArgs} args - Arguments to find a CompanyRoadmapItem
     * @example
     * // Get one CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyRoadmapItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyRoadmapItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRoadmapItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemFindFirstArgs} args - Arguments to find a CompanyRoadmapItem
     * @example
     * // Get one CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyRoadmapItemFindFirstArgs>(args?: SelectSubset<T, CompanyRoadmapItemFindFirstArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRoadmapItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemFindFirstOrThrowArgs} args - Arguments to find a CompanyRoadmapItem
     * @example
     * // Get one CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyRoadmapItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyRoadmapItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyRoadmapItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyRoadmapItems
     * const companyRoadmapItems = await prisma.companyRoadmapItem.findMany()
     * 
     * // Get first 10 CompanyRoadmapItems
     * const companyRoadmapItems = await prisma.companyRoadmapItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyRoadmapItemWithIdOnly = await prisma.companyRoadmapItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyRoadmapItemFindManyArgs>(args?: SelectSubset<T, CompanyRoadmapItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyRoadmapItem.
     * @param {CompanyRoadmapItemCreateArgs} args - Arguments to create a CompanyRoadmapItem.
     * @example
     * // Create one CompanyRoadmapItem
     * const CompanyRoadmapItem = await prisma.companyRoadmapItem.create({
     *   data: {
     *     // ... data to create a CompanyRoadmapItem
     *   }
     * })
     * 
     */
    create<T extends CompanyRoadmapItemCreateArgs>(args: SelectSubset<T, CompanyRoadmapItemCreateArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyRoadmapItems.
     * @param {CompanyRoadmapItemCreateManyArgs} args - Arguments to create many CompanyRoadmapItems.
     * @example
     * // Create many CompanyRoadmapItems
     * const companyRoadmapItem = await prisma.companyRoadmapItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyRoadmapItemCreateManyArgs>(args?: SelectSubset<T, CompanyRoadmapItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyRoadmapItems and returns the data saved in the database.
     * @param {CompanyRoadmapItemCreateManyAndReturnArgs} args - Arguments to create many CompanyRoadmapItems.
     * @example
     * // Create many CompanyRoadmapItems
     * const companyRoadmapItem = await prisma.companyRoadmapItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyRoadmapItems and only return the `id`
     * const companyRoadmapItemWithIdOnly = await prisma.companyRoadmapItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyRoadmapItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyRoadmapItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyRoadmapItem.
     * @param {CompanyRoadmapItemDeleteArgs} args - Arguments to delete one CompanyRoadmapItem.
     * @example
     * // Delete one CompanyRoadmapItem
     * const CompanyRoadmapItem = await prisma.companyRoadmapItem.delete({
     *   where: {
     *     // ... filter to delete one CompanyRoadmapItem
     *   }
     * })
     * 
     */
    delete<T extends CompanyRoadmapItemDeleteArgs>(args: SelectSubset<T, CompanyRoadmapItemDeleteArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyRoadmapItem.
     * @param {CompanyRoadmapItemUpdateArgs} args - Arguments to update one CompanyRoadmapItem.
     * @example
     * // Update one CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyRoadmapItemUpdateArgs>(args: SelectSubset<T, CompanyRoadmapItemUpdateArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyRoadmapItems.
     * @param {CompanyRoadmapItemDeleteManyArgs} args - Arguments to filter CompanyRoadmapItems to delete.
     * @example
     * // Delete a few CompanyRoadmapItems
     * const { count } = await prisma.companyRoadmapItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyRoadmapItemDeleteManyArgs>(args?: SelectSubset<T, CompanyRoadmapItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyRoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyRoadmapItems
     * const companyRoadmapItem = await prisma.companyRoadmapItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyRoadmapItemUpdateManyArgs>(args: SelectSubset<T, CompanyRoadmapItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyRoadmapItems and returns the data updated in the database.
     * @param {CompanyRoadmapItemUpdateManyAndReturnArgs} args - Arguments to update many CompanyRoadmapItems.
     * @example
     * // Update many CompanyRoadmapItems
     * const companyRoadmapItem = await prisma.companyRoadmapItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyRoadmapItems and only return the `id`
     * const companyRoadmapItemWithIdOnly = await prisma.companyRoadmapItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyRoadmapItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyRoadmapItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyRoadmapItem.
     * @param {CompanyRoadmapItemUpsertArgs} args - Arguments to update or create a CompanyRoadmapItem.
     * @example
     * // Update or create a CompanyRoadmapItem
     * const companyRoadmapItem = await prisma.companyRoadmapItem.upsert({
     *   create: {
     *     // ... data to create a CompanyRoadmapItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyRoadmapItem we want to update
     *   }
     * })
     */
    upsert<T extends CompanyRoadmapItemUpsertArgs>(args: SelectSubset<T, CompanyRoadmapItemUpsertArgs<ExtArgs>>): Prisma__CompanyRoadmapItemClient<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyRoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemCountArgs} args - Arguments to filter CompanyRoadmapItems to count.
     * @example
     * // Count the number of CompanyRoadmapItems
     * const count = await prisma.companyRoadmapItem.count({
     *   where: {
     *     // ... the filter for the CompanyRoadmapItems we want to count
     *   }
     * })
    **/
    count<T extends CompanyRoadmapItemCountArgs>(
      args?: Subset<T, CompanyRoadmapItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyRoadmapItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyRoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyRoadmapItemAggregateArgs>(args: Subset<T, CompanyRoadmapItemAggregateArgs>): Prisma.PrismaPromise<GetCompanyRoadmapItemAggregateType<T>>

    /**
     * Group by CompanyRoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRoadmapItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyRoadmapItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyRoadmapItemGroupByArgs['orderBy'] }
        : { orderBy?: CompanyRoadmapItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyRoadmapItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyRoadmapItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyRoadmapItem model
   */
  readonly fields: CompanyRoadmapItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyRoadmapItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyRoadmapItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GoFastCompany<T extends CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyRoadmapItem model
   */
  interface CompanyRoadmapItemFieldRefs {
    readonly id: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly companyId: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly itemType: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly parentArchitecture: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly roadmapType: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly category: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly title: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly whatItDoes: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly howItHelps: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly fieldsData: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly howToGet: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly prerequisites: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly visual: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly orderNumber: FieldRef<"CompanyRoadmapItem", 'Int'>
    readonly hoursEstimated: FieldRef<"CompanyRoadmapItem", 'Int'>
    readonly hoursSpent: FieldRef<"CompanyRoadmapItem", 'Int'>
    readonly targetDate: FieldRef<"CompanyRoadmapItem", 'DateTime'>
    readonly dueDate: FieldRef<"CompanyRoadmapItem", 'DateTime'>
    readonly status: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly priority: FieldRef<"CompanyRoadmapItem", 'String'>
    readonly completedAt: FieldRef<"CompanyRoadmapItem", 'DateTime'>
    readonly createdAt: FieldRef<"CompanyRoadmapItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyRoadmapItem", 'DateTime'>
    readonly goFastCompanyId: FieldRef<"CompanyRoadmapItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyRoadmapItem findUnique
   */
  export type CompanyRoadmapItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRoadmapItem to fetch.
     */
    where: CompanyRoadmapItemWhereUniqueInput
  }

  /**
   * CompanyRoadmapItem findUniqueOrThrow
   */
  export type CompanyRoadmapItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRoadmapItem to fetch.
     */
    where: CompanyRoadmapItemWhereUniqueInput
  }

  /**
   * CompanyRoadmapItem findFirst
   */
  export type CompanyRoadmapItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRoadmapItem to fetch.
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRoadmapItems to fetch.
     */
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRoadmapItems.
     */
    cursor?: CompanyRoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRoadmapItems.
     */
    distinct?: CompanyRoadmapItemScalarFieldEnum | CompanyRoadmapItemScalarFieldEnum[]
  }

  /**
   * CompanyRoadmapItem findFirstOrThrow
   */
  export type CompanyRoadmapItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRoadmapItem to fetch.
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRoadmapItems to fetch.
     */
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRoadmapItems.
     */
    cursor?: CompanyRoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRoadmapItems.
     */
    distinct?: CompanyRoadmapItemScalarFieldEnum | CompanyRoadmapItemScalarFieldEnum[]
  }

  /**
   * CompanyRoadmapItem findMany
   */
  export type CompanyRoadmapItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRoadmapItems to fetch.
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRoadmapItems to fetch.
     */
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyRoadmapItems.
     */
    cursor?: CompanyRoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRoadmapItems.
     */
    skip?: number
    distinct?: CompanyRoadmapItemScalarFieldEnum | CompanyRoadmapItemScalarFieldEnum[]
  }

  /**
   * CompanyRoadmapItem create
   */
  export type CompanyRoadmapItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyRoadmapItem.
     */
    data: XOR<CompanyRoadmapItemCreateInput, CompanyRoadmapItemUncheckedCreateInput>
  }

  /**
   * CompanyRoadmapItem createMany
   */
  export type CompanyRoadmapItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyRoadmapItems.
     */
    data: CompanyRoadmapItemCreateManyInput | CompanyRoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyRoadmapItem createManyAndReturn
   */
  export type CompanyRoadmapItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyRoadmapItems.
     */
    data: CompanyRoadmapItemCreateManyInput | CompanyRoadmapItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyRoadmapItem update
   */
  export type CompanyRoadmapItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyRoadmapItem.
     */
    data: XOR<CompanyRoadmapItemUpdateInput, CompanyRoadmapItemUncheckedUpdateInput>
    /**
     * Choose, which CompanyRoadmapItem to update.
     */
    where: CompanyRoadmapItemWhereUniqueInput
  }

  /**
   * CompanyRoadmapItem updateMany
   */
  export type CompanyRoadmapItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyRoadmapItems.
     */
    data: XOR<CompanyRoadmapItemUpdateManyMutationInput, CompanyRoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which CompanyRoadmapItems to update
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * Limit how many CompanyRoadmapItems to update.
     */
    limit?: number
  }

  /**
   * CompanyRoadmapItem updateManyAndReturn
   */
  export type CompanyRoadmapItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * The data used to update CompanyRoadmapItems.
     */
    data: XOR<CompanyRoadmapItemUpdateManyMutationInput, CompanyRoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which CompanyRoadmapItems to update
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * Limit how many CompanyRoadmapItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyRoadmapItem upsert
   */
  export type CompanyRoadmapItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyRoadmapItem to update in case it exists.
     */
    where: CompanyRoadmapItemWhereUniqueInput
    /**
     * In case the CompanyRoadmapItem found by the `where` argument doesn't exist, create a new CompanyRoadmapItem with this data.
     */
    create: XOR<CompanyRoadmapItemCreateInput, CompanyRoadmapItemUncheckedCreateInput>
    /**
     * In case the CompanyRoadmapItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyRoadmapItemUpdateInput, CompanyRoadmapItemUncheckedUpdateInput>
  }

  /**
   * CompanyRoadmapItem delete
   */
  export type CompanyRoadmapItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    /**
     * Filter which CompanyRoadmapItem to delete.
     */
    where: CompanyRoadmapItemWhereUniqueInput
  }

  /**
   * CompanyRoadmapItem deleteMany
   */
  export type CompanyRoadmapItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRoadmapItems to delete
     */
    where?: CompanyRoadmapItemWhereInput
    /**
     * Limit how many CompanyRoadmapItems to delete.
     */
    limit?: number
  }

  /**
   * CompanyRoadmapItem.GoFastCompany
   */
  export type CompanyRoadmapItem$GoFastCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    where?: GoFastCompanyWhereInput
  }

  /**
   * CompanyRoadmapItem without action
   */
  export type CompanyRoadmapItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
  }


  /**
   * Model CompanyCrmContact
   */

  export type AggregateCompanyCrmContact = {
    _count: CompanyCrmContactCountAggregateOutputType | null
    _min: CompanyCrmContactMinAggregateOutputType | null
    _max: CompanyCrmContactMaxAggregateOutputType | null
  }

  export type CompanyCrmContactMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    role: string | null
    email: string | null
    companyName: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCrmContactMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    role: string | null
    email: string | null
    companyName: string | null
    pipeline: string | null
    status: string | null
    nextStep: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCrmContactCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    role: number
    email: number
    companyName: number
    pipeline: number
    status: number
    nextStep: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyCrmContactMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    role?: true
    email?: true
    companyName?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCrmContactMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    role?: true
    email?: true
    companyName?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCrmContactCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    role?: true
    email?: true
    companyName?: true
    pipeline?: true
    status?: true
    nextStep?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyCrmContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyCrmContact to aggregate.
     */
    where?: CompanyCrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCrmContacts to fetch.
     */
    orderBy?: CompanyCrmContactOrderByWithRelationInput | CompanyCrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyCrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyCrmContacts
    **/
    _count?: true | CompanyCrmContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyCrmContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyCrmContactMaxAggregateInputType
  }

  export type GetCompanyCrmContactAggregateType<T extends CompanyCrmContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyCrmContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyCrmContact[P]>
      : GetScalarType<T[P], AggregateCompanyCrmContact[P]>
  }




  export type CompanyCrmContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyCrmContactWhereInput
    orderBy?: CompanyCrmContactOrderByWithAggregationInput | CompanyCrmContactOrderByWithAggregationInput[]
    by: CompanyCrmContactScalarFieldEnum[] | CompanyCrmContactScalarFieldEnum
    having?: CompanyCrmContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCrmContactCountAggregateInputType | true
    _min?: CompanyCrmContactMinAggregateInputType
    _max?: CompanyCrmContactMaxAggregateInputType
  }

  export type CompanyCrmContactGroupByOutputType = {
    id: string
    companyId: string
    name: string
    role: string | null
    email: string | null
    companyName: string | null
    pipeline: string
    status: string
    nextStep: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCrmContactCountAggregateOutputType | null
    _min: CompanyCrmContactMinAggregateOutputType | null
    _max: CompanyCrmContactMaxAggregateOutputType | null
  }

  type GetCompanyCrmContactGroupByPayload<T extends CompanyCrmContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyCrmContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyCrmContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyCrmContactGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyCrmContactGroupByOutputType[P]>
        }
      >
    >


  export type CompanyCrmContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    companyName?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCrmContact"]>

  export type CompanyCrmContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    companyName?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCrmContact"]>

  export type CompanyCrmContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    companyName?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyCrmContact"]>

  export type CompanyCrmContactSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    companyName?: boolean
    pipeline?: boolean
    status?: boolean
    nextStep?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyCrmContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "role" | "email" | "companyName" | "pipeline" | "status" | "nextStep" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["companyCrmContact"]>
  export type CompanyCrmContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyCrmContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyCrmContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyCrmContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyCrmContact"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      role: string | null
      email: string | null
      companyName: string | null
      pipeline: string
      status: string
      nextStep: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyCrmContact"]>
    composites: {}
  }

  type CompanyCrmContactGetPayload<S extends boolean | null | undefined | CompanyCrmContactDefaultArgs> = $Result.GetResult<Prisma.$CompanyCrmContactPayload, S>

  type CompanyCrmContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyCrmContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCrmContactCountAggregateInputType | true
    }

  export interface CompanyCrmContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyCrmContact'], meta: { name: 'CompanyCrmContact' } }
    /**
     * Find zero or one CompanyCrmContact that matches the filter.
     * @param {CompanyCrmContactFindUniqueArgs} args - Arguments to find a CompanyCrmContact
     * @example
     * // Get one CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyCrmContactFindUniqueArgs>(args: SelectSubset<T, CompanyCrmContactFindUniqueArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyCrmContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyCrmContactFindUniqueOrThrowArgs} args - Arguments to find a CompanyCrmContact
     * @example
     * // Get one CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyCrmContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyCrmContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyCrmContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactFindFirstArgs} args - Arguments to find a CompanyCrmContact
     * @example
     * // Get one CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyCrmContactFindFirstArgs>(args?: SelectSubset<T, CompanyCrmContactFindFirstArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyCrmContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactFindFirstOrThrowArgs} args - Arguments to find a CompanyCrmContact
     * @example
     * // Get one CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyCrmContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyCrmContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyCrmContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyCrmContacts
     * const companyCrmContacts = await prisma.companyCrmContact.findMany()
     * 
     * // Get first 10 CompanyCrmContacts
     * const companyCrmContacts = await prisma.companyCrmContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyCrmContactWithIdOnly = await prisma.companyCrmContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyCrmContactFindManyArgs>(args?: SelectSubset<T, CompanyCrmContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyCrmContact.
     * @param {CompanyCrmContactCreateArgs} args - Arguments to create a CompanyCrmContact.
     * @example
     * // Create one CompanyCrmContact
     * const CompanyCrmContact = await prisma.companyCrmContact.create({
     *   data: {
     *     // ... data to create a CompanyCrmContact
     *   }
     * })
     * 
     */
    create<T extends CompanyCrmContactCreateArgs>(args: SelectSubset<T, CompanyCrmContactCreateArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyCrmContacts.
     * @param {CompanyCrmContactCreateManyArgs} args - Arguments to create many CompanyCrmContacts.
     * @example
     * // Create many CompanyCrmContacts
     * const companyCrmContact = await prisma.companyCrmContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCrmContactCreateManyArgs>(args?: SelectSubset<T, CompanyCrmContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyCrmContacts and returns the data saved in the database.
     * @param {CompanyCrmContactCreateManyAndReturnArgs} args - Arguments to create many CompanyCrmContacts.
     * @example
     * // Create many CompanyCrmContacts
     * const companyCrmContact = await prisma.companyCrmContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyCrmContacts and only return the `id`
     * const companyCrmContactWithIdOnly = await prisma.companyCrmContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCrmContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCrmContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyCrmContact.
     * @param {CompanyCrmContactDeleteArgs} args - Arguments to delete one CompanyCrmContact.
     * @example
     * // Delete one CompanyCrmContact
     * const CompanyCrmContact = await prisma.companyCrmContact.delete({
     *   where: {
     *     // ... filter to delete one CompanyCrmContact
     *   }
     * })
     * 
     */
    delete<T extends CompanyCrmContactDeleteArgs>(args: SelectSubset<T, CompanyCrmContactDeleteArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyCrmContact.
     * @param {CompanyCrmContactUpdateArgs} args - Arguments to update one CompanyCrmContact.
     * @example
     * // Update one CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyCrmContactUpdateArgs>(args: SelectSubset<T, CompanyCrmContactUpdateArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyCrmContacts.
     * @param {CompanyCrmContactDeleteManyArgs} args - Arguments to filter CompanyCrmContacts to delete.
     * @example
     * // Delete a few CompanyCrmContacts
     * const { count } = await prisma.companyCrmContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyCrmContactDeleteManyArgs>(args?: SelectSubset<T, CompanyCrmContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyCrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyCrmContacts
     * const companyCrmContact = await prisma.companyCrmContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyCrmContactUpdateManyArgs>(args: SelectSubset<T, CompanyCrmContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyCrmContacts and returns the data updated in the database.
     * @param {CompanyCrmContactUpdateManyAndReturnArgs} args - Arguments to update many CompanyCrmContacts.
     * @example
     * // Update many CompanyCrmContacts
     * const companyCrmContact = await prisma.companyCrmContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyCrmContacts and only return the `id`
     * const companyCrmContactWithIdOnly = await prisma.companyCrmContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyCrmContactUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyCrmContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyCrmContact.
     * @param {CompanyCrmContactUpsertArgs} args - Arguments to update or create a CompanyCrmContact.
     * @example
     * // Update or create a CompanyCrmContact
     * const companyCrmContact = await prisma.companyCrmContact.upsert({
     *   create: {
     *     // ... data to create a CompanyCrmContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyCrmContact we want to update
     *   }
     * })
     */
    upsert<T extends CompanyCrmContactUpsertArgs>(args: SelectSubset<T, CompanyCrmContactUpsertArgs<ExtArgs>>): Prisma__CompanyCrmContactClient<$Result.GetResult<Prisma.$CompanyCrmContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyCrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactCountArgs} args - Arguments to filter CompanyCrmContacts to count.
     * @example
     * // Count the number of CompanyCrmContacts
     * const count = await prisma.companyCrmContact.count({
     *   where: {
     *     // ... the filter for the CompanyCrmContacts we want to count
     *   }
     * })
    **/
    count<T extends CompanyCrmContactCountArgs>(
      args?: Subset<T, CompanyCrmContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCrmContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyCrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyCrmContactAggregateArgs>(args: Subset<T, CompanyCrmContactAggregateArgs>): Prisma.PrismaPromise<GetCompanyCrmContactAggregateType<T>>

    /**
     * Group by CompanyCrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCrmContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyCrmContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyCrmContactGroupByArgs['orderBy'] }
        : { orderBy?: CompanyCrmContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyCrmContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyCrmContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyCrmContact model
   */
  readonly fields: CompanyCrmContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyCrmContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyCrmContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyCrmContact model
   */
  interface CompanyCrmContactFieldRefs {
    readonly id: FieldRef<"CompanyCrmContact", 'String'>
    readonly companyId: FieldRef<"CompanyCrmContact", 'String'>
    readonly name: FieldRef<"CompanyCrmContact", 'String'>
    readonly role: FieldRef<"CompanyCrmContact", 'String'>
    readonly email: FieldRef<"CompanyCrmContact", 'String'>
    readonly companyName: FieldRef<"CompanyCrmContact", 'String'>
    readonly pipeline: FieldRef<"CompanyCrmContact", 'String'>
    readonly status: FieldRef<"CompanyCrmContact", 'String'>
    readonly nextStep: FieldRef<"CompanyCrmContact", 'String'>
    readonly notes: FieldRef<"CompanyCrmContact", 'String'>
    readonly createdAt: FieldRef<"CompanyCrmContact", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyCrmContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyCrmContact findUnique
   */
  export type CompanyCrmContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCrmContact to fetch.
     */
    where: CompanyCrmContactWhereUniqueInput
  }

  /**
   * CompanyCrmContact findUniqueOrThrow
   */
  export type CompanyCrmContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCrmContact to fetch.
     */
    where: CompanyCrmContactWhereUniqueInput
  }

  /**
   * CompanyCrmContact findFirst
   */
  export type CompanyCrmContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCrmContact to fetch.
     */
    where?: CompanyCrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCrmContacts to fetch.
     */
    orderBy?: CompanyCrmContactOrderByWithRelationInput | CompanyCrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyCrmContacts.
     */
    cursor?: CompanyCrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyCrmContacts.
     */
    distinct?: CompanyCrmContactScalarFieldEnum | CompanyCrmContactScalarFieldEnum[]
  }

  /**
   * CompanyCrmContact findFirstOrThrow
   */
  export type CompanyCrmContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCrmContact to fetch.
     */
    where?: CompanyCrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCrmContacts to fetch.
     */
    orderBy?: CompanyCrmContactOrderByWithRelationInput | CompanyCrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyCrmContacts.
     */
    cursor?: CompanyCrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyCrmContacts.
     */
    distinct?: CompanyCrmContactScalarFieldEnum | CompanyCrmContactScalarFieldEnum[]
  }

  /**
   * CompanyCrmContact findMany
   */
  export type CompanyCrmContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CompanyCrmContacts to fetch.
     */
    where?: CompanyCrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyCrmContacts to fetch.
     */
    orderBy?: CompanyCrmContactOrderByWithRelationInput | CompanyCrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyCrmContacts.
     */
    cursor?: CompanyCrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyCrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyCrmContacts.
     */
    skip?: number
    distinct?: CompanyCrmContactScalarFieldEnum | CompanyCrmContactScalarFieldEnum[]
  }

  /**
   * CompanyCrmContact create
   */
  export type CompanyCrmContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyCrmContact.
     */
    data: XOR<CompanyCrmContactCreateInput, CompanyCrmContactUncheckedCreateInput>
  }

  /**
   * CompanyCrmContact createMany
   */
  export type CompanyCrmContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyCrmContacts.
     */
    data: CompanyCrmContactCreateManyInput | CompanyCrmContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyCrmContact createManyAndReturn
   */
  export type CompanyCrmContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyCrmContacts.
     */
    data: CompanyCrmContactCreateManyInput | CompanyCrmContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyCrmContact update
   */
  export type CompanyCrmContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyCrmContact.
     */
    data: XOR<CompanyCrmContactUpdateInput, CompanyCrmContactUncheckedUpdateInput>
    /**
     * Choose, which CompanyCrmContact to update.
     */
    where: CompanyCrmContactWhereUniqueInput
  }

  /**
   * CompanyCrmContact updateMany
   */
  export type CompanyCrmContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyCrmContacts.
     */
    data: XOR<CompanyCrmContactUpdateManyMutationInput, CompanyCrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CompanyCrmContacts to update
     */
    where?: CompanyCrmContactWhereInput
    /**
     * Limit how many CompanyCrmContacts to update.
     */
    limit?: number
  }

  /**
   * CompanyCrmContact updateManyAndReturn
   */
  export type CompanyCrmContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * The data used to update CompanyCrmContacts.
     */
    data: XOR<CompanyCrmContactUpdateManyMutationInput, CompanyCrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CompanyCrmContacts to update
     */
    where?: CompanyCrmContactWhereInput
    /**
     * Limit how many CompanyCrmContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyCrmContact upsert
   */
  export type CompanyCrmContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyCrmContact to update in case it exists.
     */
    where: CompanyCrmContactWhereUniqueInput
    /**
     * In case the CompanyCrmContact found by the `where` argument doesn't exist, create a new CompanyCrmContact with this data.
     */
    create: XOR<CompanyCrmContactCreateInput, CompanyCrmContactUncheckedCreateInput>
    /**
     * In case the CompanyCrmContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyCrmContactUpdateInput, CompanyCrmContactUncheckedUpdateInput>
  }

  /**
   * CompanyCrmContact delete
   */
  export type CompanyCrmContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
    /**
     * Filter which CompanyCrmContact to delete.
     */
    where: CompanyCrmContactWhereUniqueInput
  }

  /**
   * CompanyCrmContact deleteMany
   */
  export type CompanyCrmContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyCrmContacts to delete
     */
    where?: CompanyCrmContactWhereInput
    /**
     * Limit how many CompanyCrmContacts to delete.
     */
    limit?: number
  }

  /**
   * CompanyCrmContact without action
   */
  export type CompanyCrmContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCrmContact
     */
    select?: CompanyCrmContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyCrmContact
     */
    omit?: CompanyCrmContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyCrmContactInclude<ExtArgs> | null
  }


  /**
   * Model CompanyFinancialSpend
   */

  export type AggregateCompanyFinancialSpend = {
    _count: CompanyFinancialSpendCountAggregateOutputType | null
    _avg: CompanyFinancialSpendAvgAggregateOutputType | null
    _sum: CompanyFinancialSpendSumAggregateOutputType | null
    _min: CompanyFinancialSpendMinAggregateOutputType | null
    _max: CompanyFinancialSpendMaxAggregateOutputType | null
  }

  export type CompanyFinancialSpendAvgAggregateOutputType = {
    amount: number | null
  }

  export type CompanyFinancialSpendSumAggregateOutputType = {
    amount: number | null
  }

  export type CompanyFinancialSpendMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    date: Date | null
    amount: number | null
    category: string | null
    description: string | null
    vendor: string | null
    department: string | null
    project: string | null
    receiptUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyFinancialSpendMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    date: Date | null
    amount: number | null
    category: string | null
    description: string | null
    vendor: string | null
    department: string | null
    project: string | null
    receiptUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyFinancialSpendCountAggregateOutputType = {
    id: number
    companyId: number
    date: number
    amount: number
    category: number
    description: number
    vendor: number
    department: number
    project: number
    receiptUrl: number
    createdAt: number
    updatedAt: number
    goFastCompanyId: number
    _all: number
  }


  export type CompanyFinancialSpendAvgAggregateInputType = {
    amount?: true
  }

  export type CompanyFinancialSpendSumAggregateInputType = {
    amount?: true
  }

  export type CompanyFinancialSpendMinAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    vendor?: true
    department?: true
    project?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyFinancialSpendMaxAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    vendor?: true
    department?: true
    project?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyFinancialSpendCountAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    amount?: true
    category?: true
    description?: true
    vendor?: true
    department?: true
    project?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
    _all?: true
  }

  export type CompanyFinancialSpendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFinancialSpend to aggregate.
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialSpends to fetch.
     */
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyFinancialSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyFinancialSpends
    **/
    _count?: true | CompanyFinancialSpendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyFinancialSpendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyFinancialSpendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyFinancialSpendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyFinancialSpendMaxAggregateInputType
  }

  export type GetCompanyFinancialSpendAggregateType<T extends CompanyFinancialSpendAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyFinancialSpend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyFinancialSpend[P]>
      : GetScalarType<T[P], AggregateCompanyFinancialSpend[P]>
  }




  export type CompanyFinancialSpendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialSpendWhereInput
    orderBy?: CompanyFinancialSpendOrderByWithAggregationInput | CompanyFinancialSpendOrderByWithAggregationInput[]
    by: CompanyFinancialSpendScalarFieldEnum[] | CompanyFinancialSpendScalarFieldEnum
    having?: CompanyFinancialSpendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyFinancialSpendCountAggregateInputType | true
    _avg?: CompanyFinancialSpendAvgAggregateInputType
    _sum?: CompanyFinancialSpendSumAggregateInputType
    _min?: CompanyFinancialSpendMinAggregateInputType
    _max?: CompanyFinancialSpendMaxAggregateInputType
  }

  export type CompanyFinancialSpendGroupByOutputType = {
    id: string
    companyId: string
    date: Date
    amount: number
    category: string
    description: string | null
    vendor: string | null
    department: string | null
    project: string | null
    receiptUrl: string | null
    createdAt: Date
    updatedAt: Date
    goFastCompanyId: string | null
    _count: CompanyFinancialSpendCountAggregateOutputType | null
    _avg: CompanyFinancialSpendAvgAggregateOutputType | null
    _sum: CompanyFinancialSpendSumAggregateOutputType | null
    _min: CompanyFinancialSpendMinAggregateOutputType | null
    _max: CompanyFinancialSpendMaxAggregateOutputType | null
  }

  type GetCompanyFinancialSpendGroupByPayload<T extends CompanyFinancialSpendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyFinancialSpendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyFinancialSpendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyFinancialSpendGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyFinancialSpendGroupByOutputType[P]>
        }
      >
    >


  export type CompanyFinancialSpendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    vendor?: boolean
    department?: boolean
    project?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialSpend"]>

  export type CompanyFinancialSpendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    vendor?: boolean
    department?: boolean
    project?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialSpend"]>

  export type CompanyFinancialSpendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    vendor?: boolean
    department?: boolean
    project?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialSpend"]>

  export type CompanyFinancialSpendSelectScalar = {
    id?: boolean
    companyId?: boolean
    date?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    vendor?: boolean
    department?: boolean
    project?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
  }

  export type CompanyFinancialSpendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "date" | "amount" | "category" | "description" | "vendor" | "department" | "project" | "receiptUrl" | "createdAt" | "updatedAt" | "goFastCompanyId", ExtArgs["result"]["companyFinancialSpend"]>
  export type CompanyFinancialSpendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyFinancialSpendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyFinancialSpendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>
  }

  export type $CompanyFinancialSpendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyFinancialSpend"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      GoFastCompany: Prisma.$GoFastCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      date: Date
      amount: number
      category: string
      description: string | null
      vendor: string | null
      department: string | null
      project: string | null
      receiptUrl: string | null
      createdAt: Date
      updatedAt: Date
      goFastCompanyId: string | null
    }, ExtArgs["result"]["companyFinancialSpend"]>
    composites: {}
  }

  type CompanyFinancialSpendGetPayload<S extends boolean | null | undefined | CompanyFinancialSpendDefaultArgs> = $Result.GetResult<Prisma.$CompanyFinancialSpendPayload, S>

  type CompanyFinancialSpendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFinancialSpendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyFinancialSpendCountAggregateInputType | true
    }

  export interface CompanyFinancialSpendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyFinancialSpend'], meta: { name: 'CompanyFinancialSpend' } }
    /**
     * Find zero or one CompanyFinancialSpend that matches the filter.
     * @param {CompanyFinancialSpendFindUniqueArgs} args - Arguments to find a CompanyFinancialSpend
     * @example
     * // Get one CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFinancialSpendFindUniqueArgs>(args: SelectSubset<T, CompanyFinancialSpendFindUniqueArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyFinancialSpend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFinancialSpendFindUniqueOrThrowArgs} args - Arguments to find a CompanyFinancialSpend
     * @example
     * // Get one CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFinancialSpendFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFinancialSpendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinancialSpend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendFindFirstArgs} args - Arguments to find a CompanyFinancialSpend
     * @example
     * // Get one CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFinancialSpendFindFirstArgs>(args?: SelectSubset<T, CompanyFinancialSpendFindFirstArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinancialSpend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendFindFirstOrThrowArgs} args - Arguments to find a CompanyFinancialSpend
     * @example
     * // Get one CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFinancialSpendFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFinancialSpendFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyFinancialSpends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyFinancialSpends
     * const companyFinancialSpends = await prisma.companyFinancialSpend.findMany()
     * 
     * // Get first 10 CompanyFinancialSpends
     * const companyFinancialSpends = await prisma.companyFinancialSpend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyFinancialSpendWithIdOnly = await prisma.companyFinancialSpend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFinancialSpendFindManyArgs>(args?: SelectSubset<T, CompanyFinancialSpendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyFinancialSpend.
     * @param {CompanyFinancialSpendCreateArgs} args - Arguments to create a CompanyFinancialSpend.
     * @example
     * // Create one CompanyFinancialSpend
     * const CompanyFinancialSpend = await prisma.companyFinancialSpend.create({
     *   data: {
     *     // ... data to create a CompanyFinancialSpend
     *   }
     * })
     * 
     */
    create<T extends CompanyFinancialSpendCreateArgs>(args: SelectSubset<T, CompanyFinancialSpendCreateArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyFinancialSpends.
     * @param {CompanyFinancialSpendCreateManyArgs} args - Arguments to create many CompanyFinancialSpends.
     * @example
     * // Create many CompanyFinancialSpends
     * const companyFinancialSpend = await prisma.companyFinancialSpend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyFinancialSpendCreateManyArgs>(args?: SelectSubset<T, CompanyFinancialSpendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyFinancialSpends and returns the data saved in the database.
     * @param {CompanyFinancialSpendCreateManyAndReturnArgs} args - Arguments to create many CompanyFinancialSpends.
     * @example
     * // Create many CompanyFinancialSpends
     * const companyFinancialSpend = await prisma.companyFinancialSpend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyFinancialSpends and only return the `id`
     * const companyFinancialSpendWithIdOnly = await prisma.companyFinancialSpend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyFinancialSpendCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyFinancialSpendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyFinancialSpend.
     * @param {CompanyFinancialSpendDeleteArgs} args - Arguments to delete one CompanyFinancialSpend.
     * @example
     * // Delete one CompanyFinancialSpend
     * const CompanyFinancialSpend = await prisma.companyFinancialSpend.delete({
     *   where: {
     *     // ... filter to delete one CompanyFinancialSpend
     *   }
     * })
     * 
     */
    delete<T extends CompanyFinancialSpendDeleteArgs>(args: SelectSubset<T, CompanyFinancialSpendDeleteArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyFinancialSpend.
     * @param {CompanyFinancialSpendUpdateArgs} args - Arguments to update one CompanyFinancialSpend.
     * @example
     * // Update one CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyFinancialSpendUpdateArgs>(args: SelectSubset<T, CompanyFinancialSpendUpdateArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyFinancialSpends.
     * @param {CompanyFinancialSpendDeleteManyArgs} args - Arguments to filter CompanyFinancialSpends to delete.
     * @example
     * // Delete a few CompanyFinancialSpends
     * const { count } = await prisma.companyFinancialSpend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyFinancialSpendDeleteManyArgs>(args?: SelectSubset<T, CompanyFinancialSpendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinancialSpends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyFinancialSpends
     * const companyFinancialSpend = await prisma.companyFinancialSpend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyFinancialSpendUpdateManyArgs>(args: SelectSubset<T, CompanyFinancialSpendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinancialSpends and returns the data updated in the database.
     * @param {CompanyFinancialSpendUpdateManyAndReturnArgs} args - Arguments to update many CompanyFinancialSpends.
     * @example
     * // Update many CompanyFinancialSpends
     * const companyFinancialSpend = await prisma.companyFinancialSpend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyFinancialSpends and only return the `id`
     * const companyFinancialSpendWithIdOnly = await prisma.companyFinancialSpend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyFinancialSpendUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyFinancialSpendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyFinancialSpend.
     * @param {CompanyFinancialSpendUpsertArgs} args - Arguments to update or create a CompanyFinancialSpend.
     * @example
     * // Update or create a CompanyFinancialSpend
     * const companyFinancialSpend = await prisma.companyFinancialSpend.upsert({
     *   create: {
     *     // ... data to create a CompanyFinancialSpend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyFinancialSpend we want to update
     *   }
     * })
     */
    upsert<T extends CompanyFinancialSpendUpsertArgs>(args: SelectSubset<T, CompanyFinancialSpendUpsertArgs<ExtArgs>>): Prisma__CompanyFinancialSpendClient<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyFinancialSpends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendCountArgs} args - Arguments to filter CompanyFinancialSpends to count.
     * @example
     * // Count the number of CompanyFinancialSpends
     * const count = await prisma.companyFinancialSpend.count({
     *   where: {
     *     // ... the filter for the CompanyFinancialSpends we want to count
     *   }
     * })
    **/
    count<T extends CompanyFinancialSpendCountArgs>(
      args?: Subset<T, CompanyFinancialSpendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyFinancialSpendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyFinancialSpend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyFinancialSpendAggregateArgs>(args: Subset<T, CompanyFinancialSpendAggregateArgs>): Prisma.PrismaPromise<GetCompanyFinancialSpendAggregateType<T>>

    /**
     * Group by CompanyFinancialSpend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialSpendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyFinancialSpendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyFinancialSpendGroupByArgs['orderBy'] }
        : { orderBy?: CompanyFinancialSpendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyFinancialSpendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyFinancialSpendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyFinancialSpend model
   */
  readonly fields: CompanyFinancialSpendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyFinancialSpend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyFinancialSpendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GoFastCompany<T extends CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyFinancialSpend model
   */
  interface CompanyFinancialSpendFieldRefs {
    readonly id: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly companyId: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly date: FieldRef<"CompanyFinancialSpend", 'DateTime'>
    readonly amount: FieldRef<"CompanyFinancialSpend", 'Float'>
    readonly category: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly description: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly vendor: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly department: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly project: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly receiptUrl: FieldRef<"CompanyFinancialSpend", 'String'>
    readonly createdAt: FieldRef<"CompanyFinancialSpend", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyFinancialSpend", 'DateTime'>
    readonly goFastCompanyId: FieldRef<"CompanyFinancialSpend", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyFinancialSpend findUnique
   */
  export type CompanyFinancialSpendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialSpend to fetch.
     */
    where: CompanyFinancialSpendWhereUniqueInput
  }

  /**
   * CompanyFinancialSpend findUniqueOrThrow
   */
  export type CompanyFinancialSpendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialSpend to fetch.
     */
    where: CompanyFinancialSpendWhereUniqueInput
  }

  /**
   * CompanyFinancialSpend findFirst
   */
  export type CompanyFinancialSpendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialSpend to fetch.
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialSpends to fetch.
     */
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFinancialSpends.
     */
    cursor?: CompanyFinancialSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFinancialSpends.
     */
    distinct?: CompanyFinancialSpendScalarFieldEnum | CompanyFinancialSpendScalarFieldEnum[]
  }

  /**
   * CompanyFinancialSpend findFirstOrThrow
   */
  export type CompanyFinancialSpendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialSpend to fetch.
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialSpends to fetch.
     */
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFinancialSpends.
     */
    cursor?: CompanyFinancialSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFinancialSpends.
     */
    distinct?: CompanyFinancialSpendScalarFieldEnum | CompanyFinancialSpendScalarFieldEnum[]
  }

  /**
   * CompanyFinancialSpend findMany
   */
  export type CompanyFinancialSpendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialSpends to fetch.
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialSpends to fetch.
     */
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyFinancialSpends.
     */
    cursor?: CompanyFinancialSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialSpends.
     */
    skip?: number
    distinct?: CompanyFinancialSpendScalarFieldEnum | CompanyFinancialSpendScalarFieldEnum[]
  }

  /**
   * CompanyFinancialSpend create
   */
  export type CompanyFinancialSpendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyFinancialSpend.
     */
    data: XOR<CompanyFinancialSpendCreateInput, CompanyFinancialSpendUncheckedCreateInput>
  }

  /**
   * CompanyFinancialSpend createMany
   */
  export type CompanyFinancialSpendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyFinancialSpends.
     */
    data: CompanyFinancialSpendCreateManyInput | CompanyFinancialSpendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyFinancialSpend createManyAndReturn
   */
  export type CompanyFinancialSpendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyFinancialSpends.
     */
    data: CompanyFinancialSpendCreateManyInput | CompanyFinancialSpendCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFinancialSpend update
   */
  export type CompanyFinancialSpendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyFinancialSpend.
     */
    data: XOR<CompanyFinancialSpendUpdateInput, CompanyFinancialSpendUncheckedUpdateInput>
    /**
     * Choose, which CompanyFinancialSpend to update.
     */
    where: CompanyFinancialSpendWhereUniqueInput
  }

  /**
   * CompanyFinancialSpend updateMany
   */
  export type CompanyFinancialSpendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyFinancialSpends.
     */
    data: XOR<CompanyFinancialSpendUpdateManyMutationInput, CompanyFinancialSpendUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFinancialSpends to update
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * Limit how many CompanyFinancialSpends to update.
     */
    limit?: number
  }

  /**
   * CompanyFinancialSpend updateManyAndReturn
   */
  export type CompanyFinancialSpendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * The data used to update CompanyFinancialSpends.
     */
    data: XOR<CompanyFinancialSpendUpdateManyMutationInput, CompanyFinancialSpendUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFinancialSpends to update
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * Limit how many CompanyFinancialSpends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFinancialSpend upsert
   */
  export type CompanyFinancialSpendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyFinancialSpend to update in case it exists.
     */
    where: CompanyFinancialSpendWhereUniqueInput
    /**
     * In case the CompanyFinancialSpend found by the `where` argument doesn't exist, create a new CompanyFinancialSpend with this data.
     */
    create: XOR<CompanyFinancialSpendCreateInput, CompanyFinancialSpendUncheckedCreateInput>
    /**
     * In case the CompanyFinancialSpend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyFinancialSpendUpdateInput, CompanyFinancialSpendUncheckedUpdateInput>
  }

  /**
   * CompanyFinancialSpend delete
   */
  export type CompanyFinancialSpendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    /**
     * Filter which CompanyFinancialSpend to delete.
     */
    where: CompanyFinancialSpendWhereUniqueInput
  }

  /**
   * CompanyFinancialSpend deleteMany
   */
  export type CompanyFinancialSpendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFinancialSpends to delete
     */
    where?: CompanyFinancialSpendWhereInput
    /**
     * Limit how many CompanyFinancialSpends to delete.
     */
    limit?: number
  }

  /**
   * CompanyFinancialSpend.GoFastCompany
   */
  export type CompanyFinancialSpend$GoFastCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    where?: GoFastCompanyWhereInput
  }

  /**
   * CompanyFinancialSpend without action
   */
  export type CompanyFinancialSpendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
  }


  /**
   * Model CompanyFinancialProjection
   */

  export type AggregateCompanyFinancialProjection = {
    _count: CompanyFinancialProjectionCountAggregateOutputType | null
    _avg: CompanyFinancialProjectionAvgAggregateOutputType | null
    _sum: CompanyFinancialProjectionSumAggregateOutputType | null
    _min: CompanyFinancialProjectionMinAggregateOutputType | null
    _max: CompanyFinancialProjectionMaxAggregateOutputType | null
  }

  export type CompanyFinancialProjectionAvgAggregateOutputType = {
    projectedRevenue: number | null
    projectedExpenses: number | null
    projectedNet: number | null
    currentCash: number | null
    monthlyBurnRate: number | null
    runwayMonths: number | null
  }

  export type CompanyFinancialProjectionSumAggregateOutputType = {
    projectedRevenue: number | null
    projectedExpenses: number | null
    projectedNet: number | null
    currentCash: number | null
    monthlyBurnRate: number | null
    runwayMonths: number | null
  }

  export type CompanyFinancialProjectionMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    projectedRevenue: number | null
    projectedExpenses: number | null
    projectedNet: number | null
    currentCash: number | null
    monthlyBurnRate: number | null
    runwayMonths: number | null
    assumptions: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyFinancialProjectionMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    projectedRevenue: number | null
    projectedExpenses: number | null
    projectedNet: number | null
    currentCash: number | null
    monthlyBurnRate: number | null
    runwayMonths: number | null
    assumptions: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type CompanyFinancialProjectionCountAggregateOutputType = {
    id: number
    companyId: number
    period: number
    periodStart: number
    periodEnd: number
    projectedRevenue: number
    projectedExpenses: number
    projectedNet: number
    categoryBreakdown: number
    currentCash: number
    monthlyBurnRate: number
    runwayMonths: number
    assumptions: number
    status: number
    createdAt: number
    updatedAt: number
    goFastCompanyId: number
    _all: number
  }


  export type CompanyFinancialProjectionAvgAggregateInputType = {
    projectedRevenue?: true
    projectedExpenses?: true
    projectedNet?: true
    currentCash?: true
    monthlyBurnRate?: true
    runwayMonths?: true
  }

  export type CompanyFinancialProjectionSumAggregateInputType = {
    projectedRevenue?: true
    projectedExpenses?: true
    projectedNet?: true
    currentCash?: true
    monthlyBurnRate?: true
    runwayMonths?: true
  }

  export type CompanyFinancialProjectionMinAggregateInputType = {
    id?: true
    companyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    projectedRevenue?: true
    projectedExpenses?: true
    projectedNet?: true
    currentCash?: true
    monthlyBurnRate?: true
    runwayMonths?: true
    assumptions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyFinancialProjectionMaxAggregateInputType = {
    id?: true
    companyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    projectedRevenue?: true
    projectedExpenses?: true
    projectedNet?: true
    currentCash?: true
    monthlyBurnRate?: true
    runwayMonths?: true
    assumptions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type CompanyFinancialProjectionCountAggregateInputType = {
    id?: true
    companyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    projectedRevenue?: true
    projectedExpenses?: true
    projectedNet?: true
    categoryBreakdown?: true
    currentCash?: true
    monthlyBurnRate?: true
    runwayMonths?: true
    assumptions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
    _all?: true
  }

  export type CompanyFinancialProjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFinancialProjection to aggregate.
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialProjections to fetch.
     */
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyFinancialProjections
    **/
    _count?: true | CompanyFinancialProjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyFinancialProjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyFinancialProjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyFinancialProjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyFinancialProjectionMaxAggregateInputType
  }

  export type GetCompanyFinancialProjectionAggregateType<T extends CompanyFinancialProjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyFinancialProjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyFinancialProjection[P]>
      : GetScalarType<T[P], AggregateCompanyFinancialProjection[P]>
  }




  export type CompanyFinancialProjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFinancialProjectionWhereInput
    orderBy?: CompanyFinancialProjectionOrderByWithAggregationInput | CompanyFinancialProjectionOrderByWithAggregationInput[]
    by: CompanyFinancialProjectionScalarFieldEnum[] | CompanyFinancialProjectionScalarFieldEnum
    having?: CompanyFinancialProjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyFinancialProjectionCountAggregateInputType | true
    _avg?: CompanyFinancialProjectionAvgAggregateInputType
    _sum?: CompanyFinancialProjectionSumAggregateInputType
    _min?: CompanyFinancialProjectionMinAggregateInputType
    _max?: CompanyFinancialProjectionMaxAggregateInputType
  }

  export type CompanyFinancialProjectionGroupByOutputType = {
    id: string
    companyId: string
    period: string
    periodStart: Date
    periodEnd: Date
    projectedRevenue: number | null
    projectedExpenses: number
    projectedNet: number | null
    categoryBreakdown: JsonValue | null
    currentCash: number | null
    monthlyBurnRate: number | null
    runwayMonths: number | null
    assumptions: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    goFastCompanyId: string | null
    _count: CompanyFinancialProjectionCountAggregateOutputType | null
    _avg: CompanyFinancialProjectionAvgAggregateOutputType | null
    _sum: CompanyFinancialProjectionSumAggregateOutputType | null
    _min: CompanyFinancialProjectionMinAggregateOutputType | null
    _max: CompanyFinancialProjectionMaxAggregateOutputType | null
  }

  type GetCompanyFinancialProjectionGroupByPayload<T extends CompanyFinancialProjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyFinancialProjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyFinancialProjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyFinancialProjectionGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyFinancialProjectionGroupByOutputType[P]>
        }
      >
    >


  export type CompanyFinancialProjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    projectedRevenue?: boolean
    projectedExpenses?: boolean
    projectedNet?: boolean
    categoryBreakdown?: boolean
    currentCash?: boolean
    monthlyBurnRate?: boolean
    runwayMonths?: boolean
    assumptions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialProjection"]>

  export type CompanyFinancialProjectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    projectedRevenue?: boolean
    projectedExpenses?: boolean
    projectedNet?: boolean
    categoryBreakdown?: boolean
    currentCash?: boolean
    monthlyBurnRate?: boolean
    runwayMonths?: boolean
    assumptions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialProjection"]>

  export type CompanyFinancialProjectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    projectedRevenue?: boolean
    projectedExpenses?: boolean
    projectedNet?: boolean
    categoryBreakdown?: boolean
    currentCash?: boolean
    monthlyBurnRate?: boolean
    runwayMonths?: boolean
    assumptions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinancialProjection"]>

  export type CompanyFinancialProjectionSelectScalar = {
    id?: boolean
    companyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    projectedRevenue?: boolean
    projectedExpenses?: boolean
    projectedNet?: boolean
    categoryBreakdown?: boolean
    currentCash?: boolean
    monthlyBurnRate?: boolean
    runwayMonths?: boolean
    assumptions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
  }

  export type CompanyFinancialProjectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "period" | "periodStart" | "periodEnd" | "projectedRevenue" | "projectedExpenses" | "projectedNet" | "categoryBreakdown" | "currentCash" | "monthlyBurnRate" | "runwayMonths" | "assumptions" | "status" | "createdAt" | "updatedAt" | "goFastCompanyId", ExtArgs["result"]["companyFinancialProjection"]>
  export type CompanyFinancialProjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyFinancialProjectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }
  export type CompanyFinancialProjectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    GoFastCompany?: boolean | CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>
  }

  export type $CompanyFinancialProjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyFinancialProjection"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      GoFastCompany: Prisma.$GoFastCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      period: string
      periodStart: Date
      periodEnd: Date
      projectedRevenue: number | null
      projectedExpenses: number
      projectedNet: number | null
      categoryBreakdown: Prisma.JsonValue | null
      currentCash: number | null
      monthlyBurnRate: number | null
      runwayMonths: number | null
      assumptions: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      goFastCompanyId: string | null
    }, ExtArgs["result"]["companyFinancialProjection"]>
    composites: {}
  }

  type CompanyFinancialProjectionGetPayload<S extends boolean | null | undefined | CompanyFinancialProjectionDefaultArgs> = $Result.GetResult<Prisma.$CompanyFinancialProjectionPayload, S>

  type CompanyFinancialProjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFinancialProjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyFinancialProjectionCountAggregateInputType | true
    }

  export interface CompanyFinancialProjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyFinancialProjection'], meta: { name: 'CompanyFinancialProjection' } }
    /**
     * Find zero or one CompanyFinancialProjection that matches the filter.
     * @param {CompanyFinancialProjectionFindUniqueArgs} args - Arguments to find a CompanyFinancialProjection
     * @example
     * // Get one CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFinancialProjectionFindUniqueArgs>(args: SelectSubset<T, CompanyFinancialProjectionFindUniqueArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyFinancialProjection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFinancialProjectionFindUniqueOrThrowArgs} args - Arguments to find a CompanyFinancialProjection
     * @example
     * // Get one CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFinancialProjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFinancialProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinancialProjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionFindFirstArgs} args - Arguments to find a CompanyFinancialProjection
     * @example
     * // Get one CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFinancialProjectionFindFirstArgs>(args?: SelectSubset<T, CompanyFinancialProjectionFindFirstArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinancialProjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionFindFirstOrThrowArgs} args - Arguments to find a CompanyFinancialProjection
     * @example
     * // Get one CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFinancialProjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFinancialProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyFinancialProjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyFinancialProjections
     * const companyFinancialProjections = await prisma.companyFinancialProjection.findMany()
     * 
     * // Get first 10 CompanyFinancialProjections
     * const companyFinancialProjections = await prisma.companyFinancialProjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyFinancialProjectionWithIdOnly = await prisma.companyFinancialProjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFinancialProjectionFindManyArgs>(args?: SelectSubset<T, CompanyFinancialProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyFinancialProjection.
     * @param {CompanyFinancialProjectionCreateArgs} args - Arguments to create a CompanyFinancialProjection.
     * @example
     * // Create one CompanyFinancialProjection
     * const CompanyFinancialProjection = await prisma.companyFinancialProjection.create({
     *   data: {
     *     // ... data to create a CompanyFinancialProjection
     *   }
     * })
     * 
     */
    create<T extends CompanyFinancialProjectionCreateArgs>(args: SelectSubset<T, CompanyFinancialProjectionCreateArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyFinancialProjections.
     * @param {CompanyFinancialProjectionCreateManyArgs} args - Arguments to create many CompanyFinancialProjections.
     * @example
     * // Create many CompanyFinancialProjections
     * const companyFinancialProjection = await prisma.companyFinancialProjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyFinancialProjectionCreateManyArgs>(args?: SelectSubset<T, CompanyFinancialProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyFinancialProjections and returns the data saved in the database.
     * @param {CompanyFinancialProjectionCreateManyAndReturnArgs} args - Arguments to create many CompanyFinancialProjections.
     * @example
     * // Create many CompanyFinancialProjections
     * const companyFinancialProjection = await prisma.companyFinancialProjection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyFinancialProjections and only return the `id`
     * const companyFinancialProjectionWithIdOnly = await prisma.companyFinancialProjection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyFinancialProjectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyFinancialProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyFinancialProjection.
     * @param {CompanyFinancialProjectionDeleteArgs} args - Arguments to delete one CompanyFinancialProjection.
     * @example
     * // Delete one CompanyFinancialProjection
     * const CompanyFinancialProjection = await prisma.companyFinancialProjection.delete({
     *   where: {
     *     // ... filter to delete one CompanyFinancialProjection
     *   }
     * })
     * 
     */
    delete<T extends CompanyFinancialProjectionDeleteArgs>(args: SelectSubset<T, CompanyFinancialProjectionDeleteArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyFinancialProjection.
     * @param {CompanyFinancialProjectionUpdateArgs} args - Arguments to update one CompanyFinancialProjection.
     * @example
     * // Update one CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyFinancialProjectionUpdateArgs>(args: SelectSubset<T, CompanyFinancialProjectionUpdateArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyFinancialProjections.
     * @param {CompanyFinancialProjectionDeleteManyArgs} args - Arguments to filter CompanyFinancialProjections to delete.
     * @example
     * // Delete a few CompanyFinancialProjections
     * const { count } = await prisma.companyFinancialProjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyFinancialProjectionDeleteManyArgs>(args?: SelectSubset<T, CompanyFinancialProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinancialProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyFinancialProjections
     * const companyFinancialProjection = await prisma.companyFinancialProjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyFinancialProjectionUpdateManyArgs>(args: SelectSubset<T, CompanyFinancialProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinancialProjections and returns the data updated in the database.
     * @param {CompanyFinancialProjectionUpdateManyAndReturnArgs} args - Arguments to update many CompanyFinancialProjections.
     * @example
     * // Update many CompanyFinancialProjections
     * const companyFinancialProjection = await prisma.companyFinancialProjection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyFinancialProjections and only return the `id`
     * const companyFinancialProjectionWithIdOnly = await prisma.companyFinancialProjection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyFinancialProjectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyFinancialProjectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyFinancialProjection.
     * @param {CompanyFinancialProjectionUpsertArgs} args - Arguments to update or create a CompanyFinancialProjection.
     * @example
     * // Update or create a CompanyFinancialProjection
     * const companyFinancialProjection = await prisma.companyFinancialProjection.upsert({
     *   create: {
     *     // ... data to create a CompanyFinancialProjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyFinancialProjection we want to update
     *   }
     * })
     */
    upsert<T extends CompanyFinancialProjectionUpsertArgs>(args: SelectSubset<T, CompanyFinancialProjectionUpsertArgs<ExtArgs>>): Prisma__CompanyFinancialProjectionClient<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyFinancialProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionCountArgs} args - Arguments to filter CompanyFinancialProjections to count.
     * @example
     * // Count the number of CompanyFinancialProjections
     * const count = await prisma.companyFinancialProjection.count({
     *   where: {
     *     // ... the filter for the CompanyFinancialProjections we want to count
     *   }
     * })
    **/
    count<T extends CompanyFinancialProjectionCountArgs>(
      args?: Subset<T, CompanyFinancialProjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyFinancialProjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyFinancialProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyFinancialProjectionAggregateArgs>(args: Subset<T, CompanyFinancialProjectionAggregateArgs>): Prisma.PrismaPromise<GetCompanyFinancialProjectionAggregateType<T>>

    /**
     * Group by CompanyFinancialProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinancialProjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyFinancialProjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyFinancialProjectionGroupByArgs['orderBy'] }
        : { orderBy?: CompanyFinancialProjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyFinancialProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyFinancialProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyFinancialProjection model
   */
  readonly fields: CompanyFinancialProjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyFinancialProjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyFinancialProjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GoFastCompany<T extends CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyFinancialProjection model
   */
  interface CompanyFinancialProjectionFieldRefs {
    readonly id: FieldRef<"CompanyFinancialProjection", 'String'>
    readonly companyId: FieldRef<"CompanyFinancialProjection", 'String'>
    readonly period: FieldRef<"CompanyFinancialProjection", 'String'>
    readonly periodStart: FieldRef<"CompanyFinancialProjection", 'DateTime'>
    readonly periodEnd: FieldRef<"CompanyFinancialProjection", 'DateTime'>
    readonly projectedRevenue: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly projectedExpenses: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly projectedNet: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly categoryBreakdown: FieldRef<"CompanyFinancialProjection", 'Json'>
    readonly currentCash: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly monthlyBurnRate: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly runwayMonths: FieldRef<"CompanyFinancialProjection", 'Float'>
    readonly assumptions: FieldRef<"CompanyFinancialProjection", 'String'>
    readonly status: FieldRef<"CompanyFinancialProjection", 'String'>
    readonly createdAt: FieldRef<"CompanyFinancialProjection", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyFinancialProjection", 'DateTime'>
    readonly goFastCompanyId: FieldRef<"CompanyFinancialProjection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyFinancialProjection findUnique
   */
  export type CompanyFinancialProjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialProjection to fetch.
     */
    where: CompanyFinancialProjectionWhereUniqueInput
  }

  /**
   * CompanyFinancialProjection findUniqueOrThrow
   */
  export type CompanyFinancialProjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialProjection to fetch.
     */
    where: CompanyFinancialProjectionWhereUniqueInput
  }

  /**
   * CompanyFinancialProjection findFirst
   */
  export type CompanyFinancialProjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialProjection to fetch.
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialProjections to fetch.
     */
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFinancialProjections.
     */
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFinancialProjections.
     */
    distinct?: CompanyFinancialProjectionScalarFieldEnum | CompanyFinancialProjectionScalarFieldEnum[]
  }

  /**
   * CompanyFinancialProjection findFirstOrThrow
   */
  export type CompanyFinancialProjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialProjection to fetch.
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialProjections to fetch.
     */
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFinancialProjections.
     */
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFinancialProjections.
     */
    distinct?: CompanyFinancialProjectionScalarFieldEnum | CompanyFinancialProjectionScalarFieldEnum[]
  }

  /**
   * CompanyFinancialProjection findMany
   */
  export type CompanyFinancialProjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFinancialProjections to fetch.
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFinancialProjections to fetch.
     */
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyFinancialProjections.
     */
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFinancialProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFinancialProjections.
     */
    skip?: number
    distinct?: CompanyFinancialProjectionScalarFieldEnum | CompanyFinancialProjectionScalarFieldEnum[]
  }

  /**
   * CompanyFinancialProjection create
   */
  export type CompanyFinancialProjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyFinancialProjection.
     */
    data: XOR<CompanyFinancialProjectionCreateInput, CompanyFinancialProjectionUncheckedCreateInput>
  }

  /**
   * CompanyFinancialProjection createMany
   */
  export type CompanyFinancialProjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyFinancialProjections.
     */
    data: CompanyFinancialProjectionCreateManyInput | CompanyFinancialProjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyFinancialProjection createManyAndReturn
   */
  export type CompanyFinancialProjectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyFinancialProjections.
     */
    data: CompanyFinancialProjectionCreateManyInput | CompanyFinancialProjectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFinancialProjection update
   */
  export type CompanyFinancialProjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyFinancialProjection.
     */
    data: XOR<CompanyFinancialProjectionUpdateInput, CompanyFinancialProjectionUncheckedUpdateInput>
    /**
     * Choose, which CompanyFinancialProjection to update.
     */
    where: CompanyFinancialProjectionWhereUniqueInput
  }

  /**
   * CompanyFinancialProjection updateMany
   */
  export type CompanyFinancialProjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyFinancialProjections.
     */
    data: XOR<CompanyFinancialProjectionUpdateManyMutationInput, CompanyFinancialProjectionUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFinancialProjections to update
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * Limit how many CompanyFinancialProjections to update.
     */
    limit?: number
  }

  /**
   * CompanyFinancialProjection updateManyAndReturn
   */
  export type CompanyFinancialProjectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * The data used to update CompanyFinancialProjections.
     */
    data: XOR<CompanyFinancialProjectionUpdateManyMutationInput, CompanyFinancialProjectionUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFinancialProjections to update
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * Limit how many CompanyFinancialProjections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyFinancialProjection upsert
   */
  export type CompanyFinancialProjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyFinancialProjection to update in case it exists.
     */
    where: CompanyFinancialProjectionWhereUniqueInput
    /**
     * In case the CompanyFinancialProjection found by the `where` argument doesn't exist, create a new CompanyFinancialProjection with this data.
     */
    create: XOR<CompanyFinancialProjectionCreateInput, CompanyFinancialProjectionUncheckedCreateInput>
    /**
     * In case the CompanyFinancialProjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyFinancialProjectionUpdateInput, CompanyFinancialProjectionUncheckedUpdateInput>
  }

  /**
   * CompanyFinancialProjection delete
   */
  export type CompanyFinancialProjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    /**
     * Filter which CompanyFinancialProjection to delete.
     */
    where: CompanyFinancialProjectionWhereUniqueInput
  }

  /**
   * CompanyFinancialProjection deleteMany
   */
  export type CompanyFinancialProjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFinancialProjections to delete
     */
    where?: CompanyFinancialProjectionWhereInput
    /**
     * Limit how many CompanyFinancialProjections to delete.
     */
    limit?: number
  }

  /**
   * CompanyFinancialProjection.GoFastCompany
   */
  export type CompanyFinancialProjection$GoFastCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    where?: GoFastCompanyWhereInput
  }

  /**
   * CompanyFinancialProjection without action
   */
  export type CompanyFinancialProjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    companyId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    department: string | null
    isTopPriority: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    companyId: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    dueDate: Date | null
    department: string | null
    isTopPriority: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    goFastCompanyId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    founderId: number
    companyId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    department: number
    isTopPriority: number
    completedAt: number
    createdAt: number
    updatedAt: number
    goFastCompanyId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    founderId?: true
    companyId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    department?: true
    isTopPriority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    founderId?: true
    companyId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    department?: true
    isTopPriority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    founderId?: true
    companyId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    department?: true
    isTopPriority?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    goFastCompanyId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    founderId: string | null
    companyId: string | null
    title: string
    description: string | null
    status: string
    priority: string
    dueDate: Date | null
    department: string | null
    isTopPriority: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    goFastCompanyId: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    companyId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    department?: boolean
    isTopPriority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    companyId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    department?: boolean
    isTopPriority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    companyId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    department?: boolean
    isTopPriority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    founderId?: boolean
    companyId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    department?: boolean
    isTopPriority?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goFastCompanyId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "founderId" | "companyId" | "title" | "description" | "status" | "priority" | "dueDate" | "department" | "isTopPriority" | "completedAt" | "createdAt" | "updatedAt" | "goFastCompanyId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | Task$founderArgs<ExtArgs>
    company?: boolean | Task$companyArgs<ExtArgs>
    GoFastCompany?: boolean | Task$GoFastCompanyArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      founder: Prisma.$FounderPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      GoFastCompany: Prisma.$GoFastCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string | null
      companyId: string | null
      title: string
      description: string | null
      status: string
      priority: string
      dueDate: Date | null
      department: string | null
      isTopPriority: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      goFastCompanyId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends Task$founderArgs<ExtArgs> = {}>(args?: Subset<T, Task$founderArgs<ExtArgs>>): Prisma__FounderClient<$Result.GetResult<Prisma.$FounderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends Task$companyArgs<ExtArgs> = {}>(args?: Subset<T, Task$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    GoFastCompany<T extends Task$GoFastCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Task$GoFastCompanyArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly founderId: FieldRef<"Task", 'String'>
    readonly companyId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly department: FieldRef<"Task", 'String'>
    readonly isTopPriority: FieldRef<"Task", 'Boolean'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly goFastCompanyId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.founder
   */
  export type Task$founderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Founder
     */
    select?: FounderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Founder
     */
    omit?: FounderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderInclude<ExtArgs> | null
    where?: FounderWhereInput
  }

  /**
   * Task.company
   */
  export type Task$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Task.GoFastCompany
   */
  export type Task$GoFastCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    where?: GoFastCompanyWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    authorId: string | null
    author: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    authorId: string | null
    author: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    groupId: number
    authorId: number
    author: number
    content: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    groupId?: true
    authorId?: true
    author?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    groupId?: true
    authorId?: true
    author?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    groupId?: true
    authorId?: true
    author?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    groupId: string
    authorId: string
    author: string
    content: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    authorId?: boolean
    author?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    authorId?: boolean
    author?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    authorId?: boolean
    author?: boolean
    content?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    groupId?: boolean
    authorId?: boolean
    author?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "authorId" | "author" | "content" | "createdAt", ExtArgs["result"]["message"]>

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      authorId: string
      author: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly groupId: FieldRef<"Message", 'String'>
    readonly authorId: FieldRef<"Message", 'String'>
    readonly author: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
  }


  /**
   * Model GoFastCompany
   */

  export type AggregateGoFastCompany = {
    _count: GoFastCompanyCountAggregateOutputType | null
    _min: GoFastCompanyMinAggregateOutputType | null
    _max: GoFastCompanyMaxAggregateOutputType | null
  }

  export type GoFastCompanyMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    companyName: string | null
    address: string | null
    city: string | null
    state: string | null
    website: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoFastCompanyMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    companyName: string | null
    address: string | null
    city: string | null
    state: string | null
    website: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoFastCompanyCountAggregateOutputType = {
    id: number
    containerId: number
    companyName: number
    address: number
    city: number
    state: number
    website: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoFastCompanyMinAggregateInputType = {
    id?: true
    containerId?: true
    companyName?: true
    address?: true
    city?: true
    state?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoFastCompanyMaxAggregateInputType = {
    id?: true
    containerId?: true
    companyName?: true
    address?: true
    city?: true
    state?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoFastCompanyCountAggregateInputType = {
    id?: true
    containerId?: true
    companyName?: true
    address?: true
    city?: true
    state?: true
    website?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoFastCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoFastCompany to aggregate.
     */
    where?: GoFastCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoFastCompanies to fetch.
     */
    orderBy?: GoFastCompanyOrderByWithRelationInput | GoFastCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoFastCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoFastCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoFastCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoFastCompanies
    **/
    _count?: true | GoFastCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoFastCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoFastCompanyMaxAggregateInputType
  }

  export type GetGoFastCompanyAggregateType<T extends GoFastCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateGoFastCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoFastCompany[P]>
      : GetScalarType<T[P], AggregateGoFastCompany[P]>
  }




  export type GoFastCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoFastCompanyWhereInput
    orderBy?: GoFastCompanyOrderByWithAggregationInput | GoFastCompanyOrderByWithAggregationInput[]
    by: GoFastCompanyScalarFieldEnum[] | GoFastCompanyScalarFieldEnum
    having?: GoFastCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoFastCompanyCountAggregateInputType | true
    _min?: GoFastCompanyMinAggregateInputType
    _max?: GoFastCompanyMaxAggregateInputType
  }

  export type GoFastCompanyGroupByOutputType = {
    id: string
    containerId: string
    companyName: string
    address: string | null
    city: string | null
    state: string | null
    website: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: GoFastCompanyCountAggregateOutputType | null
    _min: GoFastCompanyMinAggregateOutputType | null
    _max: GoFastCompanyMaxAggregateOutputType | null
  }

  type GetGoFastCompanyGroupByPayload<T extends GoFastCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoFastCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoFastCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoFastCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], GoFastCompanyGroupByOutputType[P]>
        }
      >
    >


  export type GoFastCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    companyName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | GoFastCompany$staffArgs<ExtArgs>
    contacts?: boolean | GoFastCompany$contactsArgs<ExtArgs>
    pipelines?: boolean | GoFastCompany$pipelinesArgs<ExtArgs>
    pipelineConfigs?: boolean | GoFastCompany$pipelineConfigsArgs<ExtArgs>
    productPipelineItems?: boolean | GoFastCompany$productPipelineItemsArgs<ExtArgs>
    financialSpends?: boolean | GoFastCompany$financialSpendsArgs<ExtArgs>
    financialProjections?: boolean | GoFastCompany$financialProjectionsArgs<ExtArgs>
    roadmapItems?: boolean | GoFastCompany$roadmapItemsArgs<ExtArgs>
    tasks?: boolean | GoFastCompany$tasksArgs<ExtArgs>
    _count?: boolean | GoFastCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goFastCompany"]>

  export type GoFastCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    companyName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["goFastCompany"]>

  export type GoFastCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    companyName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["goFastCompany"]>

  export type GoFastCompanySelectScalar = {
    id?: boolean
    containerId?: boolean
    companyName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    website?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoFastCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerId" | "companyName" | "address" | "city" | "state" | "website" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["goFastCompany"]>
  export type GoFastCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | GoFastCompany$staffArgs<ExtArgs>
    contacts?: boolean | GoFastCompany$contactsArgs<ExtArgs>
    pipelines?: boolean | GoFastCompany$pipelinesArgs<ExtArgs>
    pipelineConfigs?: boolean | GoFastCompany$pipelineConfigsArgs<ExtArgs>
    productPipelineItems?: boolean | GoFastCompany$productPipelineItemsArgs<ExtArgs>
    financialSpends?: boolean | GoFastCompany$financialSpendsArgs<ExtArgs>
    financialProjections?: boolean | GoFastCompany$financialProjectionsArgs<ExtArgs>
    roadmapItems?: boolean | GoFastCompany$roadmapItemsArgs<ExtArgs>
    tasks?: boolean | GoFastCompany$tasksArgs<ExtArgs>
    _count?: boolean | GoFastCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoFastCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GoFastCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GoFastCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoFastCompany"
    objects: {
      staff: Prisma.$CompanyStaffPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      pipelines: Prisma.$PipelinePayload<ExtArgs>[]
      pipelineConfigs: Prisma.$PipelineConfigPayload<ExtArgs>[]
      productPipelineItems: Prisma.$ProductPipelineItemPayload<ExtArgs>[]
      financialSpends: Prisma.$CompanyFinancialSpendPayload<ExtArgs>[]
      financialProjections: Prisma.$CompanyFinancialProjectionPayload<ExtArgs>[]
      roadmapItems: Prisma.$CompanyRoadmapItemPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string
      companyName: string
      address: string | null
      city: string | null
      state: string | null
      website: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goFastCompany"]>
    composites: {}
  }

  type GoFastCompanyGetPayload<S extends boolean | null | undefined | GoFastCompanyDefaultArgs> = $Result.GetResult<Prisma.$GoFastCompanyPayload, S>

  type GoFastCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoFastCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoFastCompanyCountAggregateInputType | true
    }

  export interface GoFastCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoFastCompany'], meta: { name: 'GoFastCompany' } }
    /**
     * Find zero or one GoFastCompany that matches the filter.
     * @param {GoFastCompanyFindUniqueArgs} args - Arguments to find a GoFastCompany
     * @example
     * // Get one GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoFastCompanyFindUniqueArgs>(args: SelectSubset<T, GoFastCompanyFindUniqueArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GoFastCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoFastCompanyFindUniqueOrThrowArgs} args - Arguments to find a GoFastCompany
     * @example
     * // Get one GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoFastCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, GoFastCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoFastCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyFindFirstArgs} args - Arguments to find a GoFastCompany
     * @example
     * // Get one GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoFastCompanyFindFirstArgs>(args?: SelectSubset<T, GoFastCompanyFindFirstArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoFastCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyFindFirstOrThrowArgs} args - Arguments to find a GoFastCompany
     * @example
     * // Get one GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoFastCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, GoFastCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GoFastCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoFastCompanies
     * const goFastCompanies = await prisma.goFastCompany.findMany()
     * 
     * // Get first 10 GoFastCompanies
     * const goFastCompanies = await prisma.goFastCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goFastCompanyWithIdOnly = await prisma.goFastCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoFastCompanyFindManyArgs>(args?: SelectSubset<T, GoFastCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GoFastCompany.
     * @param {GoFastCompanyCreateArgs} args - Arguments to create a GoFastCompany.
     * @example
     * // Create one GoFastCompany
     * const GoFastCompany = await prisma.goFastCompany.create({
     *   data: {
     *     // ... data to create a GoFastCompany
     *   }
     * })
     * 
     */
    create<T extends GoFastCompanyCreateArgs>(args: SelectSubset<T, GoFastCompanyCreateArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GoFastCompanies.
     * @param {GoFastCompanyCreateManyArgs} args - Arguments to create many GoFastCompanies.
     * @example
     * // Create many GoFastCompanies
     * const goFastCompany = await prisma.goFastCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoFastCompanyCreateManyArgs>(args?: SelectSubset<T, GoFastCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoFastCompanies and returns the data saved in the database.
     * @param {GoFastCompanyCreateManyAndReturnArgs} args - Arguments to create many GoFastCompanies.
     * @example
     * // Create many GoFastCompanies
     * const goFastCompany = await prisma.goFastCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoFastCompanies and only return the `id`
     * const goFastCompanyWithIdOnly = await prisma.goFastCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoFastCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, GoFastCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GoFastCompany.
     * @param {GoFastCompanyDeleteArgs} args - Arguments to delete one GoFastCompany.
     * @example
     * // Delete one GoFastCompany
     * const GoFastCompany = await prisma.goFastCompany.delete({
     *   where: {
     *     // ... filter to delete one GoFastCompany
     *   }
     * })
     * 
     */
    delete<T extends GoFastCompanyDeleteArgs>(args: SelectSubset<T, GoFastCompanyDeleteArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GoFastCompany.
     * @param {GoFastCompanyUpdateArgs} args - Arguments to update one GoFastCompany.
     * @example
     * // Update one GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoFastCompanyUpdateArgs>(args: SelectSubset<T, GoFastCompanyUpdateArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GoFastCompanies.
     * @param {GoFastCompanyDeleteManyArgs} args - Arguments to filter GoFastCompanies to delete.
     * @example
     * // Delete a few GoFastCompanies
     * const { count } = await prisma.goFastCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoFastCompanyDeleteManyArgs>(args?: SelectSubset<T, GoFastCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoFastCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoFastCompanies
     * const goFastCompany = await prisma.goFastCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoFastCompanyUpdateManyArgs>(args: SelectSubset<T, GoFastCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoFastCompanies and returns the data updated in the database.
     * @param {GoFastCompanyUpdateManyAndReturnArgs} args - Arguments to update many GoFastCompanies.
     * @example
     * // Update many GoFastCompanies
     * const goFastCompany = await prisma.goFastCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GoFastCompanies and only return the `id`
     * const goFastCompanyWithIdOnly = await prisma.goFastCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoFastCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, GoFastCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GoFastCompany.
     * @param {GoFastCompanyUpsertArgs} args - Arguments to update or create a GoFastCompany.
     * @example
     * // Update or create a GoFastCompany
     * const goFastCompany = await prisma.goFastCompany.upsert({
     *   create: {
     *     // ... data to create a GoFastCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoFastCompany we want to update
     *   }
     * })
     */
    upsert<T extends GoFastCompanyUpsertArgs>(args: SelectSubset<T, GoFastCompanyUpsertArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GoFastCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyCountArgs} args - Arguments to filter GoFastCompanies to count.
     * @example
     * // Count the number of GoFastCompanies
     * const count = await prisma.goFastCompany.count({
     *   where: {
     *     // ... the filter for the GoFastCompanies we want to count
     *   }
     * })
    **/
    count<T extends GoFastCompanyCountArgs>(
      args?: Subset<T, GoFastCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoFastCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoFastCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoFastCompanyAggregateArgs>(args: Subset<T, GoFastCompanyAggregateArgs>): Prisma.PrismaPromise<GetGoFastCompanyAggregateType<T>>

    /**
     * Group by GoFastCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoFastCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoFastCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoFastCompanyGroupByArgs['orderBy'] }
        : { orderBy?: GoFastCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoFastCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoFastCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoFastCompany model
   */
  readonly fields: GoFastCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoFastCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoFastCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends GoFastCompany$staffArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends GoFastCompany$contactsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends GoFastCompany$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelineConfigs<T extends GoFastCompany$pipelineConfigsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$pipelineConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productPipelineItems<T extends GoFastCompany$productPipelineItemsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$productPipelineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialSpends<T extends GoFastCompany$financialSpendsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$financialSpendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialSpendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialProjections<T extends GoFastCompany$financialProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$financialProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFinancialProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapItems<T extends GoFastCompany$roadmapItemsArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$roadmapItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends GoFastCompany$tasksArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompany$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoFastCompany model
   */
  interface GoFastCompanyFieldRefs {
    readonly id: FieldRef<"GoFastCompany", 'String'>
    readonly containerId: FieldRef<"GoFastCompany", 'String'>
    readonly companyName: FieldRef<"GoFastCompany", 'String'>
    readonly address: FieldRef<"GoFastCompany", 'String'>
    readonly city: FieldRef<"GoFastCompany", 'String'>
    readonly state: FieldRef<"GoFastCompany", 'String'>
    readonly website: FieldRef<"GoFastCompany", 'String'>
    readonly description: FieldRef<"GoFastCompany", 'String'>
    readonly createdAt: FieldRef<"GoFastCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"GoFastCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoFastCompany findUnique
   */
  export type GoFastCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter, which GoFastCompany to fetch.
     */
    where: GoFastCompanyWhereUniqueInput
  }

  /**
   * GoFastCompany findUniqueOrThrow
   */
  export type GoFastCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter, which GoFastCompany to fetch.
     */
    where: GoFastCompanyWhereUniqueInput
  }

  /**
   * GoFastCompany findFirst
   */
  export type GoFastCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter, which GoFastCompany to fetch.
     */
    where?: GoFastCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoFastCompanies to fetch.
     */
    orderBy?: GoFastCompanyOrderByWithRelationInput | GoFastCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoFastCompanies.
     */
    cursor?: GoFastCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoFastCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoFastCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoFastCompanies.
     */
    distinct?: GoFastCompanyScalarFieldEnum | GoFastCompanyScalarFieldEnum[]
  }

  /**
   * GoFastCompany findFirstOrThrow
   */
  export type GoFastCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter, which GoFastCompany to fetch.
     */
    where?: GoFastCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoFastCompanies to fetch.
     */
    orderBy?: GoFastCompanyOrderByWithRelationInput | GoFastCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoFastCompanies.
     */
    cursor?: GoFastCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoFastCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoFastCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoFastCompanies.
     */
    distinct?: GoFastCompanyScalarFieldEnum | GoFastCompanyScalarFieldEnum[]
  }

  /**
   * GoFastCompany findMany
   */
  export type GoFastCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter, which GoFastCompanies to fetch.
     */
    where?: GoFastCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoFastCompanies to fetch.
     */
    orderBy?: GoFastCompanyOrderByWithRelationInput | GoFastCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoFastCompanies.
     */
    cursor?: GoFastCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoFastCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoFastCompanies.
     */
    skip?: number
    distinct?: GoFastCompanyScalarFieldEnum | GoFastCompanyScalarFieldEnum[]
  }

  /**
   * GoFastCompany create
   */
  export type GoFastCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a GoFastCompany.
     */
    data: XOR<GoFastCompanyCreateInput, GoFastCompanyUncheckedCreateInput>
  }

  /**
   * GoFastCompany createMany
   */
  export type GoFastCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoFastCompanies.
     */
    data: GoFastCompanyCreateManyInput | GoFastCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoFastCompany createManyAndReturn
   */
  export type GoFastCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many GoFastCompanies.
     */
    data: GoFastCompanyCreateManyInput | GoFastCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoFastCompany update
   */
  export type GoFastCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a GoFastCompany.
     */
    data: XOR<GoFastCompanyUpdateInput, GoFastCompanyUncheckedUpdateInput>
    /**
     * Choose, which GoFastCompany to update.
     */
    where: GoFastCompanyWhereUniqueInput
  }

  /**
   * GoFastCompany updateMany
   */
  export type GoFastCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoFastCompanies.
     */
    data: XOR<GoFastCompanyUpdateManyMutationInput, GoFastCompanyUncheckedUpdateManyInput>
    /**
     * Filter which GoFastCompanies to update
     */
    where?: GoFastCompanyWhereInput
    /**
     * Limit how many GoFastCompanies to update.
     */
    limit?: number
  }

  /**
   * GoFastCompany updateManyAndReturn
   */
  export type GoFastCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * The data used to update GoFastCompanies.
     */
    data: XOR<GoFastCompanyUpdateManyMutationInput, GoFastCompanyUncheckedUpdateManyInput>
    /**
     * Filter which GoFastCompanies to update
     */
    where?: GoFastCompanyWhereInput
    /**
     * Limit how many GoFastCompanies to update.
     */
    limit?: number
  }

  /**
   * GoFastCompany upsert
   */
  export type GoFastCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the GoFastCompany to update in case it exists.
     */
    where: GoFastCompanyWhereUniqueInput
    /**
     * In case the GoFastCompany found by the `where` argument doesn't exist, create a new GoFastCompany with this data.
     */
    create: XOR<GoFastCompanyCreateInput, GoFastCompanyUncheckedCreateInput>
    /**
     * In case the GoFastCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoFastCompanyUpdateInput, GoFastCompanyUncheckedUpdateInput>
  }

  /**
   * GoFastCompany delete
   */
  export type GoFastCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
    /**
     * Filter which GoFastCompany to delete.
     */
    where: GoFastCompanyWhereUniqueInput
  }

  /**
   * GoFastCompany deleteMany
   */
  export type GoFastCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoFastCompanies to delete
     */
    where?: GoFastCompanyWhereInput
    /**
     * Limit how many GoFastCompanies to delete.
     */
    limit?: number
  }

  /**
   * GoFastCompany.staff
   */
  export type GoFastCompany$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    where?: CompanyStaffWhereInput
    orderBy?: CompanyStaffOrderByWithRelationInput | CompanyStaffOrderByWithRelationInput[]
    cursor?: CompanyStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyStaffScalarFieldEnum | CompanyStaffScalarFieldEnum[]
  }

  /**
   * GoFastCompany.contacts
   */
  export type GoFastCompany$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * GoFastCompany.pipelines
   */
  export type GoFastCompany$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * GoFastCompany.pipelineConfigs
   */
  export type GoFastCompany$pipelineConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    where?: PipelineConfigWhereInput
    orderBy?: PipelineConfigOrderByWithRelationInput | PipelineConfigOrderByWithRelationInput[]
    cursor?: PipelineConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineConfigScalarFieldEnum | PipelineConfigScalarFieldEnum[]
  }

  /**
   * GoFastCompany.productPipelineItems
   */
  export type GoFastCompany$productPipelineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    where?: ProductPipelineItemWhereInput
    orderBy?: ProductPipelineItemOrderByWithRelationInput | ProductPipelineItemOrderByWithRelationInput[]
    cursor?: ProductPipelineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPipelineItemScalarFieldEnum | ProductPipelineItemScalarFieldEnum[]
  }

  /**
   * GoFastCompany.financialSpends
   */
  export type GoFastCompany$financialSpendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialSpend
     */
    select?: CompanyFinancialSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialSpend
     */
    omit?: CompanyFinancialSpendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialSpendInclude<ExtArgs> | null
    where?: CompanyFinancialSpendWhereInput
    orderBy?: CompanyFinancialSpendOrderByWithRelationInput | CompanyFinancialSpendOrderByWithRelationInput[]
    cursor?: CompanyFinancialSpendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFinancialSpendScalarFieldEnum | CompanyFinancialSpendScalarFieldEnum[]
  }

  /**
   * GoFastCompany.financialProjections
   */
  export type GoFastCompany$financialProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFinancialProjection
     */
    select?: CompanyFinancialProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFinancialProjection
     */
    omit?: CompanyFinancialProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFinancialProjectionInclude<ExtArgs> | null
    where?: CompanyFinancialProjectionWhereInput
    orderBy?: CompanyFinancialProjectionOrderByWithRelationInput | CompanyFinancialProjectionOrderByWithRelationInput[]
    cursor?: CompanyFinancialProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFinancialProjectionScalarFieldEnum | CompanyFinancialProjectionScalarFieldEnum[]
  }

  /**
   * GoFastCompany.roadmapItems
   */
  export type GoFastCompany$roadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRoadmapItem
     */
    select?: CompanyRoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRoadmapItem
     */
    omit?: CompanyRoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRoadmapItemInclude<ExtArgs> | null
    where?: CompanyRoadmapItemWhereInput
    orderBy?: CompanyRoadmapItemOrderByWithRelationInput | CompanyRoadmapItemOrderByWithRelationInput[]
    cursor?: CompanyRoadmapItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyRoadmapItemScalarFieldEnum | CompanyRoadmapItemScalarFieldEnum[]
  }

  /**
   * GoFastCompany.tasks
   */
  export type GoFastCompany$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * GoFastCompany without action
   */
  export type GoFastCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoFastCompany
     */
    select?: GoFastCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoFastCompany
     */
    omit?: GoFastCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoFastCompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyStaff
   */

  export type AggregateCompanyStaff = {
    _count: CompanyStaffCountAggregateOutputType | null
    _min: CompanyStaffMinAggregateOutputType | null
    _max: CompanyStaffMaxAggregateOutputType | null
  }

  export type CompanyStaffMinAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    name: string | null
    email: string | null
    photoURL: string | null
    companyId: string | null
    role: string | null
    department: string | null
    verificationCode: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyStaffMaxAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    name: string | null
    email: string | null
    photoURL: string | null
    companyId: string | null
    role: string | null
    department: string | null
    verificationCode: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyStaffCountAggregateOutputType = {
    id: number
    firebaseId: number
    name: number
    email: number
    photoURL: number
    companyId: number
    role: number
    department: number
    verificationCode: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyStaffMinAggregateInputType = {
    id?: true
    firebaseId?: true
    name?: true
    email?: true
    photoURL?: true
    companyId?: true
    role?: true
    department?: true
    verificationCode?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyStaffMaxAggregateInputType = {
    id?: true
    firebaseId?: true
    name?: true
    email?: true
    photoURL?: true
    companyId?: true
    role?: true
    department?: true
    verificationCode?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyStaffCountAggregateInputType = {
    id?: true
    firebaseId?: true
    name?: true
    email?: true
    photoURL?: true
    companyId?: true
    role?: true
    department?: true
    verificationCode?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyStaff to aggregate.
     */
    where?: CompanyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStaffs to fetch.
     */
    orderBy?: CompanyStaffOrderByWithRelationInput | CompanyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyStaffs
    **/
    _count?: true | CompanyStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyStaffMaxAggregateInputType
  }

  export type GetCompanyStaffAggregateType<T extends CompanyStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyStaff[P]>
      : GetScalarType<T[P], AggregateCompanyStaff[P]>
  }




  export type CompanyStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyStaffWhereInput
    orderBy?: CompanyStaffOrderByWithAggregationInput | CompanyStaffOrderByWithAggregationInput[]
    by: CompanyStaffScalarFieldEnum[] | CompanyStaffScalarFieldEnum
    having?: CompanyStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyStaffCountAggregateInputType | true
    _min?: CompanyStaffMinAggregateInputType
    _max?: CompanyStaffMaxAggregateInputType
  }

  export type CompanyStaffGroupByOutputType = {
    id: string
    firebaseId: string
    name: string | null
    email: string | null
    photoURL: string | null
    companyId: string
    role: string
    department: string | null
    verificationCode: string | null
    joinedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CompanyStaffCountAggregateOutputType | null
    _min: CompanyStaffMinAggregateOutputType | null
    _max: CompanyStaffMaxAggregateOutputType | null
  }

  type GetCompanyStaffGroupByPayload<T extends CompanyStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyStaffGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyStaffGroupByOutputType[P]>
        }
      >
    >


  export type CompanyStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    name?: boolean
    email?: boolean
    photoURL?: boolean
    companyId?: boolean
    role?: boolean
    department?: boolean
    verificationCode?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStaff"]>

  export type CompanyStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    name?: boolean
    email?: boolean
    photoURL?: boolean
    companyId?: boolean
    role?: boolean
    department?: boolean
    verificationCode?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStaff"]>

  export type CompanyStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    name?: boolean
    email?: boolean
    photoURL?: boolean
    companyId?: boolean
    role?: boolean
    department?: boolean
    verificationCode?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStaff"]>

  export type CompanyStaffSelectScalar = {
    id?: boolean
    firebaseId?: boolean
    name?: boolean
    email?: boolean
    photoURL?: boolean
    companyId?: boolean
    role?: boolean
    department?: boolean
    verificationCode?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firebaseId" | "name" | "email" | "photoURL" | "companyId" | "role" | "department" | "verificationCode" | "joinedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["companyStaff"]>
  export type CompanyStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type CompanyStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type CompanyStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyStaff"
    objects: {
      company: Prisma.$GoFastCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firebaseId: string
      name: string | null
      email: string | null
      photoURL: string | null
      companyId: string
      role: string
      department: string | null
      verificationCode: string | null
      joinedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyStaff"]>
    composites: {}
  }

  type CompanyStaffGetPayload<S extends boolean | null | undefined | CompanyStaffDefaultArgs> = $Result.GetResult<Prisma.$CompanyStaffPayload, S>

  type CompanyStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyStaffCountAggregateInputType | true
    }

  export interface CompanyStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyStaff'], meta: { name: 'CompanyStaff' } }
    /**
     * Find zero or one CompanyStaff that matches the filter.
     * @param {CompanyStaffFindUniqueArgs} args - Arguments to find a CompanyStaff
     * @example
     * // Get one CompanyStaff
     * const companyStaff = await prisma.companyStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyStaffFindUniqueArgs>(args: SelectSubset<T, CompanyStaffFindUniqueArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyStaffFindUniqueOrThrowArgs} args - Arguments to find a CompanyStaff
     * @example
     * // Get one CompanyStaff
     * const companyStaff = await prisma.companyStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffFindFirstArgs} args - Arguments to find a CompanyStaff
     * @example
     * // Get one CompanyStaff
     * const companyStaff = await prisma.companyStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyStaffFindFirstArgs>(args?: SelectSubset<T, CompanyStaffFindFirstArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffFindFirstOrThrowArgs} args - Arguments to find a CompanyStaff
     * @example
     * // Get one CompanyStaff
     * const companyStaff = await prisma.companyStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyStaffs
     * const companyStaffs = await prisma.companyStaff.findMany()
     * 
     * // Get first 10 CompanyStaffs
     * const companyStaffs = await prisma.companyStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyStaffWithIdOnly = await prisma.companyStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyStaffFindManyArgs>(args?: SelectSubset<T, CompanyStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyStaff.
     * @param {CompanyStaffCreateArgs} args - Arguments to create a CompanyStaff.
     * @example
     * // Create one CompanyStaff
     * const CompanyStaff = await prisma.companyStaff.create({
     *   data: {
     *     // ... data to create a CompanyStaff
     *   }
     * })
     * 
     */
    create<T extends CompanyStaffCreateArgs>(args: SelectSubset<T, CompanyStaffCreateArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyStaffs.
     * @param {CompanyStaffCreateManyArgs} args - Arguments to create many CompanyStaffs.
     * @example
     * // Create many CompanyStaffs
     * const companyStaff = await prisma.companyStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyStaffCreateManyArgs>(args?: SelectSubset<T, CompanyStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyStaffs and returns the data saved in the database.
     * @param {CompanyStaffCreateManyAndReturnArgs} args - Arguments to create many CompanyStaffs.
     * @example
     * // Create many CompanyStaffs
     * const companyStaff = await prisma.companyStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyStaffs and only return the `id`
     * const companyStaffWithIdOnly = await prisma.companyStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyStaff.
     * @param {CompanyStaffDeleteArgs} args - Arguments to delete one CompanyStaff.
     * @example
     * // Delete one CompanyStaff
     * const CompanyStaff = await prisma.companyStaff.delete({
     *   where: {
     *     // ... filter to delete one CompanyStaff
     *   }
     * })
     * 
     */
    delete<T extends CompanyStaffDeleteArgs>(args: SelectSubset<T, CompanyStaffDeleteArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyStaff.
     * @param {CompanyStaffUpdateArgs} args - Arguments to update one CompanyStaff.
     * @example
     * // Update one CompanyStaff
     * const companyStaff = await prisma.companyStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyStaffUpdateArgs>(args: SelectSubset<T, CompanyStaffUpdateArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyStaffs.
     * @param {CompanyStaffDeleteManyArgs} args - Arguments to filter CompanyStaffs to delete.
     * @example
     * // Delete a few CompanyStaffs
     * const { count } = await prisma.companyStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyStaffDeleteManyArgs>(args?: SelectSubset<T, CompanyStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyStaffs
     * const companyStaff = await prisma.companyStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyStaffUpdateManyArgs>(args: SelectSubset<T, CompanyStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyStaffs and returns the data updated in the database.
     * @param {CompanyStaffUpdateManyAndReturnArgs} args - Arguments to update many CompanyStaffs.
     * @example
     * // Update many CompanyStaffs
     * const companyStaff = await prisma.companyStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyStaffs and only return the `id`
     * const companyStaffWithIdOnly = await prisma.companyStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyStaff.
     * @param {CompanyStaffUpsertArgs} args - Arguments to update or create a CompanyStaff.
     * @example
     * // Update or create a CompanyStaff
     * const companyStaff = await prisma.companyStaff.upsert({
     *   create: {
     *     // ... data to create a CompanyStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyStaff we want to update
     *   }
     * })
     */
    upsert<T extends CompanyStaffUpsertArgs>(args: SelectSubset<T, CompanyStaffUpsertArgs<ExtArgs>>): Prisma__CompanyStaffClient<$Result.GetResult<Prisma.$CompanyStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffCountArgs} args - Arguments to filter CompanyStaffs to count.
     * @example
     * // Count the number of CompanyStaffs
     * const count = await prisma.companyStaff.count({
     *   where: {
     *     // ... the filter for the CompanyStaffs we want to count
     *   }
     * })
    **/
    count<T extends CompanyStaffCountArgs>(
      args?: Subset<T, CompanyStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyStaffAggregateArgs>(args: Subset<T, CompanyStaffAggregateArgs>): Prisma.PrismaPromise<GetCompanyStaffAggregateType<T>>

    /**
     * Group by CompanyStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyStaffGroupByArgs['orderBy'] }
        : { orderBy?: CompanyStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyStaff model
   */
  readonly fields: CompanyStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends GoFastCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompanyDefaultArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyStaff model
   */
  interface CompanyStaffFieldRefs {
    readonly id: FieldRef<"CompanyStaff", 'String'>
    readonly firebaseId: FieldRef<"CompanyStaff", 'String'>
    readonly name: FieldRef<"CompanyStaff", 'String'>
    readonly email: FieldRef<"CompanyStaff", 'String'>
    readonly photoURL: FieldRef<"CompanyStaff", 'String'>
    readonly companyId: FieldRef<"CompanyStaff", 'String'>
    readonly role: FieldRef<"CompanyStaff", 'String'>
    readonly department: FieldRef<"CompanyStaff", 'String'>
    readonly verificationCode: FieldRef<"CompanyStaff", 'String'>
    readonly joinedAt: FieldRef<"CompanyStaff", 'DateTime'>
    readonly createdAt: FieldRef<"CompanyStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyStaff findUnique
   */
  export type CompanyStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStaff to fetch.
     */
    where: CompanyStaffWhereUniqueInput
  }

  /**
   * CompanyStaff findUniqueOrThrow
   */
  export type CompanyStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStaff to fetch.
     */
    where: CompanyStaffWhereUniqueInput
  }

  /**
   * CompanyStaff findFirst
   */
  export type CompanyStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStaff to fetch.
     */
    where?: CompanyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStaffs to fetch.
     */
    orderBy?: CompanyStaffOrderByWithRelationInput | CompanyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyStaffs.
     */
    cursor?: CompanyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyStaffs.
     */
    distinct?: CompanyStaffScalarFieldEnum | CompanyStaffScalarFieldEnum[]
  }

  /**
   * CompanyStaff findFirstOrThrow
   */
  export type CompanyStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStaff to fetch.
     */
    where?: CompanyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStaffs to fetch.
     */
    orderBy?: CompanyStaffOrderByWithRelationInput | CompanyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyStaffs.
     */
    cursor?: CompanyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyStaffs.
     */
    distinct?: CompanyStaffScalarFieldEnum | CompanyStaffScalarFieldEnum[]
  }

  /**
   * CompanyStaff findMany
   */
  export type CompanyStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStaffs to fetch.
     */
    where?: CompanyStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStaffs to fetch.
     */
    orderBy?: CompanyStaffOrderByWithRelationInput | CompanyStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyStaffs.
     */
    cursor?: CompanyStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStaffs.
     */
    skip?: number
    distinct?: CompanyStaffScalarFieldEnum | CompanyStaffScalarFieldEnum[]
  }

  /**
   * CompanyStaff create
   */
  export type CompanyStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyStaff.
     */
    data: XOR<CompanyStaffCreateInput, CompanyStaffUncheckedCreateInput>
  }

  /**
   * CompanyStaff createMany
   */
  export type CompanyStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyStaffs.
     */
    data: CompanyStaffCreateManyInput | CompanyStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyStaff createManyAndReturn
   */
  export type CompanyStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyStaffs.
     */
    data: CompanyStaffCreateManyInput | CompanyStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyStaff update
   */
  export type CompanyStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyStaff.
     */
    data: XOR<CompanyStaffUpdateInput, CompanyStaffUncheckedUpdateInput>
    /**
     * Choose, which CompanyStaff to update.
     */
    where: CompanyStaffWhereUniqueInput
  }

  /**
   * CompanyStaff updateMany
   */
  export type CompanyStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyStaffs.
     */
    data: XOR<CompanyStaffUpdateManyMutationInput, CompanyStaffUncheckedUpdateManyInput>
    /**
     * Filter which CompanyStaffs to update
     */
    where?: CompanyStaffWhereInput
    /**
     * Limit how many CompanyStaffs to update.
     */
    limit?: number
  }

  /**
   * CompanyStaff updateManyAndReturn
   */
  export type CompanyStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * The data used to update CompanyStaffs.
     */
    data: XOR<CompanyStaffUpdateManyMutationInput, CompanyStaffUncheckedUpdateManyInput>
    /**
     * Filter which CompanyStaffs to update
     */
    where?: CompanyStaffWhereInput
    /**
     * Limit how many CompanyStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyStaff upsert
   */
  export type CompanyStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyStaff to update in case it exists.
     */
    where: CompanyStaffWhereUniqueInput
    /**
     * In case the CompanyStaff found by the `where` argument doesn't exist, create a new CompanyStaff with this data.
     */
    create: XOR<CompanyStaffCreateInput, CompanyStaffUncheckedCreateInput>
    /**
     * In case the CompanyStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyStaffUpdateInput, CompanyStaffUncheckedUpdateInput>
  }

  /**
   * CompanyStaff delete
   */
  export type CompanyStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
    /**
     * Filter which CompanyStaff to delete.
     */
    where: CompanyStaffWhereUniqueInput
  }

  /**
   * CompanyStaff deleteMany
   */
  export type CompanyStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyStaffs to delete
     */
    where?: CompanyStaffWhereInput
    /**
     * Limit how many CompanyStaffs to delete.
     */
    limit?: number
  }

  /**
   * CompanyStaff without action
   */
  export type CompanyStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStaff
     */
    select?: CompanyStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStaff
     */
    omit?: CompanyStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStaffInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    firstName: string | null
    lastName: string | null
    goesBy: string | null
    email: string | null
    phone: string | null
    title: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    firstName: string | null
    lastName: string | null
    goesBy: string | null
    email: string | null
    phone: string | null
    title: string | null
    athleteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    companyId: number
    firstName: number
    lastName: number
    goesBy: number
    email: number
    phone: number
    title: number
    athleteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    companyId?: true
    firstName?: true
    lastName?: true
    goesBy?: true
    email?: true
    phone?: true
    title?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    companyId?: true
    firstName?: true
    lastName?: true
    goesBy?: true
    email?: true
    phone?: true
    title?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    companyId?: true
    firstName?: true
    lastName?: true
    goesBy?: true
    email?: true
    phone?: true
    title?: true
    athleteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    companyId: string
    firstName: string | null
    lastName: string | null
    goesBy: string | null
    email: string | null
    phone: string | null
    title: string | null
    athleteId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    firstName?: boolean
    lastName?: boolean
    goesBy?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    pipelines?: boolean | Contact$pipelinesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    firstName?: boolean
    lastName?: boolean
    goesBy?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    firstName?: boolean
    lastName?: boolean
    goesBy?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    companyId?: boolean
    firstName?: boolean
    lastName?: boolean
    goesBy?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    athleteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "firstName" | "lastName" | "goesBy" | "email" | "phone" | "title" | "athleteId" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    pipelines?: boolean | Contact$pipelinesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      company: Prisma.$GoFastCompanyPayload<ExtArgs>
      pipelines: Prisma.$PipelinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      firstName: string | null
      lastName: string | null
      goesBy: string | null
      email: string | null
      phone: string | null
      title: string | null
      athleteId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends GoFastCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompanyDefaultArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pipelines<T extends Contact$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly companyId: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly goesBy: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly title: FieldRef<"Contact", 'String'>
    readonly athleteId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.pipelines
   */
  export type Contact$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    contactId: string | null
    configId: string | null
    stageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    contactId: string | null
    configId: string | null
    stageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    companyId: number
    contactId: number
    configId: number
    stageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    companyId?: true
    contactId?: true
    configId?: true
    stageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    companyId?: true
    contactId?: true
    configId?: true
    stageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    companyId?: true
    contactId?: true
    configId?: true
    stageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    companyId: string
    contactId: string
    configId: string
    stageId: string
    createdAt: Date
    updatedAt: Date
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactId?: boolean
    configId?: boolean
    stageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactId?: boolean
    configId?: boolean
    stageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contactId?: boolean
    configId?: boolean
    stageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectScalar = {
    id?: boolean
    companyId?: boolean
    contactId?: boolean
    configId?: boolean
    stageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "contactId" | "configId" | "stageId" | "createdAt" | "updatedAt", ExtArgs["result"]["pipeline"]>
  export type PipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    config?: boolean | PipelineConfigDefaultArgs<ExtArgs>
  }

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {
      company: Prisma.$GoFastCompanyPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      config: Prisma.$PipelineConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      contactId: string
      configId: string
      stageId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelineCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines and returns the data updated in the database.
     * @param {PipelineUpdateManyAndReturnArgs} args - Arguments to update many Pipelines.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelineUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends GoFastCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompanyDefaultArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    config<T extends PipelineConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineConfigDefaultArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly companyId: FieldRef<"Pipeline", 'String'>
    readonly contactId: FieldRef<"Pipeline", 'String'>
    readonly configId: FieldRef<"Pipeline", 'String'>
    readonly stageId: FieldRef<"Pipeline", 'String'>
    readonly createdAt: FieldRef<"Pipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipeline createManyAndReturn
   */
  export type PipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipeline updateManyAndReturn
   */
  export type PipelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
  }


  /**
   * Model PipelineConfig
   */

  export type AggregatePipelineConfig = {
    _count: PipelineConfigCountAggregateOutputType | null
    _min: PipelineConfigMinAggregateOutputType | null
    _max: PipelineConfigMaxAggregateOutputType | null
  }

  export type PipelineConfigMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineConfigMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineConfigCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    description: number
    stages: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PipelineConfigMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineConfigMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineConfigCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    stages?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PipelineConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineConfig to aggregate.
     */
    where?: PipelineConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineConfigs to fetch.
     */
    orderBy?: PipelineConfigOrderByWithRelationInput | PipelineConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PipelineConfigs
    **/
    _count?: true | PipelineConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineConfigMaxAggregateInputType
  }

  export type GetPipelineConfigAggregateType<T extends PipelineConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelineConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelineConfig[P]>
      : GetScalarType<T[P], AggregatePipelineConfig[P]>
  }




  export type PipelineConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineConfigWhereInput
    orderBy?: PipelineConfigOrderByWithAggregationInput | PipelineConfigOrderByWithAggregationInput[]
    by: PipelineConfigScalarFieldEnum[] | PipelineConfigScalarFieldEnum
    having?: PipelineConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineConfigCountAggregateInputType | true
    _min?: PipelineConfigMinAggregateInputType
    _max?: PipelineConfigMaxAggregateInputType
  }

  export type PipelineConfigGroupByOutputType = {
    id: string
    companyId: string
    name: string
    description: string | null
    stages: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PipelineConfigCountAggregateOutputType | null
    _min: PipelineConfigMinAggregateOutputType | null
    _max: PipelineConfigMaxAggregateOutputType | null
  }

  type GetPipelineConfigGroupByPayload<T extends PipelineConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineConfigGroupByOutputType[P]>
        }
      >
    >


  export type PipelineConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    stages?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    pipelines?: boolean | PipelineConfig$pipelinesArgs<ExtArgs>
    _count?: boolean | PipelineConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineConfig"]>

  export type PipelineConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    stages?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineConfig"]>

  export type PipelineConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    stages?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineConfig"]>

  export type PipelineConfigSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    stages?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PipelineConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "description" | "stages" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["pipelineConfig"]>
  export type PipelineConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
    pipelines?: boolean | PipelineConfig$pipelinesArgs<ExtArgs>
    _count?: boolean | PipelineConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelineConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type PipelineConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }

  export type $PipelineConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PipelineConfig"
    objects: {
      company: Prisma.$GoFastCompanyPayload<ExtArgs>
      pipelines: Prisma.$PipelinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      description: string | null
      stages: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pipelineConfig"]>
    composites: {}
  }

  type PipelineConfigGetPayload<S extends boolean | null | undefined | PipelineConfigDefaultArgs> = $Result.GetResult<Prisma.$PipelineConfigPayload, S>

  type PipelineConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineConfigCountAggregateInputType | true
    }

  export interface PipelineConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PipelineConfig'], meta: { name: 'PipelineConfig' } }
    /**
     * Find zero or one PipelineConfig that matches the filter.
     * @param {PipelineConfigFindUniqueArgs} args - Arguments to find a PipelineConfig
     * @example
     * // Get one PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineConfigFindUniqueArgs>(args: SelectSubset<T, PipelineConfigFindUniqueArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PipelineConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineConfigFindUniqueOrThrowArgs} args - Arguments to find a PipelineConfig
     * @example
     * // Get one PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PipelineConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigFindFirstArgs} args - Arguments to find a PipelineConfig
     * @example
     * // Get one PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineConfigFindFirstArgs>(args?: SelectSubset<T, PipelineConfigFindFirstArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PipelineConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigFindFirstOrThrowArgs} args - Arguments to find a PipelineConfig
     * @example
     * // Get one PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PipelineConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PipelineConfigs
     * const pipelineConfigs = await prisma.pipelineConfig.findMany()
     * 
     * // Get first 10 PipelineConfigs
     * const pipelineConfigs = await prisma.pipelineConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineConfigWithIdOnly = await prisma.pipelineConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineConfigFindManyArgs>(args?: SelectSubset<T, PipelineConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PipelineConfig.
     * @param {PipelineConfigCreateArgs} args - Arguments to create a PipelineConfig.
     * @example
     * // Create one PipelineConfig
     * const PipelineConfig = await prisma.pipelineConfig.create({
     *   data: {
     *     // ... data to create a PipelineConfig
     *   }
     * })
     * 
     */
    create<T extends PipelineConfigCreateArgs>(args: SelectSubset<T, PipelineConfigCreateArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PipelineConfigs.
     * @param {PipelineConfigCreateManyArgs} args - Arguments to create many PipelineConfigs.
     * @example
     * // Create many PipelineConfigs
     * const pipelineConfig = await prisma.pipelineConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineConfigCreateManyArgs>(args?: SelectSubset<T, PipelineConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PipelineConfigs and returns the data saved in the database.
     * @param {PipelineConfigCreateManyAndReturnArgs} args - Arguments to create many PipelineConfigs.
     * @example
     * // Create many PipelineConfigs
     * const pipelineConfig = await prisma.pipelineConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PipelineConfigs and only return the `id`
     * const pipelineConfigWithIdOnly = await prisma.pipelineConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PipelineConfig.
     * @param {PipelineConfigDeleteArgs} args - Arguments to delete one PipelineConfig.
     * @example
     * // Delete one PipelineConfig
     * const PipelineConfig = await prisma.pipelineConfig.delete({
     *   where: {
     *     // ... filter to delete one PipelineConfig
     *   }
     * })
     * 
     */
    delete<T extends PipelineConfigDeleteArgs>(args: SelectSubset<T, PipelineConfigDeleteArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PipelineConfig.
     * @param {PipelineConfigUpdateArgs} args - Arguments to update one PipelineConfig.
     * @example
     * // Update one PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineConfigUpdateArgs>(args: SelectSubset<T, PipelineConfigUpdateArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PipelineConfigs.
     * @param {PipelineConfigDeleteManyArgs} args - Arguments to filter PipelineConfigs to delete.
     * @example
     * // Delete a few PipelineConfigs
     * const { count } = await prisma.pipelineConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineConfigDeleteManyArgs>(args?: SelectSubset<T, PipelineConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PipelineConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PipelineConfigs
     * const pipelineConfig = await prisma.pipelineConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineConfigUpdateManyArgs>(args: SelectSubset<T, PipelineConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PipelineConfigs and returns the data updated in the database.
     * @param {PipelineConfigUpdateManyAndReturnArgs} args - Arguments to update many PipelineConfigs.
     * @example
     * // Update many PipelineConfigs
     * const pipelineConfig = await prisma.pipelineConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PipelineConfigs and only return the `id`
     * const pipelineConfigWithIdOnly = await prisma.pipelineConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelineConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelineConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PipelineConfig.
     * @param {PipelineConfigUpsertArgs} args - Arguments to update or create a PipelineConfig.
     * @example
     * // Update or create a PipelineConfig
     * const pipelineConfig = await prisma.pipelineConfig.upsert({
     *   create: {
     *     // ... data to create a PipelineConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PipelineConfig we want to update
     *   }
     * })
     */
    upsert<T extends PipelineConfigUpsertArgs>(args: SelectSubset<T, PipelineConfigUpsertArgs<ExtArgs>>): Prisma__PipelineConfigClient<$Result.GetResult<Prisma.$PipelineConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PipelineConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigCountArgs} args - Arguments to filter PipelineConfigs to count.
     * @example
     * // Count the number of PipelineConfigs
     * const count = await prisma.pipelineConfig.count({
     *   where: {
     *     // ... the filter for the PipelineConfigs we want to count
     *   }
     * })
    **/
    count<T extends PipelineConfigCountArgs>(
      args?: Subset<T, PipelineConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PipelineConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineConfigAggregateArgs>(args: Subset<T, PipelineConfigAggregateArgs>): Prisma.PrismaPromise<GetPipelineConfigAggregateType<T>>

    /**
     * Group by PipelineConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineConfigGroupByArgs['orderBy'] }
        : { orderBy?: PipelineConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PipelineConfig model
   */
  readonly fields: PipelineConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PipelineConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends GoFastCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompanyDefaultArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pipelines<T extends PipelineConfig$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, PipelineConfig$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PipelineConfig model
   */
  interface PipelineConfigFieldRefs {
    readonly id: FieldRef<"PipelineConfig", 'String'>
    readonly companyId: FieldRef<"PipelineConfig", 'String'>
    readonly name: FieldRef<"PipelineConfig", 'String'>
    readonly description: FieldRef<"PipelineConfig", 'String'>
    readonly stages: FieldRef<"PipelineConfig", 'Json'>
    readonly isActive: FieldRef<"PipelineConfig", 'Boolean'>
    readonly createdAt: FieldRef<"PipelineConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PipelineConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PipelineConfig findUnique
   */
  export type PipelineConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter, which PipelineConfig to fetch.
     */
    where: PipelineConfigWhereUniqueInput
  }

  /**
   * PipelineConfig findUniqueOrThrow
   */
  export type PipelineConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter, which PipelineConfig to fetch.
     */
    where: PipelineConfigWhereUniqueInput
  }

  /**
   * PipelineConfig findFirst
   */
  export type PipelineConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter, which PipelineConfig to fetch.
     */
    where?: PipelineConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineConfigs to fetch.
     */
    orderBy?: PipelineConfigOrderByWithRelationInput | PipelineConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineConfigs.
     */
    cursor?: PipelineConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineConfigs.
     */
    distinct?: PipelineConfigScalarFieldEnum | PipelineConfigScalarFieldEnum[]
  }

  /**
   * PipelineConfig findFirstOrThrow
   */
  export type PipelineConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter, which PipelineConfig to fetch.
     */
    where?: PipelineConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineConfigs to fetch.
     */
    orderBy?: PipelineConfigOrderByWithRelationInput | PipelineConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineConfigs.
     */
    cursor?: PipelineConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineConfigs.
     */
    distinct?: PipelineConfigScalarFieldEnum | PipelineConfigScalarFieldEnum[]
  }

  /**
   * PipelineConfig findMany
   */
  export type PipelineConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter, which PipelineConfigs to fetch.
     */
    where?: PipelineConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineConfigs to fetch.
     */
    orderBy?: PipelineConfigOrderByWithRelationInput | PipelineConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PipelineConfigs.
     */
    cursor?: PipelineConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineConfigs.
     */
    skip?: number
    distinct?: PipelineConfigScalarFieldEnum | PipelineConfigScalarFieldEnum[]
  }

  /**
   * PipelineConfig create
   */
  export type PipelineConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a PipelineConfig.
     */
    data: XOR<PipelineConfigCreateInput, PipelineConfigUncheckedCreateInput>
  }

  /**
   * PipelineConfig createMany
   */
  export type PipelineConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PipelineConfigs.
     */
    data: PipelineConfigCreateManyInput | PipelineConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PipelineConfig createManyAndReturn
   */
  export type PipelineConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * The data used to create many PipelineConfigs.
     */
    data: PipelineConfigCreateManyInput | PipelineConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PipelineConfig update
   */
  export type PipelineConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a PipelineConfig.
     */
    data: XOR<PipelineConfigUpdateInput, PipelineConfigUncheckedUpdateInput>
    /**
     * Choose, which PipelineConfig to update.
     */
    where: PipelineConfigWhereUniqueInput
  }

  /**
   * PipelineConfig updateMany
   */
  export type PipelineConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PipelineConfigs.
     */
    data: XOR<PipelineConfigUpdateManyMutationInput, PipelineConfigUncheckedUpdateManyInput>
    /**
     * Filter which PipelineConfigs to update
     */
    where?: PipelineConfigWhereInput
    /**
     * Limit how many PipelineConfigs to update.
     */
    limit?: number
  }

  /**
   * PipelineConfig updateManyAndReturn
   */
  export type PipelineConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * The data used to update PipelineConfigs.
     */
    data: XOR<PipelineConfigUpdateManyMutationInput, PipelineConfigUncheckedUpdateManyInput>
    /**
     * Filter which PipelineConfigs to update
     */
    where?: PipelineConfigWhereInput
    /**
     * Limit how many PipelineConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PipelineConfig upsert
   */
  export type PipelineConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the PipelineConfig to update in case it exists.
     */
    where: PipelineConfigWhereUniqueInput
    /**
     * In case the PipelineConfig found by the `where` argument doesn't exist, create a new PipelineConfig with this data.
     */
    create: XOR<PipelineConfigCreateInput, PipelineConfigUncheckedCreateInput>
    /**
     * In case the PipelineConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineConfigUpdateInput, PipelineConfigUncheckedUpdateInput>
  }

  /**
   * PipelineConfig delete
   */
  export type PipelineConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
    /**
     * Filter which PipelineConfig to delete.
     */
    where: PipelineConfigWhereUniqueInput
  }

  /**
   * PipelineConfig deleteMany
   */
  export type PipelineConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineConfigs to delete
     */
    where?: PipelineConfigWhereInput
    /**
     * Limit how many PipelineConfigs to delete.
     */
    limit?: number
  }

  /**
   * PipelineConfig.pipelines
   */
  export type PipelineConfig$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * PipelineConfig without action
   */
  export type PipelineConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineConfig
     */
    select?: PipelineConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PipelineConfig
     */
    omit?: PipelineConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineConfigInclude<ExtArgs> | null
  }


  /**
   * Model ProductPipelineItem
   */

  export type AggregateProductPipelineItem = {
    _count: ProductPipelineItemCountAggregateOutputType | null
    _min: ProductPipelineItemMinAggregateOutputType | null
    _max: ProductPipelineItemMaxAggregateOutputType | null
  }

  export type ProductPipelineItemMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    timeItTakes: string | null
    status: string | null
    priority: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductPipelineItemMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    timeItTakes: string | null
    status: string | null
    priority: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductPipelineItemCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    description: number
    timeItTakes: number
    status: number
    priority: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductPipelineItemMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    timeItTakes?: true
    status?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductPipelineItemMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    timeItTakes?: true
    status?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductPipelineItemCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    timeItTakes?: true
    status?: true
    priority?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductPipelineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPipelineItem to aggregate.
     */
    where?: ProductPipelineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPipelineItems to fetch.
     */
    orderBy?: ProductPipelineItemOrderByWithRelationInput | ProductPipelineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPipelineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPipelineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPipelineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPipelineItems
    **/
    _count?: true | ProductPipelineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPipelineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPipelineItemMaxAggregateInputType
  }

  export type GetProductPipelineItemAggregateType<T extends ProductPipelineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPipelineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPipelineItem[P]>
      : GetScalarType<T[P], AggregateProductPipelineItem[P]>
  }




  export type ProductPipelineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPipelineItemWhereInput
    orderBy?: ProductPipelineItemOrderByWithAggregationInput | ProductPipelineItemOrderByWithAggregationInput[]
    by: ProductPipelineItemScalarFieldEnum[] | ProductPipelineItemScalarFieldEnum
    having?: ProductPipelineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPipelineItemCountAggregateInputType | true
    _min?: ProductPipelineItemMinAggregateInputType
    _max?: ProductPipelineItemMaxAggregateInputType
  }

  export type ProductPipelineItemGroupByOutputType = {
    id: string
    companyId: string
    name: string
    description: string | null
    timeItTakes: string | null
    status: string
    priority: string
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductPipelineItemCountAggregateOutputType | null
    _min: ProductPipelineItemMinAggregateOutputType | null
    _max: ProductPipelineItemMaxAggregateOutputType | null
  }

  type GetProductPipelineItemGroupByPayload<T extends ProductPipelineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPipelineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPipelineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPipelineItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPipelineItemGroupByOutputType[P]>
        }
      >
    >


  export type ProductPipelineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    timeItTakes?: boolean
    status?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPipelineItem"]>

  export type ProductPipelineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    timeItTakes?: boolean
    status?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPipelineItem"]>

  export type ProductPipelineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    timeItTakes?: boolean
    status?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPipelineItem"]>

  export type ProductPipelineItemSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    timeItTakes?: boolean
    status?: boolean
    priority?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductPipelineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "description" | "timeItTakes" | "status" | "priority" | "startedAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["productPipelineItem"]>
  export type ProductPipelineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type ProductPipelineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }
  export type ProductPipelineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | GoFastCompanyDefaultArgs<ExtArgs>
  }

  export type $ProductPipelineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPipelineItem"
    objects: {
      company: Prisma.$GoFastCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      description: string | null
      timeItTakes: string | null
      status: string
      priority: string
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productPipelineItem"]>
    composites: {}
  }

  type ProductPipelineItemGetPayload<S extends boolean | null | undefined | ProductPipelineItemDefaultArgs> = $Result.GetResult<Prisma.$ProductPipelineItemPayload, S>

  type ProductPipelineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductPipelineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductPipelineItemCountAggregateInputType | true
    }

  export interface ProductPipelineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPipelineItem'], meta: { name: 'ProductPipelineItem' } }
    /**
     * Find zero or one ProductPipelineItem that matches the filter.
     * @param {ProductPipelineItemFindUniqueArgs} args - Arguments to find a ProductPipelineItem
     * @example
     * // Get one ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPipelineItemFindUniqueArgs>(args: SelectSubset<T, ProductPipelineItemFindUniqueArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductPipelineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductPipelineItemFindUniqueOrThrowArgs} args - Arguments to find a ProductPipelineItem
     * @example
     * // Get one ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPipelineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPipelineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPipelineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemFindFirstArgs} args - Arguments to find a ProductPipelineItem
     * @example
     * // Get one ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPipelineItemFindFirstArgs>(args?: SelectSubset<T, ProductPipelineItemFindFirstArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPipelineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemFindFirstOrThrowArgs} args - Arguments to find a ProductPipelineItem
     * @example
     * // Get one ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPipelineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPipelineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductPipelineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPipelineItems
     * const productPipelineItems = await prisma.productPipelineItem.findMany()
     * 
     * // Get first 10 ProductPipelineItems
     * const productPipelineItems = await prisma.productPipelineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPipelineItemWithIdOnly = await prisma.productPipelineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPipelineItemFindManyArgs>(args?: SelectSubset<T, ProductPipelineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductPipelineItem.
     * @param {ProductPipelineItemCreateArgs} args - Arguments to create a ProductPipelineItem.
     * @example
     * // Create one ProductPipelineItem
     * const ProductPipelineItem = await prisma.productPipelineItem.create({
     *   data: {
     *     // ... data to create a ProductPipelineItem
     *   }
     * })
     * 
     */
    create<T extends ProductPipelineItemCreateArgs>(args: SelectSubset<T, ProductPipelineItemCreateArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductPipelineItems.
     * @param {ProductPipelineItemCreateManyArgs} args - Arguments to create many ProductPipelineItems.
     * @example
     * // Create many ProductPipelineItems
     * const productPipelineItem = await prisma.productPipelineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPipelineItemCreateManyArgs>(args?: SelectSubset<T, ProductPipelineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPipelineItems and returns the data saved in the database.
     * @param {ProductPipelineItemCreateManyAndReturnArgs} args - Arguments to create many ProductPipelineItems.
     * @example
     * // Create many ProductPipelineItems
     * const productPipelineItem = await prisma.productPipelineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPipelineItems and only return the `id`
     * const productPipelineItemWithIdOnly = await prisma.productPipelineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPipelineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPipelineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductPipelineItem.
     * @param {ProductPipelineItemDeleteArgs} args - Arguments to delete one ProductPipelineItem.
     * @example
     * // Delete one ProductPipelineItem
     * const ProductPipelineItem = await prisma.productPipelineItem.delete({
     *   where: {
     *     // ... filter to delete one ProductPipelineItem
     *   }
     * })
     * 
     */
    delete<T extends ProductPipelineItemDeleteArgs>(args: SelectSubset<T, ProductPipelineItemDeleteArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductPipelineItem.
     * @param {ProductPipelineItemUpdateArgs} args - Arguments to update one ProductPipelineItem.
     * @example
     * // Update one ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPipelineItemUpdateArgs>(args: SelectSubset<T, ProductPipelineItemUpdateArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductPipelineItems.
     * @param {ProductPipelineItemDeleteManyArgs} args - Arguments to filter ProductPipelineItems to delete.
     * @example
     * // Delete a few ProductPipelineItems
     * const { count } = await prisma.productPipelineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPipelineItemDeleteManyArgs>(args?: SelectSubset<T, ProductPipelineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPipelineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPipelineItems
     * const productPipelineItem = await prisma.productPipelineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPipelineItemUpdateManyArgs>(args: SelectSubset<T, ProductPipelineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPipelineItems and returns the data updated in the database.
     * @param {ProductPipelineItemUpdateManyAndReturnArgs} args - Arguments to update many ProductPipelineItems.
     * @example
     * // Update many ProductPipelineItems
     * const productPipelineItem = await prisma.productPipelineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductPipelineItems and only return the `id`
     * const productPipelineItemWithIdOnly = await prisma.productPipelineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductPipelineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductPipelineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductPipelineItem.
     * @param {ProductPipelineItemUpsertArgs} args - Arguments to update or create a ProductPipelineItem.
     * @example
     * // Update or create a ProductPipelineItem
     * const productPipelineItem = await prisma.productPipelineItem.upsert({
     *   create: {
     *     // ... data to create a ProductPipelineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPipelineItem we want to update
     *   }
     * })
     */
    upsert<T extends ProductPipelineItemUpsertArgs>(args: SelectSubset<T, ProductPipelineItemUpsertArgs<ExtArgs>>): Prisma__ProductPipelineItemClient<$Result.GetResult<Prisma.$ProductPipelineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductPipelineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemCountArgs} args - Arguments to filter ProductPipelineItems to count.
     * @example
     * // Count the number of ProductPipelineItems
     * const count = await prisma.productPipelineItem.count({
     *   where: {
     *     // ... the filter for the ProductPipelineItems we want to count
     *   }
     * })
    **/
    count<T extends ProductPipelineItemCountArgs>(
      args?: Subset<T, ProductPipelineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPipelineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPipelineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPipelineItemAggregateArgs>(args: Subset<T, ProductPipelineItemAggregateArgs>): Prisma.PrismaPromise<GetProductPipelineItemAggregateType<T>>

    /**
     * Group by ProductPipelineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPipelineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPipelineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPipelineItemGroupByArgs['orderBy'] }
        : { orderBy?: ProductPipelineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPipelineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPipelineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPipelineItem model
   */
  readonly fields: ProductPipelineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPipelineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPipelineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends GoFastCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoFastCompanyDefaultArgs<ExtArgs>>): Prisma__GoFastCompanyClient<$Result.GetResult<Prisma.$GoFastCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPipelineItem model
   */
  interface ProductPipelineItemFieldRefs {
    readonly id: FieldRef<"ProductPipelineItem", 'String'>
    readonly companyId: FieldRef<"ProductPipelineItem", 'String'>
    readonly name: FieldRef<"ProductPipelineItem", 'String'>
    readonly description: FieldRef<"ProductPipelineItem", 'String'>
    readonly timeItTakes: FieldRef<"ProductPipelineItem", 'String'>
    readonly status: FieldRef<"ProductPipelineItem", 'String'>
    readonly priority: FieldRef<"ProductPipelineItem", 'String'>
    readonly startedAt: FieldRef<"ProductPipelineItem", 'DateTime'>
    readonly completedAt: FieldRef<"ProductPipelineItem", 'DateTime'>
    readonly createdAt: FieldRef<"ProductPipelineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductPipelineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPipelineItem findUnique
   */
  export type ProductPipelineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductPipelineItem to fetch.
     */
    where: ProductPipelineItemWhereUniqueInput
  }

  /**
   * ProductPipelineItem findUniqueOrThrow
   */
  export type ProductPipelineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductPipelineItem to fetch.
     */
    where: ProductPipelineItemWhereUniqueInput
  }

  /**
   * ProductPipelineItem findFirst
   */
  export type ProductPipelineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductPipelineItem to fetch.
     */
    where?: ProductPipelineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPipelineItems to fetch.
     */
    orderBy?: ProductPipelineItemOrderByWithRelationInput | ProductPipelineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPipelineItems.
     */
    cursor?: ProductPipelineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPipelineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPipelineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPipelineItems.
     */
    distinct?: ProductPipelineItemScalarFieldEnum | ProductPipelineItemScalarFieldEnum[]
  }

  /**
   * ProductPipelineItem findFirstOrThrow
   */
  export type ProductPipelineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductPipelineItem to fetch.
     */
    where?: ProductPipelineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPipelineItems to fetch.
     */
    orderBy?: ProductPipelineItemOrderByWithRelationInput | ProductPipelineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPipelineItems.
     */
    cursor?: ProductPipelineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPipelineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPipelineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPipelineItems.
     */
    distinct?: ProductPipelineItemScalarFieldEnum | ProductPipelineItemScalarFieldEnum[]
  }

  /**
   * ProductPipelineItem findMany
   */
  export type ProductPipelineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductPipelineItems to fetch.
     */
    where?: ProductPipelineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPipelineItems to fetch.
     */
    orderBy?: ProductPipelineItemOrderByWithRelationInput | ProductPipelineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPipelineItems.
     */
    cursor?: ProductPipelineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPipelineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPipelineItems.
     */
    skip?: number
    distinct?: ProductPipelineItemScalarFieldEnum | ProductPipelineItemScalarFieldEnum[]
  }

  /**
   * ProductPipelineItem create
   */
  export type ProductPipelineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPipelineItem.
     */
    data: XOR<ProductPipelineItemCreateInput, ProductPipelineItemUncheckedCreateInput>
  }

  /**
   * ProductPipelineItem createMany
   */
  export type ProductPipelineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPipelineItems.
     */
    data: ProductPipelineItemCreateManyInput | ProductPipelineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPipelineItem createManyAndReturn
   */
  export type ProductPipelineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * The data used to create many ProductPipelineItems.
     */
    data: ProductPipelineItemCreateManyInput | ProductPipelineItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPipelineItem update
   */
  export type ProductPipelineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPipelineItem.
     */
    data: XOR<ProductPipelineItemUpdateInput, ProductPipelineItemUncheckedUpdateInput>
    /**
     * Choose, which ProductPipelineItem to update.
     */
    where: ProductPipelineItemWhereUniqueInput
  }

  /**
   * ProductPipelineItem updateMany
   */
  export type ProductPipelineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPipelineItems.
     */
    data: XOR<ProductPipelineItemUpdateManyMutationInput, ProductPipelineItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductPipelineItems to update
     */
    where?: ProductPipelineItemWhereInput
    /**
     * Limit how many ProductPipelineItems to update.
     */
    limit?: number
  }

  /**
   * ProductPipelineItem updateManyAndReturn
   */
  export type ProductPipelineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * The data used to update ProductPipelineItems.
     */
    data: XOR<ProductPipelineItemUpdateManyMutationInput, ProductPipelineItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductPipelineItems to update
     */
    where?: ProductPipelineItemWhereInput
    /**
     * Limit how many ProductPipelineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPipelineItem upsert
   */
  export type ProductPipelineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPipelineItem to update in case it exists.
     */
    where: ProductPipelineItemWhereUniqueInput
    /**
     * In case the ProductPipelineItem found by the `where` argument doesn't exist, create a new ProductPipelineItem with this data.
     */
    create: XOR<ProductPipelineItemCreateInput, ProductPipelineItemUncheckedCreateInput>
    /**
     * In case the ProductPipelineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPipelineItemUpdateInput, ProductPipelineItemUncheckedUpdateInput>
  }

  /**
   * ProductPipelineItem delete
   */
  export type ProductPipelineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
    /**
     * Filter which ProductPipelineItem to delete.
     */
    where: ProductPipelineItemWhereUniqueInput
  }

  /**
   * ProductPipelineItem deleteMany
   */
  export type ProductPipelineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPipelineItems to delete
     */
    where?: ProductPipelineItemWhereInput
    /**
     * Limit how many ProductPipelineItems to delete.
     */
    limit?: number
  }

  /**
   * ProductPipelineItem without action
   */
  export type ProductPipelineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPipelineItem
     */
    select?: ProductPipelineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPipelineItem
     */
    omit?: ProductPipelineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPipelineItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AthleteScalarFieldEnum: {
    id: 'id',
    firebaseId: 'firebaseId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    gofastHandle: 'gofastHandle',
    birthday: 'birthday',
    gender: 'gender',
    city: 'city',
    state: 'state',
    primarySport: 'primarySport',
    photoURL: 'photoURL',
    bio: 'bio',
    instagram: 'instagram',
    currentPace: 'currentPace',
    weeklyMileage: 'weeklyMileage',
    trainingGoal: 'trainingGoal',
    targetRace: 'targetRace',
    trainingStartDate: 'trainingStartDate',
    preferredDistance: 'preferredDistance',
    timePreference: 'timePreference',
    paceRange: 'paceRange',
    runningGoals: 'runningGoals',
    garmin_user_id: 'garmin_user_id',
    garmin_access_token: 'garmin_access_token',
    garmin_refresh_token: 'garmin_refresh_token',
    garmin_expires_in: 'garmin_expires_in',
    garmin_scope: 'garmin_scope',
    garmin_connected_at: 'garmin_connected_at',
    garmin_last_sync_at: 'garmin_last_sync_at',
    garmin_permissions: 'garmin_permissions',
    garmin_is_connected: 'garmin_is_connected',
    garmin_disconnected_at: 'garmin_disconnected_at',
    strava_id: 'strava_id',
    strava_access_token: 'strava_access_token',
    strava_refresh_token: 'strava_refresh_token',
    strava_expires_at: 'strava_expires_at',
    garmin_user_profile: 'garmin_user_profile',
    garmin_user_sleep: 'garmin_user_sleep',
    garmin_user_preferences: 'garmin_user_preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AthleteScalarFieldEnum = (typeof AthleteScalarFieldEnum)[keyof typeof AthleteScalarFieldEnum]


  export const AthleteActivityScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    sourceActivityId: 'sourceActivityId',
    source: 'source',
    activityType: 'activityType',
    activityName: 'activityName',
    startTime: 'startTime',
    duration: 'duration',
    distance: 'distance',
    averageSpeed: 'averageSpeed',
    calories: 'calories',
    averageHeartRate: 'averageHeartRate',
    maxHeartRate: 'maxHeartRate',
    elevationGain: 'elevationGain',
    steps: 'steps',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    summaryPolyline: 'summaryPolyline',
    deviceName: 'deviceName',
    garminUserId: 'garminUserId',
    summaryData: 'summaryData',
    detailData: 'detailData',
    hydratedAt: 'hydratedAt',
    syncedAt: 'syncedAt',
    lastUpdatedAt: 'lastUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AthleteActivityScalarFieldEnum = (typeof AthleteActivityScalarFieldEnum)[keyof typeof AthleteActivityScalarFieldEnum]


  export const RunCrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    joinCode: 'joinCode',
    logo: 'logo',
    icon: 'icon',
    runcrewAdminId: 'runcrewAdminId',
    isArchived: 'isArchived',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewScalarFieldEnum = (typeof RunCrewScalarFieldEnum)[keyof typeof RunCrewScalarFieldEnum]


  export const RunCrewMembershipScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewMembershipScalarFieldEnum = (typeof RunCrewMembershipScalarFieldEnum)[keyof typeof RunCrewMembershipScalarFieldEnum]


  export const RunCrewMessageScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type RunCrewMessageScalarFieldEnum = (typeof RunCrewMessageScalarFieldEnum)[keyof typeof RunCrewMessageScalarFieldEnum]


  export const RunCrewAnnouncementScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewAnnouncementScalarFieldEnum = (typeof RunCrewAnnouncementScalarFieldEnum)[keyof typeof RunCrewAnnouncementScalarFieldEnum]


  export const RunCrewLeaderboardScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    totalMiles: 'totalMiles',
    totalRuns: 'totalRuns',
    bestPace: 'bestPace',
    totalCalories: 'totalCalories',
    totalElevation: 'totalElevation',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewLeaderboardScalarFieldEnum = (typeof RunCrewLeaderboardScalarFieldEnum)[keyof typeof RunCrewLeaderboardScalarFieldEnum]


  export const RunCrewRunScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    createdById: 'createdById',
    title: 'title',
    date: 'date',
    startTime: 'startTime',
    location: 'location',
    address: 'address',
    totalMiles: 'totalMiles',
    pace: 'pace',
    stravaMapUrl: 'stravaMapUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewRunScalarFieldEnum = (typeof RunCrewRunScalarFieldEnum)[keyof typeof RunCrewRunScalarFieldEnum]


  export const RunCrewRunRSVPScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    athleteId: 'athleteId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type RunCrewRunRSVPScalarFieldEnum = (typeof RunCrewRunRSVPScalarFieldEnum)[keyof typeof RunCrewRunRSVPScalarFieldEnum]


  export const RunCrewEventScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    organizerId: 'organizerId',
    title: 'title',
    date: 'date',
    time: 'time',
    location: 'location',
    address: 'address',
    description: 'description',
    eventType: 'eventType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RunCrewEventScalarFieldEnum = (typeof RunCrewEventScalarFieldEnum)[keyof typeof RunCrewEventScalarFieldEnum]


  export const RunCrewEventRSVPScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    athleteId: 'athleteId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type RunCrewEventRSVPScalarFieldEnum = (typeof RunCrewEventRSVPScalarFieldEnum)[keyof typeof RunCrewEventRSVPScalarFieldEnum]


  export const RunCrewManagerScalarFieldEnum: {
    id: 'id',
    runCrewId: 'runCrewId',
    athleteId: 'athleteId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type RunCrewManagerScalarFieldEnum = (typeof RunCrewManagerScalarFieldEnum)[keyof typeof RunCrewManagerScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    id: 'id',
    raceName: 'raceName',
    raceType: 'raceType',
    raceDate: 'raceDate',
    location: 'location',
    distanceMiles: 'distanceMiles',
    registrationUrl: 'registrationUrl',
    description: 'description',
    courseProfile: 'courseProfile',
    createdByAthleteId: 'createdByAthleteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const TrainingPlanScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    raceId: 'raceId',
    goalTime: 'goalTime',
    goalPace: 'goalPace',
    baseline5k: 'baseline5k',
    baselineWeeklyMileage: 'baselineWeeklyMileage',
    startDate: 'startDate',
    totalWeeks: 'totalWeeks',
    phaseOverview: 'phaseOverview',
    weeklyMileagePlan: 'weeklyMileagePlan',
    weeks: 'weeks',
    adaptive5kTime: 'adaptive5kTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingPlanScalarFieldEnum = (typeof TrainingPlanScalarFieldEnum)[keyof typeof TrainingPlanScalarFieldEnum]


  export const TrainingDayPlannedScalarFieldEnum: {
    id: 'id',
    trainingPlanId: 'trainingPlanId',
    athleteId: 'athleteId',
    date: 'date',
    weekIndex: 'weekIndex',
    dayIndex: 'dayIndex',
    dayName: 'dayName',
    phase: 'phase',
    plannedData: 'plannedData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDayPlannedScalarFieldEnum = (typeof TrainingDayPlannedScalarFieldEnum)[keyof typeof TrainingDayPlannedScalarFieldEnum]


  export const TrainingPlanExecutionScalarFieldEnum: {
    id: 'id',
    trainingPlanId: 'trainingPlanId',
    startedAt: 'startedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingPlanExecutionScalarFieldEnum = (typeof TrainingPlanExecutionScalarFieldEnum)[keyof typeof TrainingPlanExecutionScalarFieldEnum]


  export const TrainingDayExecutedScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    athleteId: 'athleteId',
    activityId: 'activityId',
    weekIndex: 'weekIndex',
    dayIndex: 'dayIndex',
    date: 'date',
    plannedData: 'plannedData',
    analysis: 'analysis',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDayExecutedScalarFieldEnum = (typeof TrainingDayExecutedScalarFieldEnum)[keyof typeof TrainingDayExecutedScalarFieldEnum]


  export const FounderScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FounderScalarFieldEnum = (typeof FounderScalarFieldEnum)[keyof typeof FounderScalarFieldEnum]


  export const FounderTaskScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FounderTaskScalarFieldEnum = (typeof FounderTaskScalarFieldEnum)[keyof typeof FounderTaskScalarFieldEnum]


  export const CrmContactScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    name: 'name',
    role: 'role',
    email: 'email',
    company: 'company',
    pipeline: 'pipeline',
    status: 'status',
    nextStep: 'nextStep',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrmContactScalarFieldEnum = (typeof CrmContactScalarFieldEnum)[keyof typeof CrmContactScalarFieldEnum]


  export const RoadmapItemScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    roadmapType: 'roadmapType',
    quarter: 'quarter',
    category: 'category',
    title: 'title',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapItemScalarFieldEnum = (typeof RoadmapItemScalarFieldEnum)[keyof typeof RoadmapItemScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyFounderScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    founderId: 'founderId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type CompanyFounderScalarFieldEnum = (typeof CompanyFounderScalarFieldEnum)[keyof typeof CompanyFounderScalarFieldEnum]


  export const CompanyEmployeeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    email: 'email',
    name: 'name',
    role: 'role',
    department: 'department',
    phoneNumber: 'phoneNumber',
    joinedAt: 'joinedAt'
  };

  export type CompanyEmployeeScalarFieldEnum = (typeof CompanyEmployeeScalarFieldEnum)[keyof typeof CompanyEmployeeScalarFieldEnum]


  export const CompanyRoadmapItemScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    itemType: 'itemType',
    parentArchitecture: 'parentArchitecture',
    roadmapType: 'roadmapType',
    category: 'category',
    title: 'title',
    whatItDoes: 'whatItDoes',
    howItHelps: 'howItHelps',
    fieldsData: 'fieldsData',
    howToGet: 'howToGet',
    prerequisites: 'prerequisites',
    visual: 'visual',
    orderNumber: 'orderNumber',
    hoursEstimated: 'hoursEstimated',
    hoursSpent: 'hoursSpent',
    targetDate: 'targetDate',
    dueDate: 'dueDate',
    status: 'status',
    priority: 'priority',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    goFastCompanyId: 'goFastCompanyId'
  };

  export type CompanyRoadmapItemScalarFieldEnum = (typeof CompanyRoadmapItemScalarFieldEnum)[keyof typeof CompanyRoadmapItemScalarFieldEnum]


  export const CompanyCrmContactScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    role: 'role',
    email: 'email',
    companyName: 'companyName',
    pipeline: 'pipeline',
    status: 'status',
    nextStep: 'nextStep',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyCrmContactScalarFieldEnum = (typeof CompanyCrmContactScalarFieldEnum)[keyof typeof CompanyCrmContactScalarFieldEnum]


  export const CompanyFinancialSpendScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    date: 'date',
    amount: 'amount',
    category: 'category',
    description: 'description',
    vendor: 'vendor',
    department: 'department',
    project: 'project',
    receiptUrl: 'receiptUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    goFastCompanyId: 'goFastCompanyId'
  };

  export type CompanyFinancialSpendScalarFieldEnum = (typeof CompanyFinancialSpendScalarFieldEnum)[keyof typeof CompanyFinancialSpendScalarFieldEnum]


  export const CompanyFinancialProjectionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    projectedRevenue: 'projectedRevenue',
    projectedExpenses: 'projectedExpenses',
    projectedNet: 'projectedNet',
    categoryBreakdown: 'categoryBreakdown',
    currentCash: 'currentCash',
    monthlyBurnRate: 'monthlyBurnRate',
    runwayMonths: 'runwayMonths',
    assumptions: 'assumptions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    goFastCompanyId: 'goFastCompanyId'
  };

  export type CompanyFinancialProjectionScalarFieldEnum = (typeof CompanyFinancialProjectionScalarFieldEnum)[keyof typeof CompanyFinancialProjectionScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    companyId: 'companyId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    department: 'department',
    isTopPriority: 'isTopPriority',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    goFastCompanyId: 'goFastCompanyId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    authorId: 'authorId',
    author: 'author',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const GoFastCompanyScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    companyName: 'companyName',
    address: 'address',
    city: 'city',
    state: 'state',
    website: 'website',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoFastCompanyScalarFieldEnum = (typeof GoFastCompanyScalarFieldEnum)[keyof typeof GoFastCompanyScalarFieldEnum]


  export const CompanyStaffScalarFieldEnum: {
    id: 'id',
    firebaseId: 'firebaseId',
    name: 'name',
    email: 'email',
    photoURL: 'photoURL',
    companyId: 'companyId',
    role: 'role',
    department: 'department',
    verificationCode: 'verificationCode',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyStaffScalarFieldEnum = (typeof CompanyStaffScalarFieldEnum)[keyof typeof CompanyStaffScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    firstName: 'firstName',
    lastName: 'lastName',
    goesBy: 'goesBy',
    email: 'email',
    phone: 'phone',
    title: 'title',
    athleteId: 'athleteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    contactId: 'contactId',
    configId: 'configId',
    stageId: 'stageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const PipelineConfigScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    description: 'description',
    stages: 'stages',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PipelineConfigScalarFieldEnum = (typeof PipelineConfigScalarFieldEnum)[keyof typeof PipelineConfigScalarFieldEnum]


  export const ProductPipelineItemScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    description: 'description',
    timeItTakes: 'timeItTakes',
    status: 'status',
    priority: 'priority',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductPipelineItemScalarFieldEnum = (typeof ProductPipelineItemScalarFieldEnum)[keyof typeof ProductPipelineItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AthleteWhereInput = {
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    id?: StringFilter<"Athlete"> | string
    firebaseId?: StringFilter<"Athlete"> | string
    firstName?: StringNullableFilter<"Athlete"> | string | null
    lastName?: StringNullableFilter<"Athlete"> | string | null
    email?: StringFilter<"Athlete"> | string
    phoneNumber?: StringNullableFilter<"Athlete"> | string | null
    gofastHandle?: StringNullableFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    gender?: StringNullableFilter<"Athlete"> | string | null
    city?: StringNullableFilter<"Athlete"> | string | null
    state?: StringNullableFilter<"Athlete"> | string | null
    primarySport?: StringNullableFilter<"Athlete"> | string | null
    photoURL?: StringNullableFilter<"Athlete"> | string | null
    bio?: StringNullableFilter<"Athlete"> | string | null
    instagram?: StringNullableFilter<"Athlete"> | string | null
    currentPace?: StringNullableFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableFilter<"Athlete"> | string | null
    targetRace?: StringNullableFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableFilter<"Athlete"> | string | null
    timePreference?: StringNullableFilter<"Athlete"> | string | null
    paceRange?: StringNullableFilter<"Athlete"> | string | null
    runningGoals?: StringNullableFilter<"Athlete"> | string | null
    garmin_user_id?: StringNullableFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableFilter<"Athlete">
    garmin_is_connected?: BoolFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    strava_id?: IntNullableFilter<"Athlete"> | number | null
    strava_access_token?: StringNullableFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableFilter<"Athlete">
    garmin_user_sleep?: JsonNullableFilter<"Athlete">
    garmin_user_preferences?: JsonNullableFilter<"Athlete">
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeFilter<"Athlete"> | Date | string
    status?: StringNullableFilter<"Athlete"> | string | null
    activities?: AthleteActivityListRelationFilter
    adminRunCrews?: RunCrewListRelationFilter
    runCrewMemberships?: RunCrewMembershipListRelationFilter
    runCrewMessages?: RunCrewMessageListRelationFilter
    runCrewAnnouncements?: RunCrewAnnouncementListRelationFilter
    runCrewLeaderboards?: RunCrewLeaderboardListRelationFilter
    runCrewRuns?: RunCrewRunListRelationFilter
    runCrewRunRSVPs?: RunCrewRunRSVPListRelationFilter
    runCrewEvents?: RunCrewEventListRelationFilter
    runCrewEventRSVPs?: RunCrewEventRSVPListRelationFilter
    runCrewManagers?: RunCrewManagerListRelationFilter
    createdRaces?: RaceListRelationFilter
    trainingPlans?: TrainingPlanListRelationFilter
    plannedDays?: TrainingDayPlannedListRelationFilter
    executedDays?: TrainingDayExecutedListRelationFilter
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
  }

  export type AthleteOrderByWithRelationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    gofastHandle?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    primarySport?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    currentPace?: SortOrderInput | SortOrder
    weeklyMileage?: SortOrderInput | SortOrder
    trainingGoal?: SortOrderInput | SortOrder
    targetRace?: SortOrderInput | SortOrder
    trainingStartDate?: SortOrderInput | SortOrder
    preferredDistance?: SortOrderInput | SortOrder
    timePreference?: SortOrderInput | SortOrder
    paceRange?: SortOrderInput | SortOrder
    runningGoals?: SortOrderInput | SortOrder
    garmin_user_id?: SortOrderInput | SortOrder
    garmin_access_token?: SortOrderInput | SortOrder
    garmin_refresh_token?: SortOrderInput | SortOrder
    garmin_expires_in?: SortOrderInput | SortOrder
    garmin_scope?: SortOrderInput | SortOrder
    garmin_connected_at?: SortOrderInput | SortOrder
    garmin_last_sync_at?: SortOrderInput | SortOrder
    garmin_permissions?: SortOrderInput | SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrderInput | SortOrder
    strava_id?: SortOrderInput | SortOrder
    strava_access_token?: SortOrderInput | SortOrder
    strava_refresh_token?: SortOrderInput | SortOrder
    strava_expires_at?: SortOrderInput | SortOrder
    garmin_user_profile?: SortOrderInput | SortOrder
    garmin_user_sleep?: SortOrderInput | SortOrder
    garmin_user_preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    activities?: AthleteActivityOrderByRelationAggregateInput
    adminRunCrews?: RunCrewOrderByRelationAggregateInput
    runCrewMemberships?: RunCrewMembershipOrderByRelationAggregateInput
    runCrewMessages?: RunCrewMessageOrderByRelationAggregateInput
    runCrewAnnouncements?: RunCrewAnnouncementOrderByRelationAggregateInput
    runCrewLeaderboards?: RunCrewLeaderboardOrderByRelationAggregateInput
    runCrewRuns?: RunCrewRunOrderByRelationAggregateInput
    runCrewRunRSVPs?: RunCrewRunRSVPOrderByRelationAggregateInput
    runCrewEvents?: RunCrewEventOrderByRelationAggregateInput
    runCrewEventRSVPs?: RunCrewEventRSVPOrderByRelationAggregateInput
    runCrewManagers?: RunCrewManagerOrderByRelationAggregateInput
    createdRaces?: RaceOrderByRelationAggregateInput
    trainingPlans?: TrainingPlanOrderByRelationAggregateInput
    plannedDays?: TrainingDayPlannedOrderByRelationAggregateInput
    executedDays?: TrainingDayExecutedOrderByRelationAggregateInput
    founder?: FounderOrderByWithRelationInput
  }

  export type AthleteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firebaseId?: string
    email?: string
    gofastHandle?: string
    garmin_user_id?: string
    strava_id?: number
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    firstName?: StringNullableFilter<"Athlete"> | string | null
    lastName?: StringNullableFilter<"Athlete"> | string | null
    phoneNumber?: StringNullableFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    gender?: StringNullableFilter<"Athlete"> | string | null
    city?: StringNullableFilter<"Athlete"> | string | null
    state?: StringNullableFilter<"Athlete"> | string | null
    primarySport?: StringNullableFilter<"Athlete"> | string | null
    photoURL?: StringNullableFilter<"Athlete"> | string | null
    bio?: StringNullableFilter<"Athlete"> | string | null
    instagram?: StringNullableFilter<"Athlete"> | string | null
    currentPace?: StringNullableFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableFilter<"Athlete"> | string | null
    targetRace?: StringNullableFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableFilter<"Athlete"> | string | null
    timePreference?: StringNullableFilter<"Athlete"> | string | null
    paceRange?: StringNullableFilter<"Athlete"> | string | null
    runningGoals?: StringNullableFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableFilter<"Athlete">
    garmin_is_connected?: BoolFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableFilter<"Athlete"> | Date | string | null
    strava_access_token?: StringNullableFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableFilter<"Athlete">
    garmin_user_sleep?: JsonNullableFilter<"Athlete">
    garmin_user_preferences?: JsonNullableFilter<"Athlete">
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeFilter<"Athlete"> | Date | string
    status?: StringNullableFilter<"Athlete"> | string | null
    activities?: AthleteActivityListRelationFilter
    adminRunCrews?: RunCrewListRelationFilter
    runCrewMemberships?: RunCrewMembershipListRelationFilter
    runCrewMessages?: RunCrewMessageListRelationFilter
    runCrewAnnouncements?: RunCrewAnnouncementListRelationFilter
    runCrewLeaderboards?: RunCrewLeaderboardListRelationFilter
    runCrewRuns?: RunCrewRunListRelationFilter
    runCrewRunRSVPs?: RunCrewRunRSVPListRelationFilter
    runCrewEvents?: RunCrewEventListRelationFilter
    runCrewEventRSVPs?: RunCrewEventRSVPListRelationFilter
    runCrewManagers?: RunCrewManagerListRelationFilter
    createdRaces?: RaceListRelationFilter
    trainingPlans?: TrainingPlanListRelationFilter
    plannedDays?: TrainingDayPlannedListRelationFilter
    executedDays?: TrainingDayExecutedListRelationFilter
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
  }, "id" | "firebaseId" | "email" | "gofastHandle" | "garmin_user_id" | "strava_id">

  export type AthleteOrderByWithAggregationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    gofastHandle?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    primarySport?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    currentPace?: SortOrderInput | SortOrder
    weeklyMileage?: SortOrderInput | SortOrder
    trainingGoal?: SortOrderInput | SortOrder
    targetRace?: SortOrderInput | SortOrder
    trainingStartDate?: SortOrderInput | SortOrder
    preferredDistance?: SortOrderInput | SortOrder
    timePreference?: SortOrderInput | SortOrder
    paceRange?: SortOrderInput | SortOrder
    runningGoals?: SortOrderInput | SortOrder
    garmin_user_id?: SortOrderInput | SortOrder
    garmin_access_token?: SortOrderInput | SortOrder
    garmin_refresh_token?: SortOrderInput | SortOrder
    garmin_expires_in?: SortOrderInput | SortOrder
    garmin_scope?: SortOrderInput | SortOrder
    garmin_connected_at?: SortOrderInput | SortOrder
    garmin_last_sync_at?: SortOrderInput | SortOrder
    garmin_permissions?: SortOrderInput | SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrderInput | SortOrder
    strava_id?: SortOrderInput | SortOrder
    strava_access_token?: SortOrderInput | SortOrder
    strava_refresh_token?: SortOrderInput | SortOrder
    strava_expires_at?: SortOrderInput | SortOrder
    garmin_user_profile?: SortOrderInput | SortOrder
    garmin_user_sleep?: SortOrderInput | SortOrder
    garmin_user_preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: AthleteCountOrderByAggregateInput
    _avg?: AthleteAvgOrderByAggregateInput
    _max?: AthleteMaxOrderByAggregateInput
    _min?: AthleteMinOrderByAggregateInput
    _sum?: AthleteSumOrderByAggregateInput
  }

  export type AthleteScalarWhereWithAggregatesInput = {
    AND?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    OR?: AthleteScalarWhereWithAggregatesInput[]
    NOT?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Athlete"> | string
    firebaseId?: StringWithAggregatesFilter<"Athlete"> | string
    firstName?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    email?: StringWithAggregatesFilter<"Athlete"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    gofastHandle?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    city?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    state?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    primarySport?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    photoURL?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    currentPace?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    weeklyMileage?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    trainingGoal?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    targetRace?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    trainingStartDate?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    preferredDistance?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    timePreference?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    paceRange?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    runningGoals?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_user_id?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_access_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_refresh_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_expires_in?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    garmin_scope?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    garmin_connected_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    garmin_last_sync_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    garmin_permissions?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_is_connected?: BoolWithAggregatesFilter<"Athlete"> | boolean
    garmin_disconnected_at?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
    strava_id?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    strava_access_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    strava_refresh_token?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    strava_expires_at?: IntNullableWithAggregatesFilter<"Athlete"> | number | null
    garmin_user_profile?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_user_sleep?: JsonNullableWithAggregatesFilter<"Athlete">
    garmin_user_preferences?: JsonNullableWithAggregatesFilter<"Athlete">
    createdAt?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    status?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
  }

  export type AthleteActivityWhereInput = {
    AND?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    OR?: AthleteActivityWhereInput[]
    NOT?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    id?: StringFilter<"AthleteActivity"> | string
    athleteId?: StringFilter<"AthleteActivity"> | string
    sourceActivityId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type AthleteActivityOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrderInput | SortOrder
    activityName?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    averageHeartRate?: SortOrderInput | SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    elevationGain?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    summaryPolyline?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    garminUserId?: SortOrderInput | SortOrder
    summaryData?: SortOrderInput | SortOrder
    detailData?: SortOrderInput | SortOrder
    hydratedAt?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
  }

  export type AthleteActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceActivityId?: string
    AND?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    OR?: AthleteActivityWhereInput[]
    NOT?: AthleteActivityWhereInput | AthleteActivityWhereInput[]
    athleteId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "sourceActivityId">

  export type AthleteActivityOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrderInput | SortOrder
    activityName?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    averageHeartRate?: SortOrderInput | SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    elevationGain?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    summaryPolyline?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    garminUserId?: SortOrderInput | SortOrder
    summaryData?: SortOrderInput | SortOrder
    detailData?: SortOrderInput | SortOrder
    hydratedAt?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AthleteActivityCountOrderByAggregateInput
    _avg?: AthleteActivityAvgOrderByAggregateInput
    _max?: AthleteActivityMaxOrderByAggregateInput
    _min?: AthleteActivityMinOrderByAggregateInput
    _sum?: AthleteActivitySumOrderByAggregateInput
  }

  export type AthleteActivityScalarWhereWithAggregatesInput = {
    AND?: AthleteActivityScalarWhereWithAggregatesInput | AthleteActivityScalarWhereWithAggregatesInput[]
    OR?: AthleteActivityScalarWhereWithAggregatesInput[]
    NOT?: AthleteActivityScalarWhereWithAggregatesInput | AthleteActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AthleteActivity"> | string
    athleteId?: StringWithAggregatesFilter<"AthleteActivity"> | string
    sourceActivityId?: StringWithAggregatesFilter<"AthleteActivity"> | string
    source?: StringWithAggregatesFilter<"AthleteActivity"> | string
    activityType?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableWithAggregatesFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    calories?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    steps?: IntNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableWithAggregatesFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableWithAggregatesFilter<"AthleteActivity">
    detailData?: JsonNullableWithAggregatesFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableWithAggregatesFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AthleteActivity"> | Date | string
  }

  export type RunCrewWhereInput = {
    AND?: RunCrewWhereInput | RunCrewWhereInput[]
    OR?: RunCrewWhereInput[]
    NOT?: RunCrewWhereInput | RunCrewWhereInput[]
    id?: StringFilter<"RunCrew"> | string
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    joinCode?: StringFilter<"RunCrew"> | string
    logo?: StringNullableFilter<"RunCrew"> | string | null
    icon?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringNullableFilter<"RunCrew"> | string | null
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
    admin?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    memberships?: RunCrewMembershipListRelationFilter
    messages?: RunCrewMessageListRelationFilter
    announcements?: RunCrewAnnouncementListRelationFilter
    leaderboardEntries?: RunCrewLeaderboardListRelationFilter
    runs?: RunCrewRunListRelationFilter
    events?: RunCrewEventListRelationFilter
    managers?: RunCrewManagerListRelationFilter
  }

  export type RunCrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    joinCode?: SortOrder
    logo?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    runcrewAdminId?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AthleteOrderByWithRelationInput
    memberships?: RunCrewMembershipOrderByRelationAggregateInput
    messages?: RunCrewMessageOrderByRelationAggregateInput
    announcements?: RunCrewAnnouncementOrderByRelationAggregateInput
    leaderboardEntries?: RunCrewLeaderboardOrderByRelationAggregateInput
    runs?: RunCrewRunOrderByRelationAggregateInput
    events?: RunCrewEventOrderByRelationAggregateInput
    managers?: RunCrewManagerOrderByRelationAggregateInput
  }

  export type RunCrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    joinCode?: string
    AND?: RunCrewWhereInput | RunCrewWhereInput[]
    OR?: RunCrewWhereInput[]
    NOT?: RunCrewWhereInput | RunCrewWhereInput[]
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    logo?: StringNullableFilter<"RunCrew"> | string | null
    icon?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringNullableFilter<"RunCrew"> | string | null
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
    admin?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    memberships?: RunCrewMembershipListRelationFilter
    messages?: RunCrewMessageListRelationFilter
    announcements?: RunCrewAnnouncementListRelationFilter
    leaderboardEntries?: RunCrewLeaderboardListRelationFilter
    runs?: RunCrewRunListRelationFilter
    events?: RunCrewEventListRelationFilter
    managers?: RunCrewManagerListRelationFilter
  }, "id" | "joinCode">

  export type RunCrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    joinCode?: SortOrder
    logo?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    runcrewAdminId?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewCountOrderByAggregateInput
    _max?: RunCrewMaxOrderByAggregateInput
    _min?: RunCrewMinOrderByAggregateInput
  }

  export type RunCrewScalarWhereWithAggregatesInput = {
    AND?: RunCrewScalarWhereWithAggregatesInput | RunCrewScalarWhereWithAggregatesInput[]
    OR?: RunCrewScalarWhereWithAggregatesInput[]
    NOT?: RunCrewScalarWhereWithAggregatesInput | RunCrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrew"> | string
    name?: StringWithAggregatesFilter<"RunCrew"> | string
    description?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    joinCode?: StringWithAggregatesFilter<"RunCrew"> | string
    logo?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    icon?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringNullableWithAggregatesFilter<"RunCrew"> | string | null
    isArchived?: BoolWithAggregatesFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrew"> | Date | string
  }

  export type RunCrewMembershipWhereInput = {
    AND?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    OR?: RunCrewMembershipWhereInput[]
    NOT?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    id?: StringFilter<"RunCrewMembership"> | string
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewMembershipOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runCrewId_athleteId?: RunCrewMembershipRunCrewIdAthleteIdCompoundUniqueInput
    AND?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    OR?: RunCrewMembershipWhereInput[]
    NOT?: RunCrewMembershipWhereInput | RunCrewMembershipWhereInput[]
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runCrewId_athleteId">

  export type RunCrewMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewMembershipCountOrderByAggregateInput
    _max?: RunCrewMembershipMaxOrderByAggregateInput
    _min?: RunCrewMembershipMinOrderByAggregateInput
  }

  export type RunCrewMembershipScalarWhereWithAggregatesInput = {
    AND?: RunCrewMembershipScalarWhereWithAggregatesInput | RunCrewMembershipScalarWhereWithAggregatesInput[]
    OR?: RunCrewMembershipScalarWhereWithAggregatesInput[]
    NOT?: RunCrewMembershipScalarWhereWithAggregatesInput | RunCrewMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewMembership"> | Date | string
  }

  export type RunCrewMessageWhereInput = {
    AND?: RunCrewMessageWhereInput | RunCrewMessageWhereInput[]
    OR?: RunCrewMessageWhereInput[]
    NOT?: RunCrewMessageWhereInput | RunCrewMessageWhereInput[]
    id?: StringFilter<"RunCrewMessage"> | string
    runCrewId?: StringFilter<"RunCrewMessage"> | string
    athleteId?: StringFilter<"RunCrewMessage"> | string
    content?: StringFilter<"RunCrewMessage"> | string
    createdAt?: DateTimeFilter<"RunCrewMessage"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewMessageOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewMessageWhereInput | RunCrewMessageWhereInput[]
    OR?: RunCrewMessageWhereInput[]
    NOT?: RunCrewMessageWhereInput | RunCrewMessageWhereInput[]
    runCrewId?: StringFilter<"RunCrewMessage"> | string
    athleteId?: StringFilter<"RunCrewMessage"> | string
    content?: StringFilter<"RunCrewMessage"> | string
    createdAt?: DateTimeFilter<"RunCrewMessage"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id">

  export type RunCrewMessageOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: RunCrewMessageCountOrderByAggregateInput
    _max?: RunCrewMessageMaxOrderByAggregateInput
    _min?: RunCrewMessageMinOrderByAggregateInput
  }

  export type RunCrewMessageScalarWhereWithAggregatesInput = {
    AND?: RunCrewMessageScalarWhereWithAggregatesInput | RunCrewMessageScalarWhereWithAggregatesInput[]
    OR?: RunCrewMessageScalarWhereWithAggregatesInput[]
    NOT?: RunCrewMessageScalarWhereWithAggregatesInput | RunCrewMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewMessage"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewMessage"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewMessage"> | string
    content?: StringWithAggregatesFilter<"RunCrewMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewMessage"> | Date | string
  }

  export type RunCrewAnnouncementWhereInput = {
    AND?: RunCrewAnnouncementWhereInput | RunCrewAnnouncementWhereInput[]
    OR?: RunCrewAnnouncementWhereInput[]
    NOT?: RunCrewAnnouncementWhereInput | RunCrewAnnouncementWhereInput[]
    id?: StringFilter<"RunCrewAnnouncement"> | string
    runCrewId?: StringFilter<"RunCrewAnnouncement"> | string
    authorId?: StringFilter<"RunCrewAnnouncement"> | string
    title?: StringFilter<"RunCrewAnnouncement"> | string
    content?: StringFilter<"RunCrewAnnouncement"> | string
    createdAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    author?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewAnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    author?: AthleteOrderByWithRelationInput
  }

  export type RunCrewAnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewAnnouncementWhereInput | RunCrewAnnouncementWhereInput[]
    OR?: RunCrewAnnouncementWhereInput[]
    NOT?: RunCrewAnnouncementWhereInput | RunCrewAnnouncementWhereInput[]
    runCrewId?: StringFilter<"RunCrewAnnouncement"> | string
    authorId?: StringFilter<"RunCrewAnnouncement"> | string
    title?: StringFilter<"RunCrewAnnouncement"> | string
    content?: StringFilter<"RunCrewAnnouncement"> | string
    createdAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    author?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id">

  export type RunCrewAnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewAnnouncementCountOrderByAggregateInput
    _max?: RunCrewAnnouncementMaxOrderByAggregateInput
    _min?: RunCrewAnnouncementMinOrderByAggregateInput
  }

  export type RunCrewAnnouncementScalarWhereWithAggregatesInput = {
    AND?: RunCrewAnnouncementScalarWhereWithAggregatesInput | RunCrewAnnouncementScalarWhereWithAggregatesInput[]
    OR?: RunCrewAnnouncementScalarWhereWithAggregatesInput[]
    NOT?: RunCrewAnnouncementScalarWhereWithAggregatesInput | RunCrewAnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewAnnouncement"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewAnnouncement"> | string
    authorId?: StringWithAggregatesFilter<"RunCrewAnnouncement"> | string
    title?: StringWithAggregatesFilter<"RunCrewAnnouncement"> | string
    content?: StringWithAggregatesFilter<"RunCrewAnnouncement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewAnnouncement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewAnnouncement"> | Date | string
  }

  export type RunCrewLeaderboardWhereInput = {
    AND?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    OR?: RunCrewLeaderboardWhereInput[]
    NOT?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    id?: StringFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runCrewId_athleteId_period_periodStart?: RunCrewLeaderboardRunCrewIdAthleteIdPeriodPeriodStartCompoundUniqueInput
    AND?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    OR?: RunCrewLeaderboardWhereInput[]
    NOT?: RunCrewLeaderboardWhereInput | RunCrewLeaderboardWhereInput[]
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runCrewId_athleteId_period_periodStart">

  export type RunCrewLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewLeaderboardCountOrderByAggregateInput
    _avg?: RunCrewLeaderboardAvgOrderByAggregateInput
    _max?: RunCrewLeaderboardMaxOrderByAggregateInput
    _min?: RunCrewLeaderboardMinOrderByAggregateInput
    _sum?: RunCrewLeaderboardSumOrderByAggregateInput
  }

  export type RunCrewLeaderboardScalarWhereWithAggregatesInput = {
    AND?: RunCrewLeaderboardScalarWhereWithAggregatesInput | RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    OR?: RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: RunCrewLeaderboardScalarWhereWithAggregatesInput | RunCrewLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    period?: StringWithAggregatesFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatWithAggregatesFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntWithAggregatesFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableWithAggregatesFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntWithAggregatesFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatWithAggregatesFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewLeaderboard"> | Date | string
  }

  export type RunCrewRunWhereInput = {
    AND?: RunCrewRunWhereInput | RunCrewRunWhereInput[]
    OR?: RunCrewRunWhereInput[]
    NOT?: RunCrewRunWhereInput | RunCrewRunWhereInput[]
    id?: StringFilter<"RunCrewRun"> | string
    runCrewId?: StringFilter<"RunCrewRun"> | string
    createdById?: StringFilter<"RunCrewRun"> | string
    title?: StringFilter<"RunCrewRun"> | string
    date?: DateTimeFilter<"RunCrewRun"> | Date | string
    startTime?: StringFilter<"RunCrewRun"> | string
    location?: StringFilter<"RunCrewRun"> | string
    address?: StringNullableFilter<"RunCrewRun"> | string | null
    totalMiles?: FloatNullableFilter<"RunCrewRun"> | number | null
    pace?: StringNullableFilter<"RunCrewRun"> | string | null
    stravaMapUrl?: StringNullableFilter<"RunCrewRun"> | string | null
    description?: StringNullableFilter<"RunCrewRun"> | string | null
    createdAt?: DateTimeFilter<"RunCrewRun"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewRun"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    createdBy?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    rsvps?: RunCrewRunRSVPListRelationFilter
  }

  export type RunCrewRunOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    location?: SortOrder
    address?: SortOrderInput | SortOrder
    totalMiles?: SortOrderInput | SortOrder
    pace?: SortOrderInput | SortOrder
    stravaMapUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    createdBy?: AthleteOrderByWithRelationInput
    rsvps?: RunCrewRunRSVPOrderByRelationAggregateInput
  }

  export type RunCrewRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewRunWhereInput | RunCrewRunWhereInput[]
    OR?: RunCrewRunWhereInput[]
    NOT?: RunCrewRunWhereInput | RunCrewRunWhereInput[]
    runCrewId?: StringFilter<"RunCrewRun"> | string
    createdById?: StringFilter<"RunCrewRun"> | string
    title?: StringFilter<"RunCrewRun"> | string
    date?: DateTimeFilter<"RunCrewRun"> | Date | string
    startTime?: StringFilter<"RunCrewRun"> | string
    location?: StringFilter<"RunCrewRun"> | string
    address?: StringNullableFilter<"RunCrewRun"> | string | null
    totalMiles?: FloatNullableFilter<"RunCrewRun"> | number | null
    pace?: StringNullableFilter<"RunCrewRun"> | string | null
    stravaMapUrl?: StringNullableFilter<"RunCrewRun"> | string | null
    description?: StringNullableFilter<"RunCrewRun"> | string | null
    createdAt?: DateTimeFilter<"RunCrewRun"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewRun"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    createdBy?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    rsvps?: RunCrewRunRSVPListRelationFilter
  }, "id">

  export type RunCrewRunOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    location?: SortOrder
    address?: SortOrderInput | SortOrder
    totalMiles?: SortOrderInput | SortOrder
    pace?: SortOrderInput | SortOrder
    stravaMapUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewRunCountOrderByAggregateInput
    _avg?: RunCrewRunAvgOrderByAggregateInput
    _max?: RunCrewRunMaxOrderByAggregateInput
    _min?: RunCrewRunMinOrderByAggregateInput
    _sum?: RunCrewRunSumOrderByAggregateInput
  }

  export type RunCrewRunScalarWhereWithAggregatesInput = {
    AND?: RunCrewRunScalarWhereWithAggregatesInput | RunCrewRunScalarWhereWithAggregatesInput[]
    OR?: RunCrewRunScalarWhereWithAggregatesInput[]
    NOT?: RunCrewRunScalarWhereWithAggregatesInput | RunCrewRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewRun"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewRun"> | string
    createdById?: StringWithAggregatesFilter<"RunCrewRun"> | string
    title?: StringWithAggregatesFilter<"RunCrewRun"> | string
    date?: DateTimeWithAggregatesFilter<"RunCrewRun"> | Date | string
    startTime?: StringWithAggregatesFilter<"RunCrewRun"> | string
    location?: StringWithAggregatesFilter<"RunCrewRun"> | string
    address?: StringNullableWithAggregatesFilter<"RunCrewRun"> | string | null
    totalMiles?: FloatNullableWithAggregatesFilter<"RunCrewRun"> | number | null
    pace?: StringNullableWithAggregatesFilter<"RunCrewRun"> | string | null
    stravaMapUrl?: StringNullableWithAggregatesFilter<"RunCrewRun"> | string | null
    description?: StringNullableWithAggregatesFilter<"RunCrewRun"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewRun"> | Date | string
  }

  export type RunCrewRunRSVPWhereInput = {
    AND?: RunCrewRunRSVPWhereInput | RunCrewRunRSVPWhereInput[]
    OR?: RunCrewRunRSVPWhereInput[]
    NOT?: RunCrewRunRSVPWhereInput | RunCrewRunRSVPWhereInput[]
    id?: StringFilter<"RunCrewRunRSVP"> | string
    runId?: StringFilter<"RunCrewRunRSVP"> | string
    athleteId?: StringFilter<"RunCrewRunRSVP"> | string
    status?: StringFilter<"RunCrewRunRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewRunRSVP"> | Date | string
    run?: XOR<RunCrewRunScalarRelationFilter, RunCrewRunWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewRunRSVPOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    run?: RunCrewRunOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewRunRSVPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runId_athleteId?: RunCrewRunRSVPRunIdAthleteIdCompoundUniqueInput
    AND?: RunCrewRunRSVPWhereInput | RunCrewRunRSVPWhereInput[]
    OR?: RunCrewRunRSVPWhereInput[]
    NOT?: RunCrewRunRSVPWhereInput | RunCrewRunRSVPWhereInput[]
    runId?: StringFilter<"RunCrewRunRSVP"> | string
    athleteId?: StringFilter<"RunCrewRunRSVP"> | string
    status?: StringFilter<"RunCrewRunRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewRunRSVP"> | Date | string
    run?: XOR<RunCrewRunScalarRelationFilter, RunCrewRunWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runId_athleteId">

  export type RunCrewRunRSVPOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: RunCrewRunRSVPCountOrderByAggregateInput
    _max?: RunCrewRunRSVPMaxOrderByAggregateInput
    _min?: RunCrewRunRSVPMinOrderByAggregateInput
  }

  export type RunCrewRunRSVPScalarWhereWithAggregatesInput = {
    AND?: RunCrewRunRSVPScalarWhereWithAggregatesInput | RunCrewRunRSVPScalarWhereWithAggregatesInput[]
    OR?: RunCrewRunRSVPScalarWhereWithAggregatesInput[]
    NOT?: RunCrewRunRSVPScalarWhereWithAggregatesInput | RunCrewRunRSVPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewRunRSVP"> | string
    runId?: StringWithAggregatesFilter<"RunCrewRunRSVP"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewRunRSVP"> | string
    status?: StringWithAggregatesFilter<"RunCrewRunRSVP"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewRunRSVP"> | Date | string
  }

  export type RunCrewEventWhereInput = {
    AND?: RunCrewEventWhereInput | RunCrewEventWhereInput[]
    OR?: RunCrewEventWhereInput[]
    NOT?: RunCrewEventWhereInput | RunCrewEventWhereInput[]
    id?: StringFilter<"RunCrewEvent"> | string
    runCrewId?: StringFilter<"RunCrewEvent"> | string
    organizerId?: StringFilter<"RunCrewEvent"> | string
    title?: StringFilter<"RunCrewEvent"> | string
    date?: DateTimeFilter<"RunCrewEvent"> | Date | string
    time?: StringFilter<"RunCrewEvent"> | string
    location?: StringFilter<"RunCrewEvent"> | string
    address?: StringNullableFilter<"RunCrewEvent"> | string | null
    description?: StringNullableFilter<"RunCrewEvent"> | string | null
    eventType?: StringNullableFilter<"RunCrewEvent"> | string | null
    createdAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    organizer?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    rsvps?: RunCrewEventRSVPListRelationFilter
  }

  export type RunCrewEventOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    organizerId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    eventType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    organizer?: AthleteOrderByWithRelationInput
    rsvps?: RunCrewEventRSVPOrderByRelationAggregateInput
  }

  export type RunCrewEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunCrewEventWhereInput | RunCrewEventWhereInput[]
    OR?: RunCrewEventWhereInput[]
    NOT?: RunCrewEventWhereInput | RunCrewEventWhereInput[]
    runCrewId?: StringFilter<"RunCrewEvent"> | string
    organizerId?: StringFilter<"RunCrewEvent"> | string
    title?: StringFilter<"RunCrewEvent"> | string
    date?: DateTimeFilter<"RunCrewEvent"> | Date | string
    time?: StringFilter<"RunCrewEvent"> | string
    location?: StringFilter<"RunCrewEvent"> | string
    address?: StringNullableFilter<"RunCrewEvent"> | string | null
    description?: StringNullableFilter<"RunCrewEvent"> | string | null
    eventType?: StringNullableFilter<"RunCrewEvent"> | string | null
    createdAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    organizer?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    rsvps?: RunCrewEventRSVPListRelationFilter
  }, "id">

  export type RunCrewEventOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    organizerId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    eventType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RunCrewEventCountOrderByAggregateInput
    _max?: RunCrewEventMaxOrderByAggregateInput
    _min?: RunCrewEventMinOrderByAggregateInput
  }

  export type RunCrewEventScalarWhereWithAggregatesInput = {
    AND?: RunCrewEventScalarWhereWithAggregatesInput | RunCrewEventScalarWhereWithAggregatesInput[]
    OR?: RunCrewEventScalarWhereWithAggregatesInput[]
    NOT?: RunCrewEventScalarWhereWithAggregatesInput | RunCrewEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    organizerId?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    title?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    date?: DateTimeWithAggregatesFilter<"RunCrewEvent"> | Date | string
    time?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    location?: StringWithAggregatesFilter<"RunCrewEvent"> | string
    address?: StringNullableWithAggregatesFilter<"RunCrewEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"RunCrewEvent"> | string | null
    eventType?: StringNullableWithAggregatesFilter<"RunCrewEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RunCrewEvent"> | Date | string
  }

  export type RunCrewEventRSVPWhereInput = {
    AND?: RunCrewEventRSVPWhereInput | RunCrewEventRSVPWhereInput[]
    OR?: RunCrewEventRSVPWhereInput[]
    NOT?: RunCrewEventRSVPWhereInput | RunCrewEventRSVPWhereInput[]
    id?: StringFilter<"RunCrewEventRSVP"> | string
    eventId?: StringFilter<"RunCrewEventRSVP"> | string
    athleteId?: StringFilter<"RunCrewEventRSVP"> | string
    status?: StringFilter<"RunCrewEventRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewEventRSVP"> | Date | string
    event?: XOR<RunCrewEventScalarRelationFilter, RunCrewEventWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewEventRSVPOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    event?: RunCrewEventOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewEventRSVPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_athleteId?: RunCrewEventRSVPEventIdAthleteIdCompoundUniqueInput
    AND?: RunCrewEventRSVPWhereInput | RunCrewEventRSVPWhereInput[]
    OR?: RunCrewEventRSVPWhereInput[]
    NOT?: RunCrewEventRSVPWhereInput | RunCrewEventRSVPWhereInput[]
    eventId?: StringFilter<"RunCrewEventRSVP"> | string
    athleteId?: StringFilter<"RunCrewEventRSVP"> | string
    status?: StringFilter<"RunCrewEventRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewEventRSVP"> | Date | string
    event?: XOR<RunCrewEventScalarRelationFilter, RunCrewEventWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "eventId_athleteId">

  export type RunCrewEventRSVPOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: RunCrewEventRSVPCountOrderByAggregateInput
    _max?: RunCrewEventRSVPMaxOrderByAggregateInput
    _min?: RunCrewEventRSVPMinOrderByAggregateInput
  }

  export type RunCrewEventRSVPScalarWhereWithAggregatesInput = {
    AND?: RunCrewEventRSVPScalarWhereWithAggregatesInput | RunCrewEventRSVPScalarWhereWithAggregatesInput[]
    OR?: RunCrewEventRSVPScalarWhereWithAggregatesInput[]
    NOT?: RunCrewEventRSVPScalarWhereWithAggregatesInput | RunCrewEventRSVPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewEventRSVP"> | string
    eventId?: StringWithAggregatesFilter<"RunCrewEventRSVP"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewEventRSVP"> | string
    status?: StringWithAggregatesFilter<"RunCrewEventRSVP"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewEventRSVP"> | Date | string
  }

  export type RunCrewManagerWhereInput = {
    AND?: RunCrewManagerWhereInput | RunCrewManagerWhereInput[]
    OR?: RunCrewManagerWhereInput[]
    NOT?: RunCrewManagerWhereInput | RunCrewManagerWhereInput[]
    id?: StringFilter<"RunCrewManager"> | string
    runCrewId?: StringFilter<"RunCrewManager"> | string
    athleteId?: StringFilter<"RunCrewManager"> | string
    role?: StringFilter<"RunCrewManager"> | string
    createdAt?: DateTimeFilter<"RunCrewManager"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type RunCrewManagerOrderByWithRelationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    runCrew?: RunCrewOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type RunCrewManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runCrewId_athleteId?: RunCrewManagerRunCrewIdAthleteIdCompoundUniqueInput
    AND?: RunCrewManagerWhereInput | RunCrewManagerWhereInput[]
    OR?: RunCrewManagerWhereInput[]
    NOT?: RunCrewManagerWhereInput | RunCrewManagerWhereInput[]
    runCrewId?: StringFilter<"RunCrewManager"> | string
    athleteId?: StringFilter<"RunCrewManager"> | string
    role?: StringFilter<"RunCrewManager"> | string
    createdAt?: DateTimeFilter<"RunCrewManager"> | Date | string
    runCrew?: XOR<RunCrewScalarRelationFilter, RunCrewWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "runCrewId_athleteId">

  export type RunCrewManagerOrderByWithAggregationInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: RunCrewManagerCountOrderByAggregateInput
    _max?: RunCrewManagerMaxOrderByAggregateInput
    _min?: RunCrewManagerMinOrderByAggregateInput
  }

  export type RunCrewManagerScalarWhereWithAggregatesInput = {
    AND?: RunCrewManagerScalarWhereWithAggregatesInput | RunCrewManagerScalarWhereWithAggregatesInput[]
    OR?: RunCrewManagerScalarWhereWithAggregatesInput[]
    NOT?: RunCrewManagerScalarWhereWithAggregatesInput | RunCrewManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCrewManager"> | string
    runCrewId?: StringWithAggregatesFilter<"RunCrewManager"> | string
    athleteId?: StringWithAggregatesFilter<"RunCrewManager"> | string
    role?: StringWithAggregatesFilter<"RunCrewManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RunCrewManager"> | Date | string
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: StringFilter<"Race"> | string
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    createdByAthlete?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    trainingPlans?: TrainingPlanListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrderInput | SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    courseProfile?: SortOrderInput | SortOrder
    createdByAthleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByAthlete?: AthleteOrderByWithRelationInput
    trainingPlans?: TrainingPlanOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    createdByAthlete?: XOR<AthleteNullableScalarRelationFilter, AthleteWhereInput> | null
    trainingPlans?: TrainingPlanListRelationFilter
  }, "id">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrderInput | SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    courseProfile?: SortOrderInput | SortOrder
    createdByAthleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Race"> | string
    raceName?: StringWithAggregatesFilter<"Race"> | string
    raceType?: StringWithAggregatesFilter<"Race"> | string
    raceDate?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Race"> | string | null
    distanceMiles?: FloatWithAggregatesFilter<"Race"> | number
    registrationUrl?: StringNullableWithAggregatesFilter<"Race"> | string | null
    description?: StringNullableWithAggregatesFilter<"Race"> | string | null
    courseProfile?: JsonNullableWithAggregatesFilter<"Race">
    createdByAthleteId?: StringNullableWithAggregatesFilter<"Race"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
  }

  export type TrainingPlanWhereInput = {
    AND?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    OR?: TrainingPlanWhereInput[]
    NOT?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    id?: StringFilter<"TrainingPlan"> | string
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    plannedDays?: TrainingDayPlannedListRelationFilter
    executions?: TrainingPlanExecutionListRelationFilter
  }

  export type TrainingPlanOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrderInput | SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrderInput | SortOrder
    weeklyMileagePlan?: SortOrderInput | SortOrder
    weeks?: SortOrderInput | SortOrder
    adaptive5kTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
    race?: RaceOrderByWithRelationInput
    plannedDays?: TrainingDayPlannedOrderByRelationAggregateInput
    executions?: TrainingPlanExecutionOrderByRelationAggregateInput
  }

  export type TrainingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    OR?: TrainingPlanWhereInput[]
    NOT?: TrainingPlanWhereInput | TrainingPlanWhereInput[]
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    plannedDays?: TrainingDayPlannedListRelationFilter
    executions?: TrainingPlanExecutionListRelationFilter
  }, "id">

  export type TrainingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrderInput | SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrderInput | SortOrder
    weeklyMileagePlan?: SortOrderInput | SortOrder
    weeks?: SortOrderInput | SortOrder
    adaptive5kTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingPlanCountOrderByAggregateInput
    _avg?: TrainingPlanAvgOrderByAggregateInput
    _max?: TrainingPlanMaxOrderByAggregateInput
    _min?: TrainingPlanMinOrderByAggregateInput
    _sum?: TrainingPlanSumOrderByAggregateInput
  }

  export type TrainingPlanScalarWhereWithAggregatesInput = {
    AND?: TrainingPlanScalarWhereWithAggregatesInput | TrainingPlanScalarWhereWithAggregatesInput[]
    OR?: TrainingPlanScalarWhereWithAggregatesInput[]
    NOT?: TrainingPlanScalarWhereWithAggregatesInput | TrainingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPlan"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingPlan"> | string
    raceId?: StringWithAggregatesFilter<"TrainingPlan"> | string
    goalTime?: StringWithAggregatesFilter<"TrainingPlan"> | string
    goalPace?: StringNullableWithAggregatesFilter<"TrainingPlan"> | string | null
    baseline5k?: StringWithAggregatesFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableWithAggregatesFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntWithAggregatesFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    weeks?: JsonNullableWithAggregatesFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableWithAggregatesFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingPlan"> | Date | string
  }

  export type TrainingDayPlannedWhereInput = {
    AND?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    OR?: TrainingDayPlannedWhereInput[]
    NOT?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    id?: StringFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type TrainingDayPlannedOrderByWithRelationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrderInput | SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingPlan?: TrainingPlanOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type TrainingDayPlannedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingPlanId_weekIndex_dayIndex?: TrainingDayPlannedTrainingPlanIdWeekIndexDayIndexCompoundUniqueInput
    AND?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    OR?: TrainingDayPlannedWhereInput[]
    NOT?: TrainingDayPlannedWhereInput | TrainingDayPlannedWhereInput[]
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "trainingPlanId_weekIndex_dayIndex">

  export type TrainingDayPlannedOrderByWithAggregationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrderInput | SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDayPlannedCountOrderByAggregateInput
    _avg?: TrainingDayPlannedAvgOrderByAggregateInput
    _max?: TrainingDayPlannedMaxOrderByAggregateInput
    _min?: TrainingDayPlannedMinOrderByAggregateInput
    _sum?: TrainingDayPlannedSumOrderByAggregateInput
  }

  export type TrainingDayPlannedScalarWhereWithAggregatesInput = {
    AND?: TrainingDayPlannedScalarWhereWithAggregatesInput | TrainingDayPlannedScalarWhereWithAggregatesInput[]
    OR?: TrainingDayPlannedScalarWhereWithAggregatesInput[]
    NOT?: TrainingDayPlannedScalarWhereWithAggregatesInput | TrainingDayPlannedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    date?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntWithAggregatesFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntWithAggregatesFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableWithAggregatesFilter<"TrainingDayPlanned"> | string | null
    phase?: StringWithAggregatesFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonWithAggregatesFilter<"TrainingDayPlanned">
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDayPlanned"> | Date | string
  }

  export type TrainingPlanExecutionWhereInput = {
    AND?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    OR?: TrainingPlanExecutionWhereInput[]
    NOT?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    id?: StringFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    executedDays?: TrainingDayExecutedListRelationFilter
  }

  export type TrainingPlanExecutionOrderByWithRelationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingPlan?: TrainingPlanOrderByWithRelationInput
    executedDays?: TrainingDayExecutedOrderByRelationAggregateInput
  }

  export type TrainingPlanExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    OR?: TrainingPlanExecutionWhereInput[]
    NOT?: TrainingPlanExecutionWhereInput | TrainingPlanExecutionWhereInput[]
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    trainingPlan?: XOR<TrainingPlanScalarRelationFilter, TrainingPlanWhereInput>
    executedDays?: TrainingDayExecutedListRelationFilter
  }, "id">

  export type TrainingPlanExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingPlanExecutionCountOrderByAggregateInput
    _max?: TrainingPlanExecutionMaxOrderByAggregateInput
    _min?: TrainingPlanExecutionMinOrderByAggregateInput
  }

  export type TrainingPlanExecutionScalarWhereWithAggregatesInput = {
    AND?: TrainingPlanExecutionScalarWhereWithAggregatesInput | TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    OR?: TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    NOT?: TrainingPlanExecutionScalarWhereWithAggregatesInput | TrainingPlanExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
    status?: StringWithAggregatesFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingPlanExecution"> | Date | string
  }

  export type TrainingDayExecutedWhereInput = {
    AND?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    OR?: TrainingDayExecutedWhereInput[]
    NOT?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    id?: StringFilter<"TrainingDayExecuted"> | string
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    execution?: XOR<TrainingPlanExecutionScalarRelationFilter, TrainingPlanExecutionWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }

  export type TrainingDayExecutedOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    execution?: TrainingPlanExecutionOrderByWithRelationInput
    athlete?: AthleteOrderByWithRelationInput
  }

  export type TrainingDayExecutedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    activityId?: string
    executionId_date?: TrainingDayExecutedExecutionIdDateCompoundUniqueInput
    AND?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    OR?: TrainingDayExecutedWhereInput[]
    NOT?: TrainingDayExecutedWhereInput | TrainingDayExecutedWhereInput[]
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    execution?: XOR<TrainingPlanExecutionScalarRelationFilter, TrainingPlanExecutionWhereInput>
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
  }, "id" | "activityId" | "executionId_date">

  export type TrainingDayExecutedOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDayExecutedCountOrderByAggregateInput
    _avg?: TrainingDayExecutedAvgOrderByAggregateInput
    _max?: TrainingDayExecutedMaxOrderByAggregateInput
    _min?: TrainingDayExecutedMinOrderByAggregateInput
    _sum?: TrainingDayExecutedSumOrderByAggregateInput
  }

  export type TrainingDayExecutedScalarWhereWithAggregatesInput = {
    AND?: TrainingDayExecutedScalarWhereWithAggregatesInput | TrainingDayExecutedScalarWhereWithAggregatesInput[]
    OR?: TrainingDayExecutedScalarWhereWithAggregatesInput[]
    NOT?: TrainingDayExecutedScalarWhereWithAggregatesInput | TrainingDayExecutedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    executionId?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    athleteId?: StringWithAggregatesFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableWithAggregatesFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntWithAggregatesFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntWithAggregatesFilter<"TrainingDayExecuted"> | number
    date?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    analysis?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    feedback?: JsonNullableWithAggregatesFilter<"TrainingDayExecuted">
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDayExecuted"> | Date | string
  }

  export type FounderWhereInput = {
    AND?: FounderWhereInput | FounderWhereInput[]
    OR?: FounderWhereInput[]
    NOT?: FounderWhereInput | FounderWhereInput[]
    id?: StringFilter<"Founder"> | string
    athleteId?: StringFilter<"Founder"> | string
    createdAt?: DateTimeFilter<"Founder"> | Date | string
    updatedAt?: DateTimeFilter<"Founder"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    tasks?: FounderTaskListRelationFilter
    crmContacts?: CrmContactListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
    companyFounders?: CompanyFounderListRelationFilter
    unifiedTasks?: TaskListRelationFilter
  }

  export type FounderOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    athlete?: AthleteOrderByWithRelationInput
    tasks?: FounderTaskOrderByRelationAggregateInput
    crmContacts?: CrmContactOrderByRelationAggregateInput
    roadmapItems?: RoadmapItemOrderByRelationAggregateInput
    companyFounders?: CompanyFounderOrderByRelationAggregateInput
    unifiedTasks?: TaskOrderByRelationAggregateInput
  }

  export type FounderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    athleteId?: string
    AND?: FounderWhereInput | FounderWhereInput[]
    OR?: FounderWhereInput[]
    NOT?: FounderWhereInput | FounderWhereInput[]
    createdAt?: DateTimeFilter<"Founder"> | Date | string
    updatedAt?: DateTimeFilter<"Founder"> | Date | string
    athlete?: XOR<AthleteScalarRelationFilter, AthleteWhereInput>
    tasks?: FounderTaskListRelationFilter
    crmContacts?: CrmContactListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
    companyFounders?: CompanyFounderListRelationFilter
    unifiedTasks?: TaskListRelationFilter
  }, "id" | "athleteId">

  export type FounderOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FounderCountOrderByAggregateInput
    _max?: FounderMaxOrderByAggregateInput
    _min?: FounderMinOrderByAggregateInput
  }

  export type FounderScalarWhereWithAggregatesInput = {
    AND?: FounderScalarWhereWithAggregatesInput | FounderScalarWhereWithAggregatesInput[]
    OR?: FounderScalarWhereWithAggregatesInput[]
    NOT?: FounderScalarWhereWithAggregatesInput | FounderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Founder"> | string
    athleteId?: StringWithAggregatesFilter<"Founder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Founder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Founder"> | Date | string
  }

  export type FounderTaskWhereInput = {
    AND?: FounderTaskWhereInput | FounderTaskWhereInput[]
    OR?: FounderTaskWhereInput[]
    NOT?: FounderTaskWhereInput | FounderTaskWhereInput[]
    id?: StringFilter<"FounderTask"> | string
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type FounderTaskOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type FounderTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FounderTaskWhereInput | FounderTaskWhereInput[]
    OR?: FounderTaskWhereInput[]
    NOT?: FounderTaskWhereInput | FounderTaskWhereInput[]
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type FounderTaskOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FounderTaskCountOrderByAggregateInput
    _max?: FounderTaskMaxOrderByAggregateInput
    _min?: FounderTaskMinOrderByAggregateInput
  }

  export type FounderTaskScalarWhereWithAggregatesInput = {
    AND?: FounderTaskScalarWhereWithAggregatesInput | FounderTaskScalarWhereWithAggregatesInput[]
    OR?: FounderTaskScalarWhereWithAggregatesInput[]
    NOT?: FounderTaskScalarWhereWithAggregatesInput | FounderTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FounderTask"> | string
    founderId?: StringWithAggregatesFilter<"FounderTask"> | string
    title?: StringWithAggregatesFilter<"FounderTask"> | string
    description?: StringNullableWithAggregatesFilter<"FounderTask"> | string | null
    status?: StringWithAggregatesFilter<"FounderTask"> | string
    priority?: StringWithAggregatesFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FounderTask"> | Date | string
  }

  export type CrmContactWhereInput = {
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    id?: StringFilter<"CrmContact"> | string
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type CrmContactOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type CrmContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type CrmContactOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrmContactCountOrderByAggregateInput
    _max?: CrmContactMaxOrderByAggregateInput
    _min?: CrmContactMinOrderByAggregateInput
  }

  export type CrmContactScalarWhereWithAggregatesInput = {
    AND?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    OR?: CrmContactScalarWhereWithAggregatesInput[]
    NOT?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmContact"> | string
    founderId?: StringWithAggregatesFilter<"CrmContact"> | string
    name?: StringWithAggregatesFilter<"CrmContact"> | string
    role?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    company?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    pipeline?: StringWithAggregatesFilter<"CrmContact"> | string
    status?: StringWithAggregatesFilter<"CrmContact"> | string
    nextStep?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
  }

  export type RoadmapItemWhereInput = {
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type RoadmapItemOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founder?: FounderOrderByWithRelationInput
  }

  export type RoadmapItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id">

  export type RoadmapItemOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapItemCountOrderByAggregateInput
    _max?: RoadmapItemMaxOrderByAggregateInput
    _min?: RoadmapItemMinOrderByAggregateInput
  }

  export type RoadmapItemScalarWhereWithAggregatesInput = {
    AND?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    OR?: RoadmapItemScalarWhereWithAggregatesInput[]
    NOT?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapItem"> | string
    founderId?: StringWithAggregatesFilter<"RoadmapItem"> | string
    roadmapType?: StringWithAggregatesFilter<"RoadmapItem"> | string
    quarter?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    title?: StringWithAggregatesFilter<"RoadmapItem"> | string
    description?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    status?: StringWithAggregatesFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    founders?: CompanyFounderListRelationFilter
    employees?: CompanyEmployeeListRelationFilter
    roadmapItems?: CompanyRoadmapItemListRelationFilter
    tasks?: TaskListRelationFilter
    crmContacts?: CompanyCrmContactListRelationFilter
    financialSpends?: CompanyFinancialSpendListRelationFilter
    financialProjections?: CompanyFinancialProjectionListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founders?: CompanyFounderOrderByRelationAggregateInput
    employees?: CompanyEmployeeOrderByRelationAggregateInput
    roadmapItems?: CompanyRoadmapItemOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    crmContacts?: CompanyCrmContactOrderByRelationAggregateInput
    financialSpends?: CompanyFinancialSpendOrderByRelationAggregateInput
    financialProjections?: CompanyFinancialProjectionOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    founders?: CompanyFounderListRelationFilter
    employees?: CompanyEmployeeListRelationFilter
    roadmapItems?: CompanyRoadmapItemListRelationFilter
    tasks?: TaskListRelationFilter
    crmContacts?: CompanyCrmContactListRelationFilter
    financialSpends?: CompanyFinancialSpendListRelationFilter
    financialProjections?: CompanyFinancialProjectionListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CompanyFounderWhereInput = {
    AND?: CompanyFounderWhereInput | CompanyFounderWhereInput[]
    OR?: CompanyFounderWhereInput[]
    NOT?: CompanyFounderWhereInput | CompanyFounderWhereInput[]
    id?: StringFilter<"CompanyFounder"> | string
    companyId?: StringFilter<"CompanyFounder"> | string
    founderId?: StringFilter<"CompanyFounder"> | string
    role?: StringNullableFilter<"CompanyFounder"> | string | null
    joinedAt?: DateTimeFilter<"CompanyFounder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }

  export type CompanyFounderOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    founderId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    founder?: FounderOrderByWithRelationInput
  }

  export type CompanyFounderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_founderId?: CompanyFounderCompanyIdFounderIdCompoundUniqueInput
    AND?: CompanyFounderWhereInput | CompanyFounderWhereInput[]
    OR?: CompanyFounderWhereInput[]
    NOT?: CompanyFounderWhereInput | CompanyFounderWhereInput[]
    companyId?: StringFilter<"CompanyFounder"> | string
    founderId?: StringFilter<"CompanyFounder"> | string
    role?: StringNullableFilter<"CompanyFounder"> | string | null
    joinedAt?: DateTimeFilter<"CompanyFounder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    founder?: XOR<FounderScalarRelationFilter, FounderWhereInput>
  }, "id" | "companyId_founderId">

  export type CompanyFounderOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    founderId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: CompanyFounderCountOrderByAggregateInput
    _max?: CompanyFounderMaxOrderByAggregateInput
    _min?: CompanyFounderMinOrderByAggregateInput
  }

  export type CompanyFounderScalarWhereWithAggregatesInput = {
    AND?: CompanyFounderScalarWhereWithAggregatesInput | CompanyFounderScalarWhereWithAggregatesInput[]
    OR?: CompanyFounderScalarWhereWithAggregatesInput[]
    NOT?: CompanyFounderScalarWhereWithAggregatesInput | CompanyFounderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyFounder"> | string
    companyId?: StringWithAggregatesFilter<"CompanyFounder"> | string
    founderId?: StringWithAggregatesFilter<"CompanyFounder"> | string
    role?: StringNullableWithAggregatesFilter<"CompanyFounder"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"CompanyFounder"> | Date | string
  }

  export type CompanyEmployeeWhereInput = {
    AND?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    OR?: CompanyEmployeeWhereInput[]
    NOT?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    id?: StringFilter<"CompanyEmployee"> | string
    companyId?: StringFilter<"CompanyEmployee"> | string
    email?: StringFilter<"CompanyEmployee"> | string
    name?: StringFilter<"CompanyEmployee"> | string
    role?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    phoneNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    joinedAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CompanyEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_email?: CompanyEmployeeCompanyIdEmailCompoundUniqueInput
    AND?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    OR?: CompanyEmployeeWhereInput[]
    NOT?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    companyId?: StringFilter<"CompanyEmployee"> | string
    email?: StringFilter<"CompanyEmployee"> | string
    name?: StringFilter<"CompanyEmployee"> | string
    role?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    phoneNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    joinedAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_email">

  export type CompanyEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: CompanyEmployeeCountOrderByAggregateInput
    _max?: CompanyEmployeeMaxOrderByAggregateInput
    _min?: CompanyEmployeeMinOrderByAggregateInput
  }

  export type CompanyEmployeeScalarWhereWithAggregatesInput = {
    AND?: CompanyEmployeeScalarWhereWithAggregatesInput | CompanyEmployeeScalarWhereWithAggregatesInput[]
    OR?: CompanyEmployeeScalarWhereWithAggregatesInput[]
    NOT?: CompanyEmployeeScalarWhereWithAggregatesInput | CompanyEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    companyId?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    email?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    name?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    role?: StringNullableWithAggregatesFilter<"CompanyEmployee"> | string | null
    department?: StringNullableWithAggregatesFilter<"CompanyEmployee"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"CompanyEmployee"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"CompanyEmployee"> | Date | string
  }

  export type CompanyRoadmapItemWhereInput = {
    AND?: CompanyRoadmapItemWhereInput | CompanyRoadmapItemWhereInput[]
    OR?: CompanyRoadmapItemWhereInput[]
    NOT?: CompanyRoadmapItemWhereInput | CompanyRoadmapItemWhereInput[]
    id?: StringFilter<"CompanyRoadmapItem"> | string
    companyId?: StringFilter<"CompanyRoadmapItem"> | string
    itemType?: StringFilter<"CompanyRoadmapItem"> | string
    parentArchitecture?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    roadmapType?: StringFilter<"CompanyRoadmapItem"> | string
    category?: StringFilter<"CompanyRoadmapItem"> | string
    title?: StringFilter<"CompanyRoadmapItem"> | string
    whatItDoes?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howItHelps?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    fieldsData?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howToGet?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    prerequisites?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    visual?: StringFilter<"CompanyRoadmapItem"> | string
    orderNumber?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursEstimated?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursSpent?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    targetDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    status?: StringFilter<"CompanyRoadmapItem"> | string
    priority?: StringFilter<"CompanyRoadmapItem"> | string
    completedAt?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }

  export type CompanyRoadmapItemOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    itemType?: SortOrder
    parentArchitecture?: SortOrderInput | SortOrder
    roadmapType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    whatItDoes?: SortOrderInput | SortOrder
    howItHelps?: SortOrderInput | SortOrder
    fieldsData?: SortOrderInput | SortOrder
    howToGet?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    visual?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    hoursEstimated?: SortOrderInput | SortOrder
    hoursSpent?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    GoFastCompany?: GoFastCompanyOrderByWithRelationInput
  }

  export type CompanyRoadmapItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyRoadmapItemWhereInput | CompanyRoadmapItemWhereInput[]
    OR?: CompanyRoadmapItemWhereInput[]
    NOT?: CompanyRoadmapItemWhereInput | CompanyRoadmapItemWhereInput[]
    companyId?: StringFilter<"CompanyRoadmapItem"> | string
    itemType?: StringFilter<"CompanyRoadmapItem"> | string
    parentArchitecture?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    roadmapType?: StringFilter<"CompanyRoadmapItem"> | string
    category?: StringFilter<"CompanyRoadmapItem"> | string
    title?: StringFilter<"CompanyRoadmapItem"> | string
    whatItDoes?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howItHelps?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    fieldsData?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howToGet?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    prerequisites?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    visual?: StringFilter<"CompanyRoadmapItem"> | string
    orderNumber?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursEstimated?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursSpent?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    targetDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    status?: StringFilter<"CompanyRoadmapItem"> | string
    priority?: StringFilter<"CompanyRoadmapItem"> | string
    completedAt?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }, "id">

  export type CompanyRoadmapItemOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    itemType?: SortOrder
    parentArchitecture?: SortOrderInput | SortOrder
    roadmapType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    whatItDoes?: SortOrderInput | SortOrder
    howItHelps?: SortOrderInput | SortOrder
    fieldsData?: SortOrderInput | SortOrder
    howToGet?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    visual?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    hoursEstimated?: SortOrderInput | SortOrder
    hoursSpent?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    _count?: CompanyRoadmapItemCountOrderByAggregateInput
    _avg?: CompanyRoadmapItemAvgOrderByAggregateInput
    _max?: CompanyRoadmapItemMaxOrderByAggregateInput
    _min?: CompanyRoadmapItemMinOrderByAggregateInput
    _sum?: CompanyRoadmapItemSumOrderByAggregateInput
  }

  export type CompanyRoadmapItemScalarWhereWithAggregatesInput = {
    AND?: CompanyRoadmapItemScalarWhereWithAggregatesInput | CompanyRoadmapItemScalarWhereWithAggregatesInput[]
    OR?: CompanyRoadmapItemScalarWhereWithAggregatesInput[]
    NOT?: CompanyRoadmapItemScalarWhereWithAggregatesInput | CompanyRoadmapItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    companyId?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    itemType?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    parentArchitecture?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    roadmapType?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    category?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    title?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    whatItDoes?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    howItHelps?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    fieldsData?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    howToGet?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    prerequisites?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
    visual?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    orderNumber?: IntNullableWithAggregatesFilter<"CompanyRoadmapItem"> | number | null
    hoursEstimated?: IntNullableWithAggregatesFilter<"CompanyRoadmapItem"> | number | null
    hoursSpent?: IntNullableWithAggregatesFilter<"CompanyRoadmapItem"> | number | null
    targetDate?: DateTimeNullableWithAggregatesFilter<"CompanyRoadmapItem"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"CompanyRoadmapItem"> | Date | string | null
    status?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    priority?: StringWithAggregatesFilter<"CompanyRoadmapItem"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CompanyRoadmapItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyRoadmapItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyRoadmapItem"> | Date | string
    goFastCompanyId?: StringNullableWithAggregatesFilter<"CompanyRoadmapItem"> | string | null
  }

  export type CompanyCrmContactWhereInput = {
    AND?: CompanyCrmContactWhereInput | CompanyCrmContactWhereInput[]
    OR?: CompanyCrmContactWhereInput[]
    NOT?: CompanyCrmContactWhereInput | CompanyCrmContactWhereInput[]
    id?: StringFilter<"CompanyCrmContact"> | string
    companyId?: StringFilter<"CompanyCrmContact"> | string
    name?: StringFilter<"CompanyCrmContact"> | string
    role?: StringNullableFilter<"CompanyCrmContact"> | string | null
    email?: StringNullableFilter<"CompanyCrmContact"> | string | null
    companyName?: StringNullableFilter<"CompanyCrmContact"> | string | null
    pipeline?: StringFilter<"CompanyCrmContact"> | string
    status?: StringFilter<"CompanyCrmContact"> | string
    nextStep?: StringNullableFilter<"CompanyCrmContact"> | string | null
    notes?: StringNullableFilter<"CompanyCrmContact"> | string | null
    createdAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CompanyCrmContactOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyCrmContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyCrmContactWhereInput | CompanyCrmContactWhereInput[]
    OR?: CompanyCrmContactWhereInput[]
    NOT?: CompanyCrmContactWhereInput | CompanyCrmContactWhereInput[]
    companyId?: StringFilter<"CompanyCrmContact"> | string
    name?: StringFilter<"CompanyCrmContact"> | string
    role?: StringNullableFilter<"CompanyCrmContact"> | string | null
    email?: StringNullableFilter<"CompanyCrmContact"> | string | null
    companyName?: StringNullableFilter<"CompanyCrmContact"> | string | null
    pipeline?: StringFilter<"CompanyCrmContact"> | string
    status?: StringFilter<"CompanyCrmContact"> | string
    nextStep?: StringNullableFilter<"CompanyCrmContact"> | string | null
    notes?: StringNullableFilter<"CompanyCrmContact"> | string | null
    createdAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type CompanyCrmContactOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCrmContactCountOrderByAggregateInput
    _max?: CompanyCrmContactMaxOrderByAggregateInput
    _min?: CompanyCrmContactMinOrderByAggregateInput
  }

  export type CompanyCrmContactScalarWhereWithAggregatesInput = {
    AND?: CompanyCrmContactScalarWhereWithAggregatesInput | CompanyCrmContactScalarWhereWithAggregatesInput[]
    OR?: CompanyCrmContactScalarWhereWithAggregatesInput[]
    NOT?: CompanyCrmContactScalarWhereWithAggregatesInput | CompanyCrmContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyCrmContact"> | string
    companyId?: StringWithAggregatesFilter<"CompanyCrmContact"> | string
    name?: StringWithAggregatesFilter<"CompanyCrmContact"> | string
    role?: StringNullableWithAggregatesFilter<"CompanyCrmContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"CompanyCrmContact"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"CompanyCrmContact"> | string | null
    pipeline?: StringWithAggregatesFilter<"CompanyCrmContact"> | string
    status?: StringWithAggregatesFilter<"CompanyCrmContact"> | string
    nextStep?: StringNullableWithAggregatesFilter<"CompanyCrmContact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CompanyCrmContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyCrmContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyCrmContact"> | Date | string
  }

  export type CompanyFinancialSpendWhereInput = {
    AND?: CompanyFinancialSpendWhereInput | CompanyFinancialSpendWhereInput[]
    OR?: CompanyFinancialSpendWhereInput[]
    NOT?: CompanyFinancialSpendWhereInput | CompanyFinancialSpendWhereInput[]
    id?: StringFilter<"CompanyFinancialSpend"> | string
    companyId?: StringFilter<"CompanyFinancialSpend"> | string
    date?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    amount?: FloatFilter<"CompanyFinancialSpend"> | number
    category?: StringFilter<"CompanyFinancialSpend"> | string
    description?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    vendor?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    department?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    project?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    receiptUrl?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    createdAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }

  export type CompanyFinancialSpendOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    GoFastCompany?: GoFastCompanyOrderByWithRelationInput
  }

  export type CompanyFinancialSpendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyFinancialSpendWhereInput | CompanyFinancialSpendWhereInput[]
    OR?: CompanyFinancialSpendWhereInput[]
    NOT?: CompanyFinancialSpendWhereInput | CompanyFinancialSpendWhereInput[]
    companyId?: StringFilter<"CompanyFinancialSpend"> | string
    date?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    amount?: FloatFilter<"CompanyFinancialSpend"> | number
    category?: StringFilter<"CompanyFinancialSpend"> | string
    description?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    vendor?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    department?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    project?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    receiptUrl?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    createdAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }, "id">

  export type CompanyFinancialSpendOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    _count?: CompanyFinancialSpendCountOrderByAggregateInput
    _avg?: CompanyFinancialSpendAvgOrderByAggregateInput
    _max?: CompanyFinancialSpendMaxOrderByAggregateInput
    _min?: CompanyFinancialSpendMinOrderByAggregateInput
    _sum?: CompanyFinancialSpendSumOrderByAggregateInput
  }

  export type CompanyFinancialSpendScalarWhereWithAggregatesInput = {
    AND?: CompanyFinancialSpendScalarWhereWithAggregatesInput | CompanyFinancialSpendScalarWhereWithAggregatesInput[]
    OR?: CompanyFinancialSpendScalarWhereWithAggregatesInput[]
    NOT?: CompanyFinancialSpendScalarWhereWithAggregatesInput | CompanyFinancialSpendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyFinancialSpend"> | string
    companyId?: StringWithAggregatesFilter<"CompanyFinancialSpend"> | string
    date?: DateTimeWithAggregatesFilter<"CompanyFinancialSpend"> | Date | string
    amount?: FloatWithAggregatesFilter<"CompanyFinancialSpend"> | number
    category?: StringWithAggregatesFilter<"CompanyFinancialSpend"> | string
    description?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
    department?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
    project?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyFinancialSpend"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyFinancialSpend"> | Date | string
    goFastCompanyId?: StringNullableWithAggregatesFilter<"CompanyFinancialSpend"> | string | null
  }

  export type CompanyFinancialProjectionWhereInput = {
    AND?: CompanyFinancialProjectionWhereInput | CompanyFinancialProjectionWhereInput[]
    OR?: CompanyFinancialProjectionWhereInput[]
    NOT?: CompanyFinancialProjectionWhereInput | CompanyFinancialProjectionWhereInput[]
    id?: StringFilter<"CompanyFinancialProjection"> | string
    companyId?: StringFilter<"CompanyFinancialProjection"> | string
    period?: StringFilter<"CompanyFinancialProjection"> | string
    periodStart?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    periodEnd?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    projectedRevenue?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    projectedExpenses?: FloatFilter<"CompanyFinancialProjection"> | number
    projectedNet?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    categoryBreakdown?: JsonNullableFilter<"CompanyFinancialProjection">
    currentCash?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    monthlyBurnRate?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    runwayMonths?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    assumptions?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
    status?: StringFilter<"CompanyFinancialProjection"> | string
    createdAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }

  export type CompanyFinancialProjectionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    projectedRevenue?: SortOrderInput | SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrderInput | SortOrder
    categoryBreakdown?: SortOrderInput | SortOrder
    currentCash?: SortOrderInput | SortOrder
    monthlyBurnRate?: SortOrderInput | SortOrder
    runwayMonths?: SortOrderInput | SortOrder
    assumptions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    GoFastCompany?: GoFastCompanyOrderByWithRelationInput
  }

  export type CompanyFinancialProjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyFinancialProjectionWhereInput | CompanyFinancialProjectionWhereInput[]
    OR?: CompanyFinancialProjectionWhereInput[]
    NOT?: CompanyFinancialProjectionWhereInput | CompanyFinancialProjectionWhereInput[]
    companyId?: StringFilter<"CompanyFinancialProjection"> | string
    period?: StringFilter<"CompanyFinancialProjection"> | string
    periodStart?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    periodEnd?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    projectedRevenue?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    projectedExpenses?: FloatFilter<"CompanyFinancialProjection"> | number
    projectedNet?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    categoryBreakdown?: JsonNullableFilter<"CompanyFinancialProjection">
    currentCash?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    monthlyBurnRate?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    runwayMonths?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    assumptions?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
    status?: StringFilter<"CompanyFinancialProjection"> | string
    createdAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }, "id">

  export type CompanyFinancialProjectionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    projectedRevenue?: SortOrderInput | SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrderInput | SortOrder
    categoryBreakdown?: SortOrderInput | SortOrder
    currentCash?: SortOrderInput | SortOrder
    monthlyBurnRate?: SortOrderInput | SortOrder
    runwayMonths?: SortOrderInput | SortOrder
    assumptions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    _count?: CompanyFinancialProjectionCountOrderByAggregateInput
    _avg?: CompanyFinancialProjectionAvgOrderByAggregateInput
    _max?: CompanyFinancialProjectionMaxOrderByAggregateInput
    _min?: CompanyFinancialProjectionMinOrderByAggregateInput
    _sum?: CompanyFinancialProjectionSumOrderByAggregateInput
  }

  export type CompanyFinancialProjectionScalarWhereWithAggregatesInput = {
    AND?: CompanyFinancialProjectionScalarWhereWithAggregatesInput | CompanyFinancialProjectionScalarWhereWithAggregatesInput[]
    OR?: CompanyFinancialProjectionScalarWhereWithAggregatesInput[]
    NOT?: CompanyFinancialProjectionScalarWhereWithAggregatesInput | CompanyFinancialProjectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyFinancialProjection"> | string
    companyId?: StringWithAggregatesFilter<"CompanyFinancialProjection"> | string
    period?: StringWithAggregatesFilter<"CompanyFinancialProjection"> | string
    periodStart?: DateTimeWithAggregatesFilter<"CompanyFinancialProjection"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"CompanyFinancialProjection"> | Date | string
    projectedRevenue?: FloatNullableWithAggregatesFilter<"CompanyFinancialProjection"> | number | null
    projectedExpenses?: FloatWithAggregatesFilter<"CompanyFinancialProjection"> | number
    projectedNet?: FloatNullableWithAggregatesFilter<"CompanyFinancialProjection"> | number | null
    categoryBreakdown?: JsonNullableWithAggregatesFilter<"CompanyFinancialProjection">
    currentCash?: FloatNullableWithAggregatesFilter<"CompanyFinancialProjection"> | number | null
    monthlyBurnRate?: FloatNullableWithAggregatesFilter<"CompanyFinancialProjection"> | number | null
    runwayMonths?: FloatNullableWithAggregatesFilter<"CompanyFinancialProjection"> | number | null
    assumptions?: StringNullableWithAggregatesFilter<"CompanyFinancialProjection"> | string | null
    status?: StringWithAggregatesFilter<"CompanyFinancialProjection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyFinancialProjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyFinancialProjection"> | Date | string
    goFastCompanyId?: StringNullableWithAggregatesFilter<"CompanyFinancialProjection"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    founderId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    department?: StringNullableFilter<"Task"> | string | null
    isTopPriority?: BoolFilter<"Task"> | boolean
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    goFastCompanyId?: StringNullableFilter<"Task"> | string | null
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    isTopPriority?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    founder?: FounderOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    GoFastCompany?: GoFastCompanyOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    founderId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    department?: StringNullableFilter<"Task"> | string | null
    isTopPriority?: BoolFilter<"Task"> | boolean
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    goFastCompanyId?: StringNullableFilter<"Task"> | string | null
    founder?: XOR<FounderNullableScalarRelationFilter, FounderWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    GoFastCompany?: XOR<GoFastCompanyNullableScalarRelationFilter, GoFastCompanyWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    isTopPriority?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    founderId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    department?: StringNullableWithAggregatesFilter<"Task"> | string | null
    isTopPriority?: BoolWithAggregatesFilter<"Task"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    goFastCompanyId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    groupId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    author?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    authorId?: SortOrder
    author?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    groupId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    author?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    authorId?: SortOrder
    author?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    groupId?: StringWithAggregatesFilter<"Message"> | string
    authorId?: StringWithAggregatesFilter<"Message"> | string
    author?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type GoFastCompanyWhereInput = {
    AND?: GoFastCompanyWhereInput | GoFastCompanyWhereInput[]
    OR?: GoFastCompanyWhereInput[]
    NOT?: GoFastCompanyWhereInput | GoFastCompanyWhereInput[]
    id?: StringFilter<"GoFastCompany"> | string
    containerId?: StringFilter<"GoFastCompany"> | string
    companyName?: StringFilter<"GoFastCompany"> | string
    address?: StringNullableFilter<"GoFastCompany"> | string | null
    city?: StringNullableFilter<"GoFastCompany"> | string | null
    state?: StringNullableFilter<"GoFastCompany"> | string | null
    website?: StringNullableFilter<"GoFastCompany"> | string | null
    description?: StringNullableFilter<"GoFastCompany"> | string | null
    createdAt?: DateTimeFilter<"GoFastCompany"> | Date | string
    updatedAt?: DateTimeFilter<"GoFastCompany"> | Date | string
    staff?: CompanyStaffListRelationFilter
    contacts?: ContactListRelationFilter
    pipelines?: PipelineListRelationFilter
    pipelineConfigs?: PipelineConfigListRelationFilter
    productPipelineItems?: ProductPipelineItemListRelationFilter
    financialSpends?: CompanyFinancialSpendListRelationFilter
    financialProjections?: CompanyFinancialProjectionListRelationFilter
    roadmapItems?: CompanyRoadmapItemListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type GoFastCompanyOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    companyName?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: CompanyStaffOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    pipelines?: PipelineOrderByRelationAggregateInput
    pipelineConfigs?: PipelineConfigOrderByRelationAggregateInput
    productPipelineItems?: ProductPipelineItemOrderByRelationAggregateInput
    financialSpends?: CompanyFinancialSpendOrderByRelationAggregateInput
    financialProjections?: CompanyFinancialProjectionOrderByRelationAggregateInput
    roadmapItems?: CompanyRoadmapItemOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type GoFastCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    containerId?: string
    AND?: GoFastCompanyWhereInput | GoFastCompanyWhereInput[]
    OR?: GoFastCompanyWhereInput[]
    NOT?: GoFastCompanyWhereInput | GoFastCompanyWhereInput[]
    companyName?: StringFilter<"GoFastCompany"> | string
    address?: StringNullableFilter<"GoFastCompany"> | string | null
    city?: StringNullableFilter<"GoFastCompany"> | string | null
    state?: StringNullableFilter<"GoFastCompany"> | string | null
    website?: StringNullableFilter<"GoFastCompany"> | string | null
    description?: StringNullableFilter<"GoFastCompany"> | string | null
    createdAt?: DateTimeFilter<"GoFastCompany"> | Date | string
    updatedAt?: DateTimeFilter<"GoFastCompany"> | Date | string
    staff?: CompanyStaffListRelationFilter
    contacts?: ContactListRelationFilter
    pipelines?: PipelineListRelationFilter
    pipelineConfigs?: PipelineConfigListRelationFilter
    productPipelineItems?: ProductPipelineItemListRelationFilter
    financialSpends?: CompanyFinancialSpendListRelationFilter
    financialProjections?: CompanyFinancialProjectionListRelationFilter
    roadmapItems?: CompanyRoadmapItemListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id" | "containerId">

  export type GoFastCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    companyName?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoFastCompanyCountOrderByAggregateInput
    _max?: GoFastCompanyMaxOrderByAggregateInput
    _min?: GoFastCompanyMinOrderByAggregateInput
  }

  export type GoFastCompanyScalarWhereWithAggregatesInput = {
    AND?: GoFastCompanyScalarWhereWithAggregatesInput | GoFastCompanyScalarWhereWithAggregatesInput[]
    OR?: GoFastCompanyScalarWhereWithAggregatesInput[]
    NOT?: GoFastCompanyScalarWhereWithAggregatesInput | GoFastCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoFastCompany"> | string
    containerId?: StringWithAggregatesFilter<"GoFastCompany"> | string
    companyName?: StringWithAggregatesFilter<"GoFastCompany"> | string
    address?: StringNullableWithAggregatesFilter<"GoFastCompany"> | string | null
    city?: StringNullableWithAggregatesFilter<"GoFastCompany"> | string | null
    state?: StringNullableWithAggregatesFilter<"GoFastCompany"> | string | null
    website?: StringNullableWithAggregatesFilter<"GoFastCompany"> | string | null
    description?: StringNullableWithAggregatesFilter<"GoFastCompany"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GoFastCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoFastCompany"> | Date | string
  }

  export type CompanyStaffWhereInput = {
    AND?: CompanyStaffWhereInput | CompanyStaffWhereInput[]
    OR?: CompanyStaffWhereInput[]
    NOT?: CompanyStaffWhereInput | CompanyStaffWhereInput[]
    id?: StringFilter<"CompanyStaff"> | string
    firebaseId?: StringFilter<"CompanyStaff"> | string
    name?: StringNullableFilter<"CompanyStaff"> | string | null
    email?: StringNullableFilter<"CompanyStaff"> | string | null
    photoURL?: StringNullableFilter<"CompanyStaff"> | string | null
    companyId?: StringFilter<"CompanyStaff"> | string
    role?: StringFilter<"CompanyStaff"> | string
    department?: StringNullableFilter<"CompanyStaff"> | string | null
    verificationCode?: StringNullableFilter<"CompanyStaff"> | string | null
    joinedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    createdAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
  }

  export type CompanyStaffOrderByWithRelationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    companyId?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: GoFastCompanyOrderByWithRelationInput
  }

  export type CompanyStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firebaseId?: string
    AND?: CompanyStaffWhereInput | CompanyStaffWhereInput[]
    OR?: CompanyStaffWhereInput[]
    NOT?: CompanyStaffWhereInput | CompanyStaffWhereInput[]
    name?: StringNullableFilter<"CompanyStaff"> | string | null
    email?: StringNullableFilter<"CompanyStaff"> | string | null
    photoURL?: StringNullableFilter<"CompanyStaff"> | string | null
    companyId?: StringFilter<"CompanyStaff"> | string
    role?: StringFilter<"CompanyStaff"> | string
    department?: StringNullableFilter<"CompanyStaff"> | string | null
    verificationCode?: StringNullableFilter<"CompanyStaff"> | string | null
    joinedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    createdAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
  }, "id" | "firebaseId">

  export type CompanyStaffOrderByWithAggregationInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    photoURL?: SortOrderInput | SortOrder
    companyId?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyStaffCountOrderByAggregateInput
    _max?: CompanyStaffMaxOrderByAggregateInput
    _min?: CompanyStaffMinOrderByAggregateInput
  }

  export type CompanyStaffScalarWhereWithAggregatesInput = {
    AND?: CompanyStaffScalarWhereWithAggregatesInput | CompanyStaffScalarWhereWithAggregatesInput[]
    OR?: CompanyStaffScalarWhereWithAggregatesInput[]
    NOT?: CompanyStaffScalarWhereWithAggregatesInput | CompanyStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyStaff"> | string
    firebaseId?: StringWithAggregatesFilter<"CompanyStaff"> | string
    name?: StringNullableWithAggregatesFilter<"CompanyStaff"> | string | null
    email?: StringNullableWithAggregatesFilter<"CompanyStaff"> | string | null
    photoURL?: StringNullableWithAggregatesFilter<"CompanyStaff"> | string | null
    companyId?: StringWithAggregatesFilter<"CompanyStaff"> | string
    role?: StringWithAggregatesFilter<"CompanyStaff"> | string
    department?: StringNullableWithAggregatesFilter<"CompanyStaff"> | string | null
    verificationCode?: StringNullableWithAggregatesFilter<"CompanyStaff"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"CompanyStaff"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyStaff"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    companyId?: StringFilter<"Contact"> | string
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    goesBy?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    athleteId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    pipelines?: PipelineListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    goesBy?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    athleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: GoFastCompanyOrderByWithRelationInput
    pipelines?: PipelineOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    companyId?: StringFilter<"Contact"> | string
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    goesBy?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    athleteId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    pipelines?: PipelineListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    goesBy?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    athleteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    companyId?: StringWithAggregatesFilter<"Contact"> | string
    firstName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    goesBy?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    title?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    athleteId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    companyId?: StringFilter<"Pipeline"> | string
    contactId?: StringFilter<"Pipeline"> | string
    configId?: StringFilter<"Pipeline"> | string
    stageId?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    config?: XOR<PipelineConfigScalarRelationFilter, PipelineConfigWhereInput>
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactId?: SortOrder
    configId?: SortOrder
    stageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: GoFastCompanyOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    config?: PipelineConfigOrderByWithRelationInput
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contactId_configId?: PipelineContactIdConfigIdCompoundUniqueInput
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    companyId?: StringFilter<"Pipeline"> | string
    contactId?: StringFilter<"Pipeline"> | string
    configId?: StringFilter<"Pipeline"> | string
    stageId?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    config?: XOR<PipelineConfigScalarRelationFilter, PipelineConfigWhereInput>
  }, "id" | "contactId_configId">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactId?: SortOrder
    configId?: SortOrder
    stageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    companyId?: StringWithAggregatesFilter<"Pipeline"> | string
    contactId?: StringWithAggregatesFilter<"Pipeline"> | string
    configId?: StringWithAggregatesFilter<"Pipeline"> | string
    stageId?: StringWithAggregatesFilter<"Pipeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
  }

  export type PipelineConfigWhereInput = {
    AND?: PipelineConfigWhereInput | PipelineConfigWhereInput[]
    OR?: PipelineConfigWhereInput[]
    NOT?: PipelineConfigWhereInput | PipelineConfigWhereInput[]
    id?: StringFilter<"PipelineConfig"> | string
    companyId?: StringFilter<"PipelineConfig"> | string
    name?: StringFilter<"PipelineConfig"> | string
    description?: StringNullableFilter<"PipelineConfig"> | string | null
    stages?: JsonFilter<"PipelineConfig">
    isActive?: BoolFilter<"PipelineConfig"> | boolean
    createdAt?: DateTimeFilter<"PipelineConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineConfig"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    pipelines?: PipelineListRelationFilter
  }

  export type PipelineConfigOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    stages?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: GoFastCompanyOrderByWithRelationInput
    pipelines?: PipelineOrderByRelationAggregateInput
  }

  export type PipelineConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineConfigWhereInput | PipelineConfigWhereInput[]
    OR?: PipelineConfigWhereInput[]
    NOT?: PipelineConfigWhereInput | PipelineConfigWhereInput[]
    companyId?: StringFilter<"PipelineConfig"> | string
    name?: StringFilter<"PipelineConfig"> | string
    description?: StringNullableFilter<"PipelineConfig"> | string | null
    stages?: JsonFilter<"PipelineConfig">
    isActive?: BoolFilter<"PipelineConfig"> | boolean
    createdAt?: DateTimeFilter<"PipelineConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineConfig"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
    pipelines?: PipelineListRelationFilter
  }, "id">

  export type PipelineConfigOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    stages?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PipelineConfigCountOrderByAggregateInput
    _max?: PipelineConfigMaxOrderByAggregateInput
    _min?: PipelineConfigMinOrderByAggregateInput
  }

  export type PipelineConfigScalarWhereWithAggregatesInput = {
    AND?: PipelineConfigScalarWhereWithAggregatesInput | PipelineConfigScalarWhereWithAggregatesInput[]
    OR?: PipelineConfigScalarWhereWithAggregatesInput[]
    NOT?: PipelineConfigScalarWhereWithAggregatesInput | PipelineConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PipelineConfig"> | string
    companyId?: StringWithAggregatesFilter<"PipelineConfig"> | string
    name?: StringWithAggregatesFilter<"PipelineConfig"> | string
    description?: StringNullableWithAggregatesFilter<"PipelineConfig"> | string | null
    stages?: JsonWithAggregatesFilter<"PipelineConfig">
    isActive?: BoolWithAggregatesFilter<"PipelineConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PipelineConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PipelineConfig"> | Date | string
  }

  export type ProductPipelineItemWhereInput = {
    AND?: ProductPipelineItemWhereInput | ProductPipelineItemWhereInput[]
    OR?: ProductPipelineItemWhereInput[]
    NOT?: ProductPipelineItemWhereInput | ProductPipelineItemWhereInput[]
    id?: StringFilter<"ProductPipelineItem"> | string
    companyId?: StringFilter<"ProductPipelineItem"> | string
    name?: StringFilter<"ProductPipelineItem"> | string
    description?: StringNullableFilter<"ProductPipelineItem"> | string | null
    timeItTakes?: StringNullableFilter<"ProductPipelineItem"> | string | null
    status?: StringFilter<"ProductPipelineItem"> | string
    priority?: StringFilter<"ProductPipelineItem"> | string
    startedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
  }

  export type ProductPipelineItemOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    timeItTakes?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: GoFastCompanyOrderByWithRelationInput
  }

  export type ProductPipelineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductPipelineItemWhereInput | ProductPipelineItemWhereInput[]
    OR?: ProductPipelineItemWhereInput[]
    NOT?: ProductPipelineItemWhereInput | ProductPipelineItemWhereInput[]
    companyId?: StringFilter<"ProductPipelineItem"> | string
    name?: StringFilter<"ProductPipelineItem"> | string
    description?: StringNullableFilter<"ProductPipelineItem"> | string | null
    timeItTakes?: StringNullableFilter<"ProductPipelineItem"> | string | null
    status?: StringFilter<"ProductPipelineItem"> | string
    priority?: StringFilter<"ProductPipelineItem"> | string
    startedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
    company?: XOR<GoFastCompanyScalarRelationFilter, GoFastCompanyWhereInput>
  }, "id">

  export type ProductPipelineItemOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    timeItTakes?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductPipelineItemCountOrderByAggregateInput
    _max?: ProductPipelineItemMaxOrderByAggregateInput
    _min?: ProductPipelineItemMinOrderByAggregateInput
  }

  export type ProductPipelineItemScalarWhereWithAggregatesInput = {
    AND?: ProductPipelineItemScalarWhereWithAggregatesInput | ProductPipelineItemScalarWhereWithAggregatesInput[]
    OR?: ProductPipelineItemScalarWhereWithAggregatesInput[]
    NOT?: ProductPipelineItemScalarWhereWithAggregatesInput | ProductPipelineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductPipelineItem"> | string
    companyId?: StringWithAggregatesFilter<"ProductPipelineItem"> | string
    name?: StringWithAggregatesFilter<"ProductPipelineItem"> | string
    description?: StringNullableWithAggregatesFilter<"ProductPipelineItem"> | string | null
    timeItTakes?: StringNullableWithAggregatesFilter<"ProductPipelineItem"> | string | null
    status?: StringWithAggregatesFilter<"ProductPipelineItem"> | string
    priority?: StringWithAggregatesFilter<"ProductPipelineItem"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ProductPipelineItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProductPipelineItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductPipelineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductPipelineItem"> | Date | string
  }

  export type AthleteCreateInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateManyInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
  }

  export type AthleteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AthleteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AthleteActivityCreateInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutActivitiesInput
  }

  export type AthleteActivityUncheckedCreateInput = {
    id?: string
    athleteId: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type AthleteActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityCreateManyInput = {
    id?: string
    athleteId: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewCreateInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMembershipsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMembershipsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMessagesInput
    athlete: AthleteCreateNestedOneWithoutRunCrewMessagesInput
  }

  export type RunCrewMessageUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMessagesNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMessagesNestedInput
  }

  export type RunCrewMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutAnnouncementsInput
    author: AthleteCreateNestedOneWithoutRunCrewAnnouncementsInput
  }

  export type RunCrewAnnouncementUncheckedCreateInput = {
    id?: string
    runCrewId: string
    authorId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewAnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutAnnouncementsNestedInput
    author?: AthleteUpdateOneRequiredWithoutRunCrewAnnouncementsNestedInput
  }

  export type RunCrewAnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementCreateManyInput = {
    id?: string
    runCrewId: string
    authorId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewAnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutLeaderboardEntriesInput
    athlete: AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput
  }

  export type RunCrewLeaderboardUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunCreateInput = {
    id?: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutRunsInput
    createdBy: AthleteCreateNestedOneWithoutRunCrewRunsInput
    rsvps?: RunCrewRunRSVPCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunUncheckedCreateInput = {
    id?: string
    runCrewId: string
    createdById: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutRunsNestedInput
    createdBy?: AthleteUpdateOneRequiredWithoutRunCrewRunsNestedInput
    rsvps?: RunCrewRunRSVPUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewRunRSVPUncheckedUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunCreateManyInput = {
    id?: string
    runCrewId: string
    createdById: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    run: RunCrewRunCreateNestedOneWithoutRsvpsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewRunRSVPsInput
  }

  export type RunCrewRunRSVPUncheckedCreateInput = {
    id?: string
    runId: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewRunRSVPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: RunCrewRunUpdateOneRequiredWithoutRsvpsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewRunRSVPsNestedInput
  }

  export type RunCrewRunRSVPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPCreateManyInput = {
    id?: string
    runId: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewRunRSVPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventCreateInput = {
    id?: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutEventsInput
    organizer: AthleteCreateNestedOneWithoutRunCrewEventsInput
    rsvps?: RunCrewEventRSVPCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventUncheckedCreateInput = {
    id?: string
    runCrewId: string
    organizerId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutEventsNestedInput
    organizer?: AthleteUpdateOneRequiredWithoutRunCrewEventsNestedInput
    rsvps?: RunCrewEventRSVPUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    organizerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewEventRSVPUncheckedUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventCreateManyInput = {
    id?: string
    runCrewId: string
    organizerId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    organizerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: RunCrewEventCreateNestedOneWithoutRsvpsInput
    athlete: AthleteCreateNestedOneWithoutRunCrewEventRSVPsInput
  }

  export type RunCrewEventRSVPUncheckedCreateInput = {
    id?: string
    eventId: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventRSVPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: RunCrewEventUpdateOneRequiredWithoutRsvpsNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewEventRSVPsNestedInput
  }

  export type RunCrewEventRSVPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPCreateManyInput = {
    id?: string
    eventId: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventRSVPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerCreateInput = {
    id?: string
    role: string
    createdAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutManagersInput
    athlete: AthleteCreateNestedOneWithoutRunCrewManagersInput
  }

  export type RunCrewManagerUncheckedCreateInput = {
    id?: string
    runCrewId: string
    athleteId: string
    role: string
    createdAt?: Date | string
  }

  export type RunCrewManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutManagersNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewManagersNestedInput
  }

  export type RunCrewManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerCreateManyInput = {
    id?: string
    runCrewId: string
    athleteId: string
    role: string
    createdAt?: Date | string
  }

  export type RunCrewManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceCreateInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAthlete?: AthleteCreateNestedOneWithoutCreatedRacesInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAthlete?: AthleteUpdateOneWithoutCreatedRacesNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanCreateInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanCreateManyInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutPlannedDaysInput
    athlete: AthleteCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateInput = {
    id?: string
    trainingPlanId: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateManyInput = {
    id?: string
    trainingPlanId: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionCreateInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutExecutionsInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUncheckedCreateInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionCreateManyInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput
    athlete: AthleteCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateInput = {
    id?: string
    executionId: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput
    athlete?: AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateManyInput = {
    id?: string
    executionId: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateManyInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutTasksInput
  }

  export type FounderTaskUncheckedCreateInput = {
    id?: string
    founderId: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutTasksNestedInput
  }

  export type FounderTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateManyInput = {
    id?: string
    founderId: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactCreateInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutCrmContactsInput
  }

  export type CrmContactUncheckedCreateInput = {
    id?: string
    founderId: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutCrmContactsNestedInput
  }

  export type CrmContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactCreateManyInput = {
    id?: string
    founderId: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: FounderCreateNestedOneWithoutRoadmapItemsInput
  }

  export type RoadmapItemUncheckedCreateInput = {
    id?: string
    founderId: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutRoadmapItemsNestedInput
  }

  export type RoadmapItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateManyInput = {
    id?: string
    founderId: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderCreateInput = {
    id?: string
    role?: string | null
    joinedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFoundersInput
    founder: FounderCreateNestedOneWithoutCompanyFoundersInput
  }

  export type CompanyFounderUncheckedCreateInput = {
    id?: string
    companyId: string
    founderId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type CompanyFounderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFoundersNestedInput
    founder?: FounderUpdateOneRequiredWithoutCompanyFoundersNestedInput
  }

  export type CompanyFounderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderCreateManyInput = {
    id?: string
    companyId: string
    founderId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type CompanyFounderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeCreateInput = {
    id?: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type CompanyEmployeeUncheckedCreateInput = {
    id?: string
    companyId: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
  }

  export type CompanyEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type CompanyEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeCreateManyInput = {
    id?: string
    companyId: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
  }

  export type CompanyEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRoadmapItemCreateInput = {
    id?: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutRoadmapItemsInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutRoadmapItemsInput
  }

  export type CompanyRoadmapItemUncheckedCreateInput = {
    id?: string
    companyId: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyRoadmapItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutRoadmapItemsNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutRoadmapItemsNestedInput
  }

  export type CompanyRoadmapItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyRoadmapItemCreateManyInput = {
    id?: string
    companyId: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyRoadmapItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRoadmapItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCrmContactCreateInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCrmContactsInput
  }

  export type CompanyCrmContactUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCrmContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCrmContactsNestedInput
  }

  export type CompanyCrmContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCrmContactCreateManyInput = {
    id?: string
    companyId: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCrmContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCrmContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialSpendCreateInput = {
    id?: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFinancialSpendsInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutFinancialSpendsInput
  }

  export type CompanyFinancialSpendUncheckedCreateInput = {
    id?: string
    companyId: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialSpendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFinancialSpendsNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutFinancialSpendsNestedInput
  }

  export type CompanyFinancialSpendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialSpendCreateManyInput = {
    id?: string
    companyId: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialSpendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialSpendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialProjectionCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFinancialProjectionsInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutFinancialProjectionsInput
  }

  export type CompanyFinancialProjectionUncheckedCreateInput = {
    id?: string
    companyId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialProjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFinancialProjectionsNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutFinancialProjectionsNestedInput
  }

  export type CompanyFinancialProjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialProjectionCreateManyInput = {
    id?: string
    companyId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialProjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialProjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder?: FounderCreateNestedOneWithoutUnifiedTasksInput
    company?: CompanyCreateNestedOneWithoutTasksInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    founderId?: string | null
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneWithoutUnifiedTasksNestedInput
    company?: CompanyUpdateOneWithoutTasksNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    founderId?: string | null
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    groupId: string
    authorId: string
    author: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    groupId: string
    authorId: string
    author: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    groupId: string
    authorId: string
    author: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoFastCompanyCreateInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyCreateManyInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoFastCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoFastCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStaffCreateInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutStaffInput
  }

  export type CompanyStaffUncheckedCreateInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    companyId: string
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutStaffNestedInput
  }

  export type CompanyStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStaffCreateManyInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    companyId: string
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutContactsInput
    pipelines?: PipelineCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    companyId: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutContactsNestedInput
    pipelines?: PipelineUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    companyId: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateInput = {
    id?: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutPipelinesInput
    contact: ContactCreateNestedOneWithoutPipelinesInput
    config: PipelineConfigCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    companyId: string
    contactId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutPipelinesNestedInput
    contact?: ContactUpdateOneRequiredWithoutPipelinesNestedInput
    config?: PipelineConfigUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateManyInput = {
    id?: string
    companyId: string
    contactId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineConfigCreateInput = {
    id?: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutPipelineConfigsInput
    pipelines?: PipelineCreateNestedManyWithoutConfigInput
  }

  export type PipelineConfigUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineUncheckedCreateNestedManyWithoutConfigInput
  }

  export type PipelineConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutPipelineConfigsNestedInput
    pipelines?: PipelineUpdateManyWithoutConfigNestedInput
  }

  export type PipelineConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type PipelineConfigCreateManyInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutProductPipelineItemsInput
  }

  export type ProductPipelineItemUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPipelineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutProductPipelineItemsNestedInput
  }

  export type ProductPipelineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemCreateManyInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPipelineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AthleteActivityListRelationFilter = {
    every?: AthleteActivityWhereInput
    some?: AthleteActivityWhereInput
    none?: AthleteActivityWhereInput
  }

  export type RunCrewListRelationFilter = {
    every?: RunCrewWhereInput
    some?: RunCrewWhereInput
    none?: RunCrewWhereInput
  }

  export type RunCrewMembershipListRelationFilter = {
    every?: RunCrewMembershipWhereInput
    some?: RunCrewMembershipWhereInput
    none?: RunCrewMembershipWhereInput
  }

  export type RunCrewMessageListRelationFilter = {
    every?: RunCrewMessageWhereInput
    some?: RunCrewMessageWhereInput
    none?: RunCrewMessageWhereInput
  }

  export type RunCrewAnnouncementListRelationFilter = {
    every?: RunCrewAnnouncementWhereInput
    some?: RunCrewAnnouncementWhereInput
    none?: RunCrewAnnouncementWhereInput
  }

  export type RunCrewLeaderboardListRelationFilter = {
    every?: RunCrewLeaderboardWhereInput
    some?: RunCrewLeaderboardWhereInput
    none?: RunCrewLeaderboardWhereInput
  }

  export type RunCrewRunListRelationFilter = {
    every?: RunCrewRunWhereInput
    some?: RunCrewRunWhereInput
    none?: RunCrewRunWhereInput
  }

  export type RunCrewRunRSVPListRelationFilter = {
    every?: RunCrewRunRSVPWhereInput
    some?: RunCrewRunRSVPWhereInput
    none?: RunCrewRunRSVPWhereInput
  }

  export type RunCrewEventListRelationFilter = {
    every?: RunCrewEventWhereInput
    some?: RunCrewEventWhereInput
    none?: RunCrewEventWhereInput
  }

  export type RunCrewEventRSVPListRelationFilter = {
    every?: RunCrewEventRSVPWhereInput
    some?: RunCrewEventRSVPWhereInput
    none?: RunCrewEventRSVPWhereInput
  }

  export type RunCrewManagerListRelationFilter = {
    every?: RunCrewManagerWhereInput
    some?: RunCrewManagerWhereInput
    none?: RunCrewManagerWhereInput
  }

  export type RaceListRelationFilter = {
    every?: RaceWhereInput
    some?: RaceWhereInput
    none?: RaceWhereInput
  }

  export type TrainingPlanListRelationFilter = {
    every?: TrainingPlanWhereInput
    some?: TrainingPlanWhereInput
    none?: TrainingPlanWhereInput
  }

  export type TrainingDayPlannedListRelationFilter = {
    every?: TrainingDayPlannedWhereInput
    some?: TrainingDayPlannedWhereInput
    none?: TrainingDayPlannedWhereInput
  }

  export type TrainingDayExecutedListRelationFilter = {
    every?: TrainingDayExecutedWhereInput
    some?: TrainingDayExecutedWhereInput
    none?: TrainingDayExecutedWhereInput
  }

  export type FounderNullableScalarRelationFilter = {
    is?: FounderWhereInput | null
    isNot?: FounderWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AthleteActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewAnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewRunRSVPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewEventRSVPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCrewManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDayPlannedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDayExecutedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AthleteCountOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_permissions?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    garmin_user_profile?: SortOrder
    garmin_user_sleep?: SortOrder
    garmin_user_preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteAvgOrderByAggregateInput = {
    weeklyMileage?: SortOrder
    garmin_expires_in?: SortOrder
    strava_id?: SortOrder
    strava_expires_at?: SortOrder
  }

  export type AthleteMaxOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteMinOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    gofastHandle?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    primarySport?: SortOrder
    photoURL?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    currentPace?: SortOrder
    weeklyMileage?: SortOrder
    trainingGoal?: SortOrder
    targetRace?: SortOrder
    trainingStartDate?: SortOrder
    preferredDistance?: SortOrder
    timePreference?: SortOrder
    paceRange?: SortOrder
    runningGoals?: SortOrder
    garmin_user_id?: SortOrder
    garmin_access_token?: SortOrder
    garmin_refresh_token?: SortOrder
    garmin_expires_in?: SortOrder
    garmin_scope?: SortOrder
    garmin_connected_at?: SortOrder
    garmin_last_sync_at?: SortOrder
    garmin_is_connected?: SortOrder
    garmin_disconnected_at?: SortOrder
    strava_id?: SortOrder
    strava_access_token?: SortOrder
    strava_refresh_token?: SortOrder
    strava_expires_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AthleteSumOrderByAggregateInput = {
    weeklyMileage?: SortOrder
    garmin_expires_in?: SortOrder
    strava_id?: SortOrder
    strava_expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AthleteScalarRelationFilter = {
    is?: AthleteWhereInput
    isNot?: AthleteWhereInput
  }

  export type AthleteActivityCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    summaryData?: SortOrder
    detailData?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type AthleteActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    sourceActivityId?: SortOrder
    source?: SortOrder
    activityType?: SortOrder
    activityName?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    summaryPolyline?: SortOrder
    deviceName?: SortOrder
    garminUserId?: SortOrder
    hydratedAt?: SortOrder
    syncedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivitySumOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
    averageSpeed?: SortOrder
    calories?: SortOrder
    averageHeartRate?: SortOrder
    maxHeartRate?: SortOrder
    elevationGain?: SortOrder
    steps?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AthleteNullableScalarRelationFilter = {
    is?: AthleteWhereInput | null
    isNot?: AthleteWhereInput | null
  }

  export type RunCrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    icon?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    icon?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    joinCode?: SortOrder
    logo?: SortOrder
    icon?: SortOrder
    runcrewAdminId?: SortOrder
    isArchived?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewScalarRelationFilter = {
    is?: RunCrewWhereInput
    isNot?: RunCrewWhereInput
  }

  export type RunCrewMembershipRunCrewIdAthleteIdCompoundUniqueInput = {
    runCrewId: string
    athleteId: string
  }

  export type RunCrewMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewMessageCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewMessageMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewAnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewAnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewAnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RunCrewLeaderboardRunCrewIdAthleteIdPeriodPeriodStartCompoundUniqueInput = {
    runCrewId: string
    athleteId: string
    period: string
    periodStart: Date | string
  }

  export type RunCrewLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardAvgOrderByAggregateInput = {
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
  }

  export type RunCrewLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    bestPace?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewLeaderboardSumOrderByAggregateInput = {
    totalMiles?: SortOrder
    totalRuns?: SortOrder
    totalCalories?: SortOrder
    totalElevation?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RunCrewRunCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    location?: SortOrder
    address?: SortOrder
    totalMiles?: SortOrder
    pace?: SortOrder
    stravaMapUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewRunAvgOrderByAggregateInput = {
    totalMiles?: SortOrder
  }

  export type RunCrewRunMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    location?: SortOrder
    address?: SortOrder
    totalMiles?: SortOrder
    pace?: SortOrder
    stravaMapUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewRunMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    location?: SortOrder
    address?: SortOrder
    totalMiles?: SortOrder
    pace?: SortOrder
    stravaMapUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewRunSumOrderByAggregateInput = {
    totalMiles?: SortOrder
  }

  export type RunCrewRunScalarRelationFilter = {
    is?: RunCrewRunWhereInput
    isNot?: RunCrewRunWhereInput
  }

  export type RunCrewRunRSVPRunIdAthleteIdCompoundUniqueInput = {
    runId: string
    athleteId: string
  }

  export type RunCrewRunRSVPCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewRunRSVPMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewRunRSVPMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewEventCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    organizerId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    address?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewEventMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    organizerId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    address?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewEventMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    organizerId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    address?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RunCrewEventScalarRelationFilter = {
    is?: RunCrewEventWhereInput
    isNot?: RunCrewEventWhereInput
  }

  export type RunCrewEventRSVPEventIdAthleteIdCompoundUniqueInput = {
    eventId: string
    athleteId: string
  }

  export type RunCrewEventRSVPCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewEventRSVPMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewEventRSVPMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    athleteId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewManagerRunCrewIdAthleteIdCompoundUniqueInput = {
    runCrewId: string
    athleteId: string
  }

  export type RunCrewManagerCountOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCrewManagerMinOrderByAggregateInput = {
    id?: SortOrder
    runCrewId?: SortOrder
    athleteId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    courseProfile?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    distanceMiles?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    raceName?: SortOrder
    raceType?: SortOrder
    raceDate?: SortOrder
    location?: SortOrder
    distanceMiles?: SortOrder
    registrationUrl?: SortOrder
    description?: SortOrder
    createdByAthleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    distanceMiles?: SortOrder
  }

  export type RaceScalarRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type TrainingPlanExecutionListRelationFilter = {
    every?: TrainingPlanExecutionWhereInput
    some?: TrainingPlanExecutionWhereInput
    none?: TrainingPlanExecutionWhereInput
  }

  export type TrainingPlanExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    phaseOverview?: SortOrder
    weeklyMileagePlan?: SortOrder
    weeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanAvgOrderByAggregateInput = {
    baselineWeeklyMileage?: SortOrder
    totalWeeks?: SortOrder
  }

  export type TrainingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    raceId?: SortOrder
    goalTime?: SortOrder
    goalPace?: SortOrder
    baseline5k?: SortOrder
    baselineWeeklyMileage?: SortOrder
    startDate?: SortOrder
    totalWeeks?: SortOrder
    adaptive5kTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanSumOrderByAggregateInput = {
    baselineWeeklyMileage?: SortOrder
    totalWeeks?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TrainingPlanScalarRelationFilter = {
    is?: TrainingPlanWhereInput
    isNot?: TrainingPlanWhereInput
  }

  export type TrainingDayPlannedTrainingPlanIdWeekIndexDayIndexCompoundUniqueInput = {
    trainingPlanId: string
    weekIndex: number
    dayIndex: number
  }

  export type TrainingDayPlannedCountOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    plannedData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedAvgOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type TrainingDayPlannedMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedMinOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    athleteId?: SortOrder
    date?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    dayName?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayPlannedSumOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TrainingPlanExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    trainingPlanId?: SortOrder
    startedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingPlanExecutionScalarRelationFilter = {
    is?: TrainingPlanExecutionWhereInput
    isNot?: TrainingPlanExecutionWhereInput
  }

  export type TrainingDayExecutedExecutionIdDateCompoundUniqueInput = {
    executionId: string
    date: Date | string
  }

  export type TrainingDayExecutedCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    plannedData?: SortOrder
    analysis?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedAvgOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type TrainingDayExecutedMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    athleteId?: SortOrder
    activityId?: SortOrder
    weekIndex?: SortOrder
    dayIndex?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDayExecutedSumOrderByAggregateInput = {
    weekIndex?: SortOrder
    dayIndex?: SortOrder
  }

  export type FounderTaskListRelationFilter = {
    every?: FounderTaskWhereInput
    some?: FounderTaskWhereInput
    none?: FounderTaskWhereInput
  }

  export type CrmContactListRelationFilter = {
    every?: CrmContactWhereInput
    some?: CrmContactWhereInput
    none?: CrmContactWhereInput
  }

  export type RoadmapItemListRelationFilter = {
    every?: RoadmapItemWhereInput
    some?: RoadmapItemWhereInput
    none?: RoadmapItemWhereInput
  }

  export type CompanyFounderListRelationFilter = {
    every?: CompanyFounderWhereInput
    some?: CompanyFounderWhereInput
    none?: CompanyFounderWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type FounderTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrmContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyFounderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FounderCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderScalarRelationFilter = {
    is?: FounderWhereInput
    isNot?: FounderWhereInput
  }

  export type FounderTaskCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderTaskMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    company?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    roadmapType?: SortOrder
    quarter?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyEmployeeListRelationFilter = {
    every?: CompanyEmployeeWhereInput
    some?: CompanyEmployeeWhereInput
    none?: CompanyEmployeeWhereInput
  }

  export type CompanyRoadmapItemListRelationFilter = {
    every?: CompanyRoadmapItemWhereInput
    some?: CompanyRoadmapItemWhereInput
    none?: CompanyRoadmapItemWhereInput
  }

  export type CompanyCrmContactListRelationFilter = {
    every?: CompanyCrmContactWhereInput
    some?: CompanyCrmContactWhereInput
    none?: CompanyCrmContactWhereInput
  }

  export type CompanyFinancialSpendListRelationFilter = {
    every?: CompanyFinancialSpendWhereInput
    some?: CompanyFinancialSpendWhereInput
    none?: CompanyFinancialSpendWhereInput
  }

  export type CompanyFinancialProjectionListRelationFilter = {
    every?: CompanyFinancialProjectionWhereInput
    some?: CompanyFinancialProjectionWhereInput
    none?: CompanyFinancialProjectionWhereInput
  }

  export type CompanyEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyRoadmapItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCrmContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyFinancialSpendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyFinancialProjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyFounderCompanyIdFounderIdCompoundUniqueInput = {
    companyId: string
    founderId: string
  }

  export type CompanyFounderCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    founderId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type CompanyFounderMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    founderId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type CompanyFounderMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    founderId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type CompanyEmployeeCompanyIdEmailCompoundUniqueInput = {
    companyId: string
    email: string
  }

  export type CompanyEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    joinedAt?: SortOrder
  }

  export type CompanyEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    joinedAt?: SortOrder
  }

  export type CompanyEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    phoneNumber?: SortOrder
    joinedAt?: SortOrder
  }

  export type GoFastCompanyNullableScalarRelationFilter = {
    is?: GoFastCompanyWhereInput | null
    isNot?: GoFastCompanyWhereInput | null
  }

  export type CompanyRoadmapItemCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    itemType?: SortOrder
    parentArchitecture?: SortOrder
    roadmapType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    whatItDoes?: SortOrder
    howItHelps?: SortOrder
    fieldsData?: SortOrder
    howToGet?: SortOrder
    prerequisites?: SortOrder
    visual?: SortOrder
    orderNumber?: SortOrder
    hoursEstimated?: SortOrder
    hoursSpent?: SortOrder
    targetDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyRoadmapItemAvgOrderByAggregateInput = {
    orderNumber?: SortOrder
    hoursEstimated?: SortOrder
    hoursSpent?: SortOrder
  }

  export type CompanyRoadmapItemMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    itemType?: SortOrder
    parentArchitecture?: SortOrder
    roadmapType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    whatItDoes?: SortOrder
    howItHelps?: SortOrder
    fieldsData?: SortOrder
    howToGet?: SortOrder
    prerequisites?: SortOrder
    visual?: SortOrder
    orderNumber?: SortOrder
    hoursEstimated?: SortOrder
    hoursSpent?: SortOrder
    targetDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyRoadmapItemMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    itemType?: SortOrder
    parentArchitecture?: SortOrder
    roadmapType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    whatItDoes?: SortOrder
    howItHelps?: SortOrder
    fieldsData?: SortOrder
    howToGet?: SortOrder
    prerequisites?: SortOrder
    visual?: SortOrder
    orderNumber?: SortOrder
    hoursEstimated?: SortOrder
    hoursSpent?: SortOrder
    targetDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyRoadmapItemSumOrderByAggregateInput = {
    orderNumber?: SortOrder
    hoursEstimated?: SortOrder
    hoursSpent?: SortOrder
  }

  export type CompanyCrmContactCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyCrmContactMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyCrmContactMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    pipeline?: SortOrder
    status?: SortOrder
    nextStep?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyFinancialSpendCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    department?: SortOrder
    project?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialSpendAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CompanyFinancialSpendMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    department?: SortOrder
    project?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialSpendMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    department?: SortOrder
    project?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialSpendSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CompanyFinancialProjectionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    projectedRevenue?: SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrder
    categoryBreakdown?: SortOrder
    currentCash?: SortOrder
    monthlyBurnRate?: SortOrder
    runwayMonths?: SortOrder
    assumptions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialProjectionAvgOrderByAggregateInput = {
    projectedRevenue?: SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrder
    currentCash?: SortOrder
    monthlyBurnRate?: SortOrder
    runwayMonths?: SortOrder
  }

  export type CompanyFinancialProjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    projectedRevenue?: SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrder
    currentCash?: SortOrder
    monthlyBurnRate?: SortOrder
    runwayMonths?: SortOrder
    assumptions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialProjectionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    projectedRevenue?: SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrder
    currentCash?: SortOrder
    monthlyBurnRate?: SortOrder
    runwayMonths?: SortOrder
    assumptions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type CompanyFinancialProjectionSumOrderByAggregateInput = {
    projectedRevenue?: SortOrder
    projectedExpenses?: SortOrder
    projectedNet?: SortOrder
    currentCash?: SortOrder
    monthlyBurnRate?: SortOrder
    runwayMonths?: SortOrder
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    department?: SortOrder
    isTopPriority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    department?: SortOrder
    isTopPriority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    department?: SortOrder
    isTopPriority?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goFastCompanyId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    authorId?: SortOrder
    author?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    authorId?: SortOrder
    author?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    authorId?: SortOrder
    author?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyStaffListRelationFilter = {
    every?: CompanyStaffWhereInput
    some?: CompanyStaffWhereInput
    none?: CompanyStaffWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type PipelineListRelationFilter = {
    every?: PipelineWhereInput
    some?: PipelineWhereInput
    none?: PipelineWhereInput
  }

  export type PipelineConfigListRelationFilter = {
    every?: PipelineConfigWhereInput
    some?: PipelineConfigWhereInput
    none?: PipelineConfigWhereInput
  }

  export type ProductPipelineItemListRelationFilter = {
    every?: ProductPipelineItemWhereInput
    some?: ProductPipelineItemWhereInput
    none?: ProductPipelineItemWhereInput
  }

  export type CompanyStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductPipelineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoFastCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoFastCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoFastCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    website?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoFastCompanyScalarRelationFilter = {
    is?: GoFastCompanyWhereInput
    isNot?: GoFastCompanyWhereInput
  }

  export type CompanyStaffCountOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    photoURL?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    verificationCode?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    photoURL?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    verificationCode?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyStaffMinOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    photoURL?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    department?: SortOrder
    verificationCode?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    goesBy?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    goesBy?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    goesBy?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    athleteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type PipelineConfigScalarRelationFilter = {
    is?: PipelineConfigWhereInput
    isNot?: PipelineConfigWhereInput
  }

  export type PipelineContactIdConfigIdCompoundUniqueInput = {
    contactId: string
    configId: string
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactId?: SortOrder
    configId?: SortOrder
    stageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactId?: SortOrder
    configId?: SortOrder
    stageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactId?: SortOrder
    configId?: SortOrder
    stageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineConfigCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stages?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineConfigMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPipelineItemCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    timeItTakes?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPipelineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    timeItTakes?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPipelineItemMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    timeItTakes?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteActivityCreateNestedManyWithoutAthleteInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
  }

  export type RunCrewCreateNestedManyWithoutAdminInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
  }

  export type RunCrewMembershipCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewMessageCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput> | RunCrewMessageCreateWithoutAthleteInput[] | RunCrewMessageUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutAthleteInput | RunCrewMessageCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMessageCreateManyAthleteInputEnvelope
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
  }

  export type RunCrewAnnouncementCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput> | RunCrewAnnouncementCreateWithoutAuthorInput[] | RunCrewAnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutAuthorInput | RunCrewAnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: RunCrewAnnouncementCreateManyAuthorInputEnvelope
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
  }

  export type RunCrewLeaderboardCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RunCrewRunCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput> | RunCrewRunCreateWithoutCreatedByInput[] | RunCrewRunUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutCreatedByInput | RunCrewRunCreateOrConnectWithoutCreatedByInput[]
    createMany?: RunCrewRunCreateManyCreatedByInputEnvelope
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
  }

  export type RunCrewRunRSVPCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput> | RunCrewRunRSVPCreateWithoutAthleteInput[] | RunCrewRunRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutAthleteInput | RunCrewRunRSVPCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewRunRSVPCreateManyAthleteInputEnvelope
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
  }

  export type RunCrewEventCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput> | RunCrewEventCreateWithoutOrganizerInput[] | RunCrewEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutOrganizerInput | RunCrewEventCreateOrConnectWithoutOrganizerInput[]
    createMany?: RunCrewEventCreateManyOrganizerInputEnvelope
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
  }

  export type RunCrewEventRSVPCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput> | RunCrewEventRSVPCreateWithoutAthleteInput[] | RunCrewEventRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutAthleteInput | RunCrewEventRSVPCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewEventRSVPCreateManyAthleteInputEnvelope
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
  }

  export type RunCrewManagerCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput> | RunCrewManagerCreateWithoutAthleteInput[] | RunCrewManagerUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutAthleteInput | RunCrewManagerCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewManagerCreateManyAthleteInputEnvelope
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
  }

  export type RaceCreateNestedManyWithoutCreatedByAthleteInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type TrainingPlanCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingDayPlannedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingDayExecutedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type FounderCreateNestedOneWithoutAthleteInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    connect?: FounderWhereUniqueInput
  }

  export type AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
  }

  export type RunCrewUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
  }

  export type RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput> | RunCrewMessageCreateWithoutAthleteInput[] | RunCrewMessageUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutAthleteInput | RunCrewMessageCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewMessageCreateManyAthleteInputEnvelope
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
  }

  export type RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput> | RunCrewAnnouncementCreateWithoutAuthorInput[] | RunCrewAnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutAuthorInput | RunCrewAnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: RunCrewAnnouncementCreateManyAuthorInputEnvelope
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
  }

  export type RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput> | RunCrewRunCreateWithoutCreatedByInput[] | RunCrewRunUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutCreatedByInput | RunCrewRunCreateOrConnectWithoutCreatedByInput[]
    createMany?: RunCrewRunCreateManyCreatedByInputEnvelope
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
  }

  export type RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput> | RunCrewRunRSVPCreateWithoutAthleteInput[] | RunCrewRunRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutAthleteInput | RunCrewRunRSVPCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewRunRSVPCreateManyAthleteInputEnvelope
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
  }

  export type RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput> | RunCrewEventCreateWithoutOrganizerInput[] | RunCrewEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutOrganizerInput | RunCrewEventCreateOrConnectWithoutOrganizerInput[]
    createMany?: RunCrewEventCreateManyOrganizerInputEnvelope
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
  }

  export type RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput> | RunCrewEventRSVPCreateWithoutAthleteInput[] | RunCrewEventRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutAthleteInput | RunCrewEventRSVPCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewEventRSVPCreateManyAthleteInputEnvelope
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
  }

  export type RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput> | RunCrewManagerCreateWithoutAthleteInput[] | RunCrewManagerUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutAthleteInput | RunCrewManagerCreateOrConnectWithoutAthleteInput[]
    createMany?: RunCrewManagerCreateManyAthleteInputEnvelope
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
  }

  export type RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type FounderUncheckedCreateNestedOneWithoutAthleteInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    connect?: FounderWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AthleteActivityUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    upsert?: AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput | AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    set?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    disconnect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    delete?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    update?: AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput | AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: AthleteActivityUpdateManyWithWhereWithoutAthleteInput | AthleteActivityUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
  }

  export type RunCrewUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    upsert?: RunCrewUpsertWithWhereUniqueWithoutAdminInput | RunCrewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    set?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    disconnect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    delete?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    update?: RunCrewUpdateWithWhereUniqueWithoutAdminInput | RunCrewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RunCrewUpdateManyWithWhereWithoutAdminInput | RunCrewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
  }

  export type RunCrewMembershipUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput | RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewMessageUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput> | RunCrewMessageCreateWithoutAthleteInput[] | RunCrewMessageUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutAthleteInput | RunCrewMessageCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMessageUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMessageUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMessageCreateManyAthleteInputEnvelope
    set?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    disconnect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    delete?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    update?: RunCrewMessageUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMessageUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMessageUpdateManyWithWhereWithoutAthleteInput | RunCrewMessageUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
  }

  export type RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput> | RunCrewAnnouncementCreateWithoutAuthorInput[] | RunCrewAnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutAuthorInput | RunCrewAnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: RunCrewAnnouncementUpsertWithWhereUniqueWithoutAuthorInput | RunCrewAnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RunCrewAnnouncementCreateManyAuthorInputEnvelope
    set?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    disconnect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    delete?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    update?: RunCrewAnnouncementUpdateWithWhereUniqueWithoutAuthorInput | RunCrewAnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RunCrewAnnouncementUpdateManyWithWhereWithoutAuthorInput | RunCrewAnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
  }

  export type RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput | RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewRunUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput> | RunCrewRunCreateWithoutCreatedByInput[] | RunCrewRunUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutCreatedByInput | RunCrewRunCreateOrConnectWithoutCreatedByInput[]
    upsert?: RunCrewRunUpsertWithWhereUniqueWithoutCreatedByInput | RunCrewRunUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RunCrewRunCreateManyCreatedByInputEnvelope
    set?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    disconnect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    delete?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    update?: RunCrewRunUpdateWithWhereUniqueWithoutCreatedByInput | RunCrewRunUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RunCrewRunUpdateManyWithWhereWithoutCreatedByInput | RunCrewRunUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
  }

  export type RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput> | RunCrewRunRSVPCreateWithoutAthleteInput[] | RunCrewRunRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutAthleteInput | RunCrewRunRSVPCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewRunRSVPUpsertWithWhereUniqueWithoutAthleteInput | RunCrewRunRSVPUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewRunRSVPCreateManyAthleteInputEnvelope
    set?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    disconnect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    delete?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    update?: RunCrewRunRSVPUpdateWithWhereUniqueWithoutAthleteInput | RunCrewRunRSVPUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewRunRSVPUpdateManyWithWhereWithoutAthleteInput | RunCrewRunRSVPUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
  }

  export type RunCrewEventUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput> | RunCrewEventCreateWithoutOrganizerInput[] | RunCrewEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutOrganizerInput | RunCrewEventCreateOrConnectWithoutOrganizerInput[]
    upsert?: RunCrewEventUpsertWithWhereUniqueWithoutOrganizerInput | RunCrewEventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: RunCrewEventCreateManyOrganizerInputEnvelope
    set?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    disconnect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    delete?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    update?: RunCrewEventUpdateWithWhereUniqueWithoutOrganizerInput | RunCrewEventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: RunCrewEventUpdateManyWithWhereWithoutOrganizerInput | RunCrewEventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
  }

  export type RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput> | RunCrewEventRSVPCreateWithoutAthleteInput[] | RunCrewEventRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutAthleteInput | RunCrewEventRSVPCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewEventRSVPUpsertWithWhereUniqueWithoutAthleteInput | RunCrewEventRSVPUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewEventRSVPCreateManyAthleteInputEnvelope
    set?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    disconnect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    delete?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    update?: RunCrewEventRSVPUpdateWithWhereUniqueWithoutAthleteInput | RunCrewEventRSVPUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewEventRSVPUpdateManyWithWhereWithoutAthleteInput | RunCrewEventRSVPUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
  }

  export type RunCrewManagerUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput> | RunCrewManagerCreateWithoutAthleteInput[] | RunCrewManagerUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutAthleteInput | RunCrewManagerCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewManagerUpsertWithWhereUniqueWithoutAthleteInput | RunCrewManagerUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewManagerCreateManyAthleteInputEnvelope
    set?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    disconnect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    delete?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    update?: RunCrewManagerUpdateWithWhereUniqueWithoutAthleteInput | RunCrewManagerUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewManagerUpdateManyWithWhereWithoutAthleteInput | RunCrewManagerUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
  }

  export type RaceUpdateManyWithoutCreatedByAthleteNestedInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutCreatedByAthleteInput | RaceUpdateManyWithWhereWithoutCreatedByAthleteInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type TrainingPlanUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput | TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput | TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutAthleteInput | TrainingPlanUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingDayPlannedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput | TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingDayExecutedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput | TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type FounderUpdateOneWithoutAthleteNestedInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    upsert?: FounderUpsertWithoutAthleteInput
    disconnect?: FounderWhereInput | boolean
    delete?: FounderWhereInput | boolean
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutAthleteInput, FounderUpdateWithoutAthleteInput>, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput> | AthleteActivityCreateWithoutAthleteInput[] | AthleteActivityUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: AthleteActivityCreateOrConnectWithoutAthleteInput | AthleteActivityCreateOrConnectWithoutAthleteInput[]
    upsert?: AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput | AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: AthleteActivityCreateManyAthleteInputEnvelope
    set?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    disconnect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    delete?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    connect?: AthleteActivityWhereUniqueInput | AthleteActivityWhereUniqueInput[]
    update?: AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput | AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: AthleteActivityUpdateManyWithWhereWithoutAthleteInput | AthleteActivityUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
  }

  export type RunCrewUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput> | RunCrewCreateWithoutAdminInput[] | RunCrewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RunCrewCreateOrConnectWithoutAdminInput | RunCrewCreateOrConnectWithoutAdminInput[]
    upsert?: RunCrewUpsertWithWhereUniqueWithoutAdminInput | RunCrewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RunCrewCreateManyAdminInputEnvelope
    set?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    disconnect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    delete?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    connect?: RunCrewWhereUniqueInput | RunCrewWhereUniqueInput[]
    update?: RunCrewUpdateWithWhereUniqueWithoutAdminInput | RunCrewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RunCrewUpdateManyWithWhereWithoutAdminInput | RunCrewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput> | RunCrewMembershipCreateWithoutAthleteInput[] | RunCrewMembershipUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutAthleteInput | RunCrewMembershipCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMembershipCreateManyAthleteInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput | RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput> | RunCrewMessageCreateWithoutAthleteInput[] | RunCrewMessageUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutAthleteInput | RunCrewMessageCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewMessageUpsertWithWhereUniqueWithoutAthleteInput | RunCrewMessageUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewMessageCreateManyAthleteInputEnvelope
    set?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    disconnect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    delete?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    update?: RunCrewMessageUpdateWithWhereUniqueWithoutAthleteInput | RunCrewMessageUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewMessageUpdateManyWithWhereWithoutAthleteInput | RunCrewMessageUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
  }

  export type RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput> | RunCrewAnnouncementCreateWithoutAuthorInput[] | RunCrewAnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutAuthorInput | RunCrewAnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: RunCrewAnnouncementUpsertWithWhereUniqueWithoutAuthorInput | RunCrewAnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RunCrewAnnouncementCreateManyAuthorInputEnvelope
    set?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    disconnect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    delete?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    update?: RunCrewAnnouncementUpdateWithWhereUniqueWithoutAuthorInput | RunCrewAnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RunCrewAnnouncementUpdateManyWithWhereWithoutAuthorInput | RunCrewAnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput> | RunCrewLeaderboardCreateWithoutAthleteInput[] | RunCrewLeaderboardUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutAthleteInput | RunCrewLeaderboardCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewLeaderboardCreateManyAthleteInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput | RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput> | RunCrewRunCreateWithoutCreatedByInput[] | RunCrewRunUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutCreatedByInput | RunCrewRunCreateOrConnectWithoutCreatedByInput[]
    upsert?: RunCrewRunUpsertWithWhereUniqueWithoutCreatedByInput | RunCrewRunUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RunCrewRunCreateManyCreatedByInputEnvelope
    set?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    disconnect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    delete?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    update?: RunCrewRunUpdateWithWhereUniqueWithoutCreatedByInput | RunCrewRunUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RunCrewRunUpdateManyWithWhereWithoutCreatedByInput | RunCrewRunUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
  }

  export type RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput> | RunCrewRunRSVPCreateWithoutAthleteInput[] | RunCrewRunRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutAthleteInput | RunCrewRunRSVPCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewRunRSVPUpsertWithWhereUniqueWithoutAthleteInput | RunCrewRunRSVPUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewRunRSVPCreateManyAthleteInputEnvelope
    set?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    disconnect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    delete?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    update?: RunCrewRunRSVPUpdateWithWhereUniqueWithoutAthleteInput | RunCrewRunRSVPUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewRunRSVPUpdateManyWithWhereWithoutAthleteInput | RunCrewRunRSVPUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
  }

  export type RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput> | RunCrewEventCreateWithoutOrganizerInput[] | RunCrewEventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutOrganizerInput | RunCrewEventCreateOrConnectWithoutOrganizerInput[]
    upsert?: RunCrewEventUpsertWithWhereUniqueWithoutOrganizerInput | RunCrewEventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: RunCrewEventCreateManyOrganizerInputEnvelope
    set?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    disconnect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    delete?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    update?: RunCrewEventUpdateWithWhereUniqueWithoutOrganizerInput | RunCrewEventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: RunCrewEventUpdateManyWithWhereWithoutOrganizerInput | RunCrewEventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
  }

  export type RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput> | RunCrewEventRSVPCreateWithoutAthleteInput[] | RunCrewEventRSVPUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutAthleteInput | RunCrewEventRSVPCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewEventRSVPUpsertWithWhereUniqueWithoutAthleteInput | RunCrewEventRSVPUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewEventRSVPCreateManyAthleteInputEnvelope
    set?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    disconnect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    delete?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    update?: RunCrewEventRSVPUpdateWithWhereUniqueWithoutAthleteInput | RunCrewEventRSVPUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewEventRSVPUpdateManyWithWhereWithoutAthleteInput | RunCrewEventRSVPUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
  }

  export type RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput> | RunCrewManagerCreateWithoutAthleteInput[] | RunCrewManagerUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutAthleteInput | RunCrewManagerCreateOrConnectWithoutAthleteInput[]
    upsert?: RunCrewManagerUpsertWithWhereUniqueWithoutAthleteInput | RunCrewManagerUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: RunCrewManagerCreateManyAthleteInputEnvelope
    set?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    disconnect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    delete?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    update?: RunCrewManagerUpdateWithWhereUniqueWithoutAthleteInput | RunCrewManagerUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: RunCrewManagerUpdateManyWithWhereWithoutAthleteInput | RunCrewManagerUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
  }

  export type RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput = {
    create?: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput> | RaceCreateWithoutCreatedByAthleteInput[] | RaceUncheckedCreateWithoutCreatedByAthleteInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutCreatedByAthleteInput | RaceCreateOrConnectWithoutCreatedByAthleteInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput[]
    createMany?: RaceCreateManyCreatedByAthleteInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput | RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutCreatedByAthleteInput | RaceUpdateManyWithWhereWithoutCreatedByAthleteInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput> | TrainingPlanCreateWithoutAthleteInput[] | TrainingPlanUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutAthleteInput | TrainingPlanCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput | TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingPlanCreateManyAthleteInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput | TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutAthleteInput | TrainingPlanUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput> | TrainingDayPlannedCreateWithoutAthleteInput[] | TrainingDayPlannedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutAthleteInput | TrainingDayPlannedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayPlannedCreateManyAthleteInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput | TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput> | TrainingDayExecutedCreateWithoutAthleteInput[] | TrainingDayExecutedUncheckedCreateWithoutAthleteInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutAthleteInput | TrainingDayExecutedCreateOrConnectWithoutAthleteInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput[]
    createMany?: TrainingDayExecutedCreateManyAthleteInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput | TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type FounderUncheckedUpdateOneWithoutAthleteNestedInput = {
    create?: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    connectOrCreate?: FounderCreateOrConnectWithoutAthleteInput
    upsert?: FounderUpsertWithoutAthleteInput
    disconnect?: FounderWhereInput | boolean
    delete?: FounderWhereInput | boolean
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutAthleteInput, FounderUpdateWithoutAthleteInput>, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutActivitiesInput
    connect?: AthleteWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AthleteUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutActivitiesInput
    upsert?: AthleteUpsertWithoutActivitiesInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutActivitiesInput, AthleteUpdateWithoutActivitiesInput>, AthleteUncheckedUpdateWithoutActivitiesInput>
  }

  export type AthleteCreateNestedOneWithoutAdminRunCrewsInput = {
    create?: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutAdminRunCrewsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewMembershipCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewMessageCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput> | RunCrewMessageCreateWithoutRunCrewInput[] | RunCrewMessageUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutRunCrewInput | RunCrewMessageCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMessageCreateManyRunCrewInputEnvelope
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
  }

  export type RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput> | RunCrewAnnouncementCreateWithoutRunCrewInput[] | RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput | RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewAnnouncementCreateManyRunCrewInputEnvelope
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
  }

  export type RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RunCrewRunCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput> | RunCrewRunCreateWithoutRunCrewInput[] | RunCrewRunUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRunCrewInput | RunCrewRunCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewRunCreateManyRunCrewInputEnvelope
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
  }

  export type RunCrewEventCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput> | RunCrewEventCreateWithoutRunCrewInput[] | RunCrewEventUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRunCrewInput | RunCrewEventCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewEventCreateManyRunCrewInputEnvelope
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
  }

  export type RunCrewManagerCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput> | RunCrewManagerCreateWithoutRunCrewInput[] | RunCrewManagerUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutRunCrewInput | RunCrewManagerCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewManagerCreateManyRunCrewInputEnvelope
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
  }

  export type RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
  }

  export type RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput> | RunCrewMessageCreateWithoutRunCrewInput[] | RunCrewMessageUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutRunCrewInput | RunCrewMessageCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewMessageCreateManyRunCrewInputEnvelope
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
  }

  export type RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput> | RunCrewAnnouncementCreateWithoutRunCrewInput[] | RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput | RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewAnnouncementCreateManyRunCrewInputEnvelope
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
  }

  export type RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
  }

  export type RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput> | RunCrewRunCreateWithoutRunCrewInput[] | RunCrewRunUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRunCrewInput | RunCrewRunCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewRunCreateManyRunCrewInputEnvelope
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
  }

  export type RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput> | RunCrewEventCreateWithoutRunCrewInput[] | RunCrewEventUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRunCrewInput | RunCrewEventCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewEventCreateManyRunCrewInputEnvelope
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
  }

  export type RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput = {
    create?: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput> | RunCrewManagerCreateWithoutRunCrewInput[] | RunCrewManagerUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutRunCrewInput | RunCrewManagerCreateOrConnectWithoutRunCrewInput[]
    createMany?: RunCrewManagerCreateManyRunCrewInputEnvelope
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
  }

  export type AthleteUpdateOneWithoutAdminRunCrewsNestedInput = {
    create?: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutAdminRunCrewsInput
    upsert?: AthleteUpsertWithoutAdminRunCrewsInput
    disconnect?: AthleteWhereInput | boolean
    delete?: AthleteWhereInput | boolean
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutAdminRunCrewsInput, AthleteUpdateWithoutAdminRunCrewsInput>, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
  }

  export type RunCrewMembershipUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput | RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewMessageUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput> | RunCrewMessageCreateWithoutRunCrewInput[] | RunCrewMessageUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutRunCrewInput | RunCrewMessageCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMessageUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMessageUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMessageCreateManyRunCrewInputEnvelope
    set?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    disconnect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    delete?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    update?: RunCrewMessageUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMessageUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMessageUpdateManyWithWhereWithoutRunCrewInput | RunCrewMessageUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
  }

  export type RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput> | RunCrewAnnouncementCreateWithoutRunCrewInput[] | RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput | RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewAnnouncementUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewAnnouncementUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewAnnouncementCreateManyRunCrewInputEnvelope
    set?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    disconnect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    delete?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    update?: RunCrewAnnouncementUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewAnnouncementUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewAnnouncementUpdateManyWithWhereWithoutRunCrewInput | RunCrewAnnouncementUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
  }

  export type RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput | RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewRunUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput> | RunCrewRunCreateWithoutRunCrewInput[] | RunCrewRunUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRunCrewInput | RunCrewRunCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewRunUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewRunUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewRunCreateManyRunCrewInputEnvelope
    set?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    disconnect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    delete?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    update?: RunCrewRunUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewRunUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewRunUpdateManyWithWhereWithoutRunCrewInput | RunCrewRunUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
  }

  export type RunCrewEventUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput> | RunCrewEventCreateWithoutRunCrewInput[] | RunCrewEventUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRunCrewInput | RunCrewEventCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewEventUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewEventUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewEventCreateManyRunCrewInputEnvelope
    set?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    disconnect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    delete?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    update?: RunCrewEventUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewEventUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewEventUpdateManyWithWhereWithoutRunCrewInput | RunCrewEventUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
  }

  export type RunCrewManagerUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput> | RunCrewManagerCreateWithoutRunCrewInput[] | RunCrewManagerUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutRunCrewInput | RunCrewManagerCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewManagerUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewManagerUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewManagerCreateManyRunCrewInputEnvelope
    set?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    disconnect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    delete?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    update?: RunCrewManagerUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewManagerUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewManagerUpdateManyWithWhereWithoutRunCrewInput | RunCrewManagerUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput> | RunCrewMembershipCreateWithoutRunCrewInput[] | RunCrewMembershipUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMembershipCreateOrConnectWithoutRunCrewInput | RunCrewMembershipCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMembershipCreateManyRunCrewInputEnvelope
    set?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    disconnect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    delete?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    connect?: RunCrewMembershipWhereUniqueInput | RunCrewMembershipWhereUniqueInput[]
    update?: RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput | RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
  }

  export type RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput> | RunCrewMessageCreateWithoutRunCrewInput[] | RunCrewMessageUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewMessageCreateOrConnectWithoutRunCrewInput | RunCrewMessageCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewMessageUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewMessageUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewMessageCreateManyRunCrewInputEnvelope
    set?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    disconnect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    delete?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    connect?: RunCrewMessageWhereUniqueInput | RunCrewMessageWhereUniqueInput[]
    update?: RunCrewMessageUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewMessageUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewMessageUpdateManyWithWhereWithoutRunCrewInput | RunCrewMessageUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
  }

  export type RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput> | RunCrewAnnouncementCreateWithoutRunCrewInput[] | RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput | RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewAnnouncementUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewAnnouncementUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewAnnouncementCreateManyRunCrewInputEnvelope
    set?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    disconnect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    delete?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    connect?: RunCrewAnnouncementWhereUniqueInput | RunCrewAnnouncementWhereUniqueInput[]
    update?: RunCrewAnnouncementUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewAnnouncementUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewAnnouncementUpdateManyWithWhereWithoutRunCrewInput | RunCrewAnnouncementUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput> | RunCrewLeaderboardCreateWithoutRunCrewInput[] | RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput | RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewLeaderboardCreateManyRunCrewInputEnvelope
    set?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    disconnect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    delete?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    connect?: RunCrewLeaderboardWhereUniqueInput | RunCrewLeaderboardWhereUniqueInput[]
    update?: RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput | RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
  }

  export type RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput> | RunCrewRunCreateWithoutRunCrewInput[] | RunCrewRunUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRunCrewInput | RunCrewRunCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewRunUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewRunUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewRunCreateManyRunCrewInputEnvelope
    set?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    disconnect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    delete?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    connect?: RunCrewRunWhereUniqueInput | RunCrewRunWhereUniqueInput[]
    update?: RunCrewRunUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewRunUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewRunUpdateManyWithWhereWithoutRunCrewInput | RunCrewRunUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
  }

  export type RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput> | RunCrewEventCreateWithoutRunCrewInput[] | RunCrewEventUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRunCrewInput | RunCrewEventCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewEventUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewEventUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewEventCreateManyRunCrewInputEnvelope
    set?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    disconnect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    delete?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    connect?: RunCrewEventWhereUniqueInput | RunCrewEventWhereUniqueInput[]
    update?: RunCrewEventUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewEventUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewEventUpdateManyWithWhereWithoutRunCrewInput | RunCrewEventUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
  }

  export type RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput = {
    create?: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput> | RunCrewManagerCreateWithoutRunCrewInput[] | RunCrewManagerUncheckedCreateWithoutRunCrewInput[]
    connectOrCreate?: RunCrewManagerCreateOrConnectWithoutRunCrewInput | RunCrewManagerCreateOrConnectWithoutRunCrewInput[]
    upsert?: RunCrewManagerUpsertWithWhereUniqueWithoutRunCrewInput | RunCrewManagerUpsertWithWhereUniqueWithoutRunCrewInput[]
    createMany?: RunCrewManagerCreateManyRunCrewInputEnvelope
    set?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    disconnect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    delete?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    connect?: RunCrewManagerWhereUniqueInput | RunCrewManagerWhereUniqueInput[]
    update?: RunCrewManagerUpdateWithWhereUniqueWithoutRunCrewInput | RunCrewManagerUpdateWithWhereUniqueWithoutRunCrewInput[]
    updateMany?: RunCrewManagerUpdateManyWithWhereWithoutRunCrewInput | RunCrewManagerUpdateManyWithWhereWithoutRunCrewInput[]
    deleteMany?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
  }

  export type RunCrewCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMembershipsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewMembershipsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMembershipsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMembershipsInput
    upsert?: RunCrewUpsertWithoutMembershipsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutMembershipsInput, RunCrewUpdateWithoutMembershipsInput>, RunCrewUncheckedUpdateWithoutMembershipsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMembershipsInput
    upsert?: AthleteUpsertWithoutRunCrewMembershipsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewMembershipsInput, AthleteUpdateWithoutRunCrewMembershipsInput>, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
  }

  export type RunCrewCreateNestedOneWithoutMessagesInput = {
    create?: XOR<RunCrewCreateWithoutMessagesInput, RunCrewUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMessagesInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewMessagesInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMessagesInput, AthleteUncheckedCreateWithoutRunCrewMessagesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMessagesInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<RunCrewCreateWithoutMessagesInput, RunCrewUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutMessagesInput
    upsert?: RunCrewUpsertWithoutMessagesInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutMessagesInput, RunCrewUpdateWithoutMessagesInput>, RunCrewUncheckedUpdateWithoutMessagesInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewMessagesNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewMessagesInput, AthleteUncheckedCreateWithoutRunCrewMessagesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewMessagesInput
    upsert?: AthleteUpsertWithoutRunCrewMessagesInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewMessagesInput, AthleteUpdateWithoutRunCrewMessagesInput>, AthleteUncheckedUpdateWithoutRunCrewMessagesInput>
  }

  export type RunCrewCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<RunCrewCreateWithoutAnnouncementsInput, RunCrewUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutAnnouncementsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewAnnouncementsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewAnnouncementsInput, AthleteUncheckedCreateWithoutRunCrewAnnouncementsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewAnnouncementsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<RunCrewCreateWithoutAnnouncementsInput, RunCrewUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutAnnouncementsInput
    upsert?: RunCrewUpsertWithoutAnnouncementsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutAnnouncementsInput, RunCrewUpdateWithoutAnnouncementsInput>, RunCrewUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewAnnouncementsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewAnnouncementsInput, AthleteUncheckedCreateWithoutRunCrewAnnouncementsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewAnnouncementsInput
    upsert?: AthleteUpsertWithoutRunCrewAnnouncementsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewAnnouncementsInput, AthleteUpdateWithoutRunCrewAnnouncementsInput>, AthleteUncheckedUpdateWithoutRunCrewAnnouncementsInput>
  }

  export type RunCrewCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput
    connect?: AthleteWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: RunCrewUpsertWithoutLeaderboardEntriesInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutLeaderboardEntriesInput, RunCrewUpdateWithoutLeaderboardEntriesInput>, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput
    upsert?: AthleteUpsertWithoutRunCrewLeaderboardsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewLeaderboardsInput, AthleteUpdateWithoutRunCrewLeaderboardsInput>, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
  }

  export type RunCrewCreateNestedOneWithoutRunsInput = {
    create?: XOR<RunCrewCreateWithoutRunsInput, RunCrewUncheckedCreateWithoutRunsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutRunsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewRunsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewRunsInput, AthleteUncheckedCreateWithoutRunCrewRunsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewRunsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewRunRSVPCreateNestedManyWithoutRunInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput> | RunCrewRunRSVPCreateWithoutRunInput[] | RunCrewRunRSVPUncheckedCreateWithoutRunInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutRunInput | RunCrewRunRSVPCreateOrConnectWithoutRunInput[]
    createMany?: RunCrewRunRSVPCreateManyRunInputEnvelope
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
  }

  export type RunCrewRunRSVPUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput> | RunCrewRunRSVPCreateWithoutRunInput[] | RunCrewRunRSVPUncheckedCreateWithoutRunInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutRunInput | RunCrewRunRSVPCreateOrConnectWithoutRunInput[]
    createMany?: RunCrewRunRSVPCreateManyRunInputEnvelope
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
  }

  export type RunCrewUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<RunCrewCreateWithoutRunsInput, RunCrewUncheckedCreateWithoutRunsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutRunsInput
    upsert?: RunCrewUpsertWithoutRunsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutRunsInput, RunCrewUpdateWithoutRunsInput>, RunCrewUncheckedUpdateWithoutRunsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewRunsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewRunsInput, AthleteUncheckedCreateWithoutRunCrewRunsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewRunsInput
    upsert?: AthleteUpsertWithoutRunCrewRunsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewRunsInput, AthleteUpdateWithoutRunCrewRunsInput>, AthleteUncheckedUpdateWithoutRunCrewRunsInput>
  }

  export type RunCrewRunRSVPUpdateManyWithoutRunNestedInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput> | RunCrewRunRSVPCreateWithoutRunInput[] | RunCrewRunRSVPUncheckedCreateWithoutRunInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutRunInput | RunCrewRunRSVPCreateOrConnectWithoutRunInput[]
    upsert?: RunCrewRunRSVPUpsertWithWhereUniqueWithoutRunInput | RunCrewRunRSVPUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: RunCrewRunRSVPCreateManyRunInputEnvelope
    set?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    disconnect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    delete?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    update?: RunCrewRunRSVPUpdateWithWhereUniqueWithoutRunInput | RunCrewRunRSVPUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: RunCrewRunRSVPUpdateManyWithWhereWithoutRunInput | RunCrewRunRSVPUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
  }

  export type RunCrewRunRSVPUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput> | RunCrewRunRSVPCreateWithoutRunInput[] | RunCrewRunRSVPUncheckedCreateWithoutRunInput[]
    connectOrCreate?: RunCrewRunRSVPCreateOrConnectWithoutRunInput | RunCrewRunRSVPCreateOrConnectWithoutRunInput[]
    upsert?: RunCrewRunRSVPUpsertWithWhereUniqueWithoutRunInput | RunCrewRunRSVPUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: RunCrewRunRSVPCreateManyRunInputEnvelope
    set?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    disconnect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    delete?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    connect?: RunCrewRunRSVPWhereUniqueInput | RunCrewRunRSVPWhereUniqueInput[]
    update?: RunCrewRunRSVPUpdateWithWhereUniqueWithoutRunInput | RunCrewRunRSVPUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: RunCrewRunRSVPUpdateManyWithWhereWithoutRunInput | RunCrewRunRSVPUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
  }

  export type RunCrewRunCreateNestedOneWithoutRsvpsInput = {
    create?: XOR<RunCrewRunCreateWithoutRsvpsInput, RunCrewRunUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRsvpsInput
    connect?: RunCrewRunWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewRunRSVPsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewRunRSVPsInput, AthleteUncheckedCreateWithoutRunCrewRunRSVPsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewRunRSVPsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewRunUpdateOneRequiredWithoutRsvpsNestedInput = {
    create?: XOR<RunCrewRunCreateWithoutRsvpsInput, RunCrewRunUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: RunCrewRunCreateOrConnectWithoutRsvpsInput
    upsert?: RunCrewRunUpsertWithoutRsvpsInput
    connect?: RunCrewRunWhereUniqueInput
    update?: XOR<XOR<RunCrewRunUpdateToOneWithWhereWithoutRsvpsInput, RunCrewRunUpdateWithoutRsvpsInput>, RunCrewRunUncheckedUpdateWithoutRsvpsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewRunRSVPsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewRunRSVPsInput, AthleteUncheckedCreateWithoutRunCrewRunRSVPsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewRunRSVPsInput
    upsert?: AthleteUpsertWithoutRunCrewRunRSVPsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewRunRSVPsInput, AthleteUpdateWithoutRunCrewRunRSVPsInput>, AthleteUncheckedUpdateWithoutRunCrewRunRSVPsInput>
  }

  export type RunCrewCreateNestedOneWithoutEventsInput = {
    create?: XOR<RunCrewCreateWithoutEventsInput, RunCrewUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutEventsInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewEventsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewEventsInput, AthleteUncheckedCreateWithoutRunCrewEventsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewEventsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewEventRSVPCreateNestedManyWithoutEventInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput> | RunCrewEventRSVPCreateWithoutEventInput[] | RunCrewEventRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutEventInput | RunCrewEventRSVPCreateOrConnectWithoutEventInput[]
    createMany?: RunCrewEventRSVPCreateManyEventInputEnvelope
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
  }

  export type RunCrewEventRSVPUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput> | RunCrewEventRSVPCreateWithoutEventInput[] | RunCrewEventRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutEventInput | RunCrewEventRSVPCreateOrConnectWithoutEventInput[]
    createMany?: RunCrewEventRSVPCreateManyEventInputEnvelope
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
  }

  export type RunCrewUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<RunCrewCreateWithoutEventsInput, RunCrewUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutEventsInput
    upsert?: RunCrewUpsertWithoutEventsInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutEventsInput, RunCrewUpdateWithoutEventsInput>, RunCrewUncheckedUpdateWithoutEventsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewEventsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewEventsInput, AthleteUncheckedCreateWithoutRunCrewEventsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewEventsInput
    upsert?: AthleteUpsertWithoutRunCrewEventsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewEventsInput, AthleteUpdateWithoutRunCrewEventsInput>, AthleteUncheckedUpdateWithoutRunCrewEventsInput>
  }

  export type RunCrewEventRSVPUpdateManyWithoutEventNestedInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput> | RunCrewEventRSVPCreateWithoutEventInput[] | RunCrewEventRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutEventInput | RunCrewEventRSVPCreateOrConnectWithoutEventInput[]
    upsert?: RunCrewEventRSVPUpsertWithWhereUniqueWithoutEventInput | RunCrewEventRSVPUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: RunCrewEventRSVPCreateManyEventInputEnvelope
    set?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    disconnect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    delete?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    update?: RunCrewEventRSVPUpdateWithWhereUniqueWithoutEventInput | RunCrewEventRSVPUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: RunCrewEventRSVPUpdateManyWithWhereWithoutEventInput | RunCrewEventRSVPUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
  }

  export type RunCrewEventRSVPUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput> | RunCrewEventRSVPCreateWithoutEventInput[] | RunCrewEventRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: RunCrewEventRSVPCreateOrConnectWithoutEventInput | RunCrewEventRSVPCreateOrConnectWithoutEventInput[]
    upsert?: RunCrewEventRSVPUpsertWithWhereUniqueWithoutEventInput | RunCrewEventRSVPUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: RunCrewEventRSVPCreateManyEventInputEnvelope
    set?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    disconnect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    delete?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    connect?: RunCrewEventRSVPWhereUniqueInput | RunCrewEventRSVPWhereUniqueInput[]
    update?: RunCrewEventRSVPUpdateWithWhereUniqueWithoutEventInput | RunCrewEventRSVPUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: RunCrewEventRSVPUpdateManyWithWhereWithoutEventInput | RunCrewEventRSVPUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
  }

  export type RunCrewEventCreateNestedOneWithoutRsvpsInput = {
    create?: XOR<RunCrewEventCreateWithoutRsvpsInput, RunCrewEventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRsvpsInput
    connect?: RunCrewEventWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewEventRSVPsInput = {
    create?: XOR<AthleteCreateWithoutRunCrewEventRSVPsInput, AthleteUncheckedCreateWithoutRunCrewEventRSVPsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewEventRSVPsInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewEventUpdateOneRequiredWithoutRsvpsNestedInput = {
    create?: XOR<RunCrewEventCreateWithoutRsvpsInput, RunCrewEventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: RunCrewEventCreateOrConnectWithoutRsvpsInput
    upsert?: RunCrewEventUpsertWithoutRsvpsInput
    connect?: RunCrewEventWhereUniqueInput
    update?: XOR<XOR<RunCrewEventUpdateToOneWithWhereWithoutRsvpsInput, RunCrewEventUpdateWithoutRsvpsInput>, RunCrewEventUncheckedUpdateWithoutRsvpsInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewEventRSVPsNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewEventRSVPsInput, AthleteUncheckedCreateWithoutRunCrewEventRSVPsInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewEventRSVPsInput
    upsert?: AthleteUpsertWithoutRunCrewEventRSVPsInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewEventRSVPsInput, AthleteUpdateWithoutRunCrewEventRSVPsInput>, AthleteUncheckedUpdateWithoutRunCrewEventRSVPsInput>
  }

  export type RunCrewCreateNestedOneWithoutManagersInput = {
    create?: XOR<RunCrewCreateWithoutManagersInput, RunCrewUncheckedCreateWithoutManagersInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutManagersInput
    connect?: RunCrewWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutRunCrewManagersInput = {
    create?: XOR<AthleteCreateWithoutRunCrewManagersInput, AthleteUncheckedCreateWithoutRunCrewManagersInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewManagersInput
    connect?: AthleteWhereUniqueInput
  }

  export type RunCrewUpdateOneRequiredWithoutManagersNestedInput = {
    create?: XOR<RunCrewCreateWithoutManagersInput, RunCrewUncheckedCreateWithoutManagersInput>
    connectOrCreate?: RunCrewCreateOrConnectWithoutManagersInput
    upsert?: RunCrewUpsertWithoutManagersInput
    connect?: RunCrewWhereUniqueInput
    update?: XOR<XOR<RunCrewUpdateToOneWithWhereWithoutManagersInput, RunCrewUpdateWithoutManagersInput>, RunCrewUncheckedUpdateWithoutManagersInput>
  }

  export type AthleteUpdateOneRequiredWithoutRunCrewManagersNestedInput = {
    create?: XOR<AthleteCreateWithoutRunCrewManagersInput, AthleteUncheckedCreateWithoutRunCrewManagersInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutRunCrewManagersInput
    upsert?: AthleteUpsertWithoutRunCrewManagersInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutRunCrewManagersInput, AthleteUpdateWithoutRunCrewManagersInput>, AthleteUncheckedUpdateWithoutRunCrewManagersInput>
  }

  export type AthleteCreateNestedOneWithoutCreatedRacesInput = {
    create?: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutCreatedRacesInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanCreateNestedManyWithoutRaceInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type TrainingPlanUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
  }

  export type AthleteUpdateOneWithoutCreatedRacesNestedInput = {
    create?: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutCreatedRacesInput
    upsert?: AthleteUpsertWithoutCreatedRacesInput
    disconnect?: AthleteWhereInput | boolean
    delete?: AthleteWhereInput | boolean
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutCreatedRacesInput, AthleteUpdateWithoutCreatedRacesInput>, AthleteUncheckedUpdateWithoutCreatedRacesInput>
  }

  export type TrainingPlanUpdateManyWithoutRaceNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutRaceInput | TrainingPlanUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutRaceInput | TrainingPlanUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutRaceInput | TrainingPlanUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput> | TrainingPlanCreateWithoutRaceInput[] | TrainingPlanUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutRaceInput | TrainingPlanCreateOrConnectWithoutRaceInput[]
    upsert?: TrainingPlanUpsertWithWhereUniqueWithoutRaceInput | TrainingPlanUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: TrainingPlanCreateManyRaceInputEnvelope
    set?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    disconnect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    delete?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    connect?: TrainingPlanWhereUniqueInput | TrainingPlanWhereUniqueInput[]
    update?: TrainingPlanUpdateWithWhereUniqueWithoutRaceInput | TrainingPlanUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: TrainingPlanUpdateManyWithWhereWithoutRaceInput | TrainingPlanUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
  }

  export type AthleteCreateNestedOneWithoutTrainingPlansInput = {
    create?: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutTrainingPlansInput
    connect?: AthleteWhereUniqueInput
  }

  export type RaceCreateNestedOneWithoutTrainingPlansInput = {
    create?: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTrainingPlansInput
    connect?: RaceWhereUniqueInput
  }

  export type TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
  }

  export type TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
  }

  export type TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
  }

  export type AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput = {
    create?: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutTrainingPlansInput
    upsert?: AthleteUpsertWithoutTrainingPlansInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutTrainingPlansInput, AthleteUpdateWithoutTrainingPlansInput>, AthleteUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type RaceUpdateOneRequiredWithoutTrainingPlansNestedInput = {
    create?: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTrainingPlansInput
    upsert?: RaceUpsertWithoutTrainingPlansInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutTrainingPlansInput, RaceUpdateWithoutTrainingPlansInput>, RaceUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput | TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    set?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    disconnect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    delete?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    update?: TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput | TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput> | TrainingDayPlannedCreateWithoutTrainingPlanInput[] | TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput | TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingDayPlannedCreateManyTrainingPlanInputEnvelope
    set?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    disconnect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    delete?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    connect?: TrainingDayPlannedWhereUniqueInput | TrainingDayPlannedWhereUniqueInput[]
    update?: TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput | TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
  }

  export type TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput> | TrainingPlanExecutionCreateWithoutTrainingPlanInput[] | TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput[]
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput | TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput[]
    upsert?: TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput[]
    createMany?: TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope
    set?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    disconnect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    delete?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    connect?: TrainingPlanExecutionWhereUniqueInput | TrainingPlanExecutionWhereUniqueInput[]
    update?: TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput | TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput[]
    updateMany?: TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput | TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput[]
    deleteMany?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
  }

  export type TrainingPlanCreateNestedOneWithoutPlannedDaysInput = {
    create?: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutPlannedDaysInput
    connect?: TrainingPlanWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutPlannedDaysInput = {
    create?: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutPlannedDaysInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutPlannedDaysInput
    upsert?: TrainingPlanUpsertWithoutPlannedDaysInput
    connect?: TrainingPlanWhereUniqueInput
    update?: XOR<XOR<TrainingPlanUpdateToOneWithWhereWithoutPlannedDaysInput, TrainingPlanUpdateWithoutPlannedDaysInput>, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput = {
    create?: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutPlannedDaysInput
    upsert?: AthleteUpsertWithoutPlannedDaysInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutPlannedDaysInput, AthleteUpdateWithoutPlannedDaysInput>, AthleteUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type TrainingPlanCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutExecutionsInput
    connect?: TrainingPlanWhereUniqueInput
  }

  export type TrainingDayExecutedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
  }

  export type TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TrainingPlanCreateOrConnectWithoutExecutionsInput
    upsert?: TrainingPlanUpsertWithoutExecutionsInput
    connect?: TrainingPlanWhereUniqueInput
    update?: XOR<XOR<TrainingPlanUpdateToOneWithWhereWithoutExecutionsInput, TrainingPlanUpdateWithoutExecutionsInput>, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TrainingDayExecutedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput | TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput> | TrainingDayExecutedCreateWithoutExecutionInput[] | TrainingDayExecutedUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: TrainingDayExecutedCreateOrConnectWithoutExecutionInput | TrainingDayExecutedCreateOrConnectWithoutExecutionInput[]
    upsert?: TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: TrainingDayExecutedCreateManyExecutionInputEnvelope
    set?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    disconnect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    delete?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    connect?: TrainingDayExecutedWhereUniqueInput | TrainingDayExecutedWhereUniqueInput[]
    update?: TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput | TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput | TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
  }

  export type TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput
    connect?: TrainingPlanExecutionWhereUniqueInput
  }

  export type AthleteCreateNestedOneWithoutExecutedDaysInput = {
    create?: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutExecutedDaysInput
    connect?: AthleteWhereUniqueInput
  }

  export type TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput = {
    create?: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput
    upsert?: TrainingPlanExecutionUpsertWithoutExecutedDaysInput
    connect?: TrainingPlanExecutionWhereUniqueInput
    update?: XOR<XOR<TrainingPlanExecutionUpdateToOneWithWhereWithoutExecutedDaysInput, TrainingPlanExecutionUpdateWithoutExecutedDaysInput>, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput = {
    create?: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutExecutedDaysInput
    upsert?: AthleteUpsertWithoutExecutedDaysInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutExecutedDaysInput, AthleteUpdateWithoutExecutedDaysInput>, AthleteUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteCreateNestedOneWithoutFounderInput = {
    create?: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutFounderInput
    connect?: AthleteWhereUniqueInput
  }

  export type FounderTaskCreateNestedManyWithoutFounderInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
  }

  export type CrmContactCreateNestedManyWithoutFounderInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
  }

  export type RoadmapItemCreateNestedManyWithoutFounderInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type CompanyFounderCreateNestedManyWithoutFounderInput = {
    create?: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput> | CompanyFounderCreateWithoutFounderInput[] | CompanyFounderUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutFounderInput | CompanyFounderCreateOrConnectWithoutFounderInput[]
    createMany?: CompanyFounderCreateManyFounderInputEnvelope
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutFounderInput = {
    create?: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput> | TaskCreateWithoutFounderInput[] | TaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFounderInput | TaskCreateOrConnectWithoutFounderInput[]
    createMany?: TaskCreateManyFounderInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type FounderTaskUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
  }

  export type CrmContactUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
  }

  export type RoadmapItemUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type CompanyFounderUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput> | CompanyFounderCreateWithoutFounderInput[] | CompanyFounderUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutFounderInput | CompanyFounderCreateOrConnectWithoutFounderInput[]
    createMany?: CompanyFounderCreateManyFounderInputEnvelope
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput> | TaskCreateWithoutFounderInput[] | TaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFounderInput | TaskCreateOrConnectWithoutFounderInput[]
    createMany?: TaskCreateManyFounderInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AthleteUpdateOneRequiredWithoutFounderNestedInput = {
    create?: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    connectOrCreate?: AthleteCreateOrConnectWithoutFounderInput
    upsert?: AthleteUpsertWithoutFounderInput
    connect?: AthleteWhereUniqueInput
    update?: XOR<XOR<AthleteUpdateToOneWithWhereWithoutFounderInput, AthleteUpdateWithoutFounderInput>, AthleteUncheckedUpdateWithoutFounderInput>
  }

  export type FounderTaskUpdateManyWithoutFounderNestedInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    upsert?: FounderTaskUpsertWithWhereUniqueWithoutFounderInput | FounderTaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    set?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    disconnect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    delete?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    update?: FounderTaskUpdateWithWhereUniqueWithoutFounderInput | FounderTaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: FounderTaskUpdateManyWithWhereWithoutFounderInput | FounderTaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
  }

  export type CrmContactUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    upsert?: CrmContactUpsertWithWhereUniqueWithoutFounderInput | CrmContactUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    set?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    disconnect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    delete?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    update?: CrmContactUpdateWithWhereUniqueWithoutFounderInput | CrmContactUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CrmContactUpdateManyWithWhereWithoutFounderInput | CrmContactUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
  }

  export type RoadmapItemUpdateManyWithoutFounderNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutFounderInput | RoadmapItemUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutFounderInput | RoadmapItemUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutFounderInput | RoadmapItemUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type CompanyFounderUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput> | CompanyFounderCreateWithoutFounderInput[] | CompanyFounderUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutFounderInput | CompanyFounderCreateOrConnectWithoutFounderInput[]
    upsert?: CompanyFounderUpsertWithWhereUniqueWithoutFounderInput | CompanyFounderUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CompanyFounderCreateManyFounderInputEnvelope
    set?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    disconnect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    delete?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    update?: CompanyFounderUpdateWithWhereUniqueWithoutFounderInput | CompanyFounderUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CompanyFounderUpdateManyWithWhereWithoutFounderInput | CompanyFounderUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutFounderNestedInput = {
    create?: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput> | TaskCreateWithoutFounderInput[] | TaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFounderInput | TaskCreateOrConnectWithoutFounderInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutFounderInput | TaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: TaskCreateManyFounderInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutFounderInput | TaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutFounderInput | TaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type FounderTaskUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput> | FounderTaskCreateWithoutFounderInput[] | FounderTaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: FounderTaskCreateOrConnectWithoutFounderInput | FounderTaskCreateOrConnectWithoutFounderInput[]
    upsert?: FounderTaskUpsertWithWhereUniqueWithoutFounderInput | FounderTaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: FounderTaskCreateManyFounderInputEnvelope
    set?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    disconnect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    delete?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    connect?: FounderTaskWhereUniqueInput | FounderTaskWhereUniqueInput[]
    update?: FounderTaskUpdateWithWhereUniqueWithoutFounderInput | FounderTaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: FounderTaskUpdateManyWithWhereWithoutFounderInput | FounderTaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
  }

  export type CrmContactUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput> | CrmContactCreateWithoutFounderInput[] | CrmContactUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CrmContactCreateOrConnectWithoutFounderInput | CrmContactCreateOrConnectWithoutFounderInput[]
    upsert?: CrmContactUpsertWithWhereUniqueWithoutFounderInput | CrmContactUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CrmContactCreateManyFounderInputEnvelope
    set?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    disconnect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    delete?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    connect?: CrmContactWhereUniqueInput | CrmContactWhereUniqueInput[]
    update?: CrmContactUpdateWithWhereUniqueWithoutFounderInput | CrmContactUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CrmContactUpdateManyWithWhereWithoutFounderInput | CrmContactUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
  }

  export type RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput> | RoadmapItemCreateWithoutFounderInput[] | RoadmapItemUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutFounderInput | RoadmapItemCreateOrConnectWithoutFounderInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutFounderInput | RoadmapItemUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: RoadmapItemCreateManyFounderInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutFounderInput | RoadmapItemUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutFounderInput | RoadmapItemUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput> | CompanyFounderCreateWithoutFounderInput[] | CompanyFounderUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutFounderInput | CompanyFounderCreateOrConnectWithoutFounderInput[]
    upsert?: CompanyFounderUpsertWithWhereUniqueWithoutFounderInput | CompanyFounderUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: CompanyFounderCreateManyFounderInputEnvelope
    set?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    disconnect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    delete?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    update?: CompanyFounderUpdateWithWhereUniqueWithoutFounderInput | CompanyFounderUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: CompanyFounderUpdateManyWithWhereWithoutFounderInput | CompanyFounderUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput> | TaskCreateWithoutFounderInput[] | TaskUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFounderInput | TaskCreateOrConnectWithoutFounderInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutFounderInput | TaskUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: TaskCreateManyFounderInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutFounderInput | TaskUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutFounderInput | TaskUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type FounderCreateNestedOneWithoutTasksInput = {
    create?: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutTasksInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutTasksInput
    upsert?: FounderUpsertWithoutTasksInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutTasksInput, FounderUpdateWithoutTasksInput>, FounderUncheckedUpdateWithoutTasksInput>
  }

  export type FounderCreateNestedOneWithoutCrmContactsInput = {
    create?: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCrmContactsInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutCrmContactsNestedInput = {
    create?: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCrmContactsInput
    upsert?: FounderUpsertWithoutCrmContactsInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutCrmContactsInput, FounderUpdateWithoutCrmContactsInput>, FounderUncheckedUpdateWithoutCrmContactsInput>
  }

  export type FounderCreateNestedOneWithoutRoadmapItemsInput = {
    create?: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutRoadmapItemsInput
    connect?: FounderWhereUniqueInput
  }

  export type FounderUpdateOneRequiredWithoutRoadmapItemsNestedInput = {
    create?: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: FounderCreateOrConnectWithoutRoadmapItemsInput
    upsert?: FounderUpsertWithoutRoadmapItemsInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutRoadmapItemsInput, FounderUpdateWithoutRoadmapItemsInput>, FounderUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type CompanyFounderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput> | CompanyFounderCreateWithoutCompanyInput[] | CompanyFounderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutCompanyInput | CompanyFounderCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFounderCreateManyCompanyInputEnvelope
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
  }

  export type CompanyEmployeeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type CompanyRoadmapItemCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput> | CompanyRoadmapItemCreateWithoutCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyCompanyInputEnvelope
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput> | TaskCreateWithoutCompanyInput[] | TaskUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCompanyInput | TaskCreateOrConnectWithoutCompanyInput[]
    createMany?: TaskCreateManyCompanyInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CompanyCrmContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput> | CompanyCrmContactCreateWithoutCompanyInput[] | CompanyCrmContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCrmContactCreateOrConnectWithoutCompanyInput | CompanyCrmContactCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyCrmContactCreateManyCompanyInputEnvelope
    connect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
  }

  export type CompanyFinancialSpendCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput> | CompanyFinancialSpendCreateWithoutCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyCompanyInputEnvelope
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
  }

  export type CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput> | CompanyFinancialProjectionCreateWithoutCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyCompanyInputEnvelope
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
  }

  export type CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput> | CompanyFounderCreateWithoutCompanyInput[] | CompanyFounderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutCompanyInput | CompanyFounderCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFounderCreateManyCompanyInputEnvelope
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
  }

  export type CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput> | CompanyRoadmapItemCreateWithoutCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyCompanyInputEnvelope
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput> | TaskCreateWithoutCompanyInput[] | TaskUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCompanyInput | TaskCreateOrConnectWithoutCompanyInput[]
    createMany?: TaskCreateManyCompanyInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput> | CompanyCrmContactCreateWithoutCompanyInput[] | CompanyCrmContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCrmContactCreateOrConnectWithoutCompanyInput | CompanyCrmContactCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyCrmContactCreateManyCompanyInputEnvelope
    connect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
  }

  export type CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput> | CompanyFinancialSpendCreateWithoutCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyCompanyInputEnvelope
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
  }

  export type CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput> | CompanyFinancialProjectionCreateWithoutCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyCompanyInputEnvelope
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
  }

  export type CompanyFounderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput> | CompanyFounderCreateWithoutCompanyInput[] | CompanyFounderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutCompanyInput | CompanyFounderCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFounderUpsertWithWhereUniqueWithoutCompanyInput | CompanyFounderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFounderCreateManyCompanyInputEnvelope
    set?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    disconnect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    delete?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    update?: CompanyFounderUpdateWithWhereUniqueWithoutCompanyInput | CompanyFounderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFounderUpdateManyWithWhereWithoutCompanyInput | CompanyFounderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
  }

  export type CompanyEmployeeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput | CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput> | CompanyRoadmapItemCreateWithoutCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyRoadmapItemUpsertWithWhereUniqueWithoutCompanyInput | CompanyRoadmapItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyCompanyInputEnvelope
    set?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    disconnect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    delete?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    update?: CompanyRoadmapItemUpdateWithWhereUniqueWithoutCompanyInput | CompanyRoadmapItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyRoadmapItemUpdateManyWithWhereWithoutCompanyInput | CompanyRoadmapItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput> | TaskCreateWithoutCompanyInput[] | TaskUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCompanyInput | TaskCreateOrConnectWithoutCompanyInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCompanyInput | TaskUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TaskCreateManyCompanyInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCompanyInput | TaskUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCompanyInput | TaskUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CompanyCrmContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput> | CompanyCrmContactCreateWithoutCompanyInput[] | CompanyCrmContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCrmContactCreateOrConnectWithoutCompanyInput | CompanyCrmContactCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyCrmContactUpsertWithWhereUniqueWithoutCompanyInput | CompanyCrmContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyCrmContactCreateManyCompanyInputEnvelope
    set?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    disconnect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    delete?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    connect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    update?: CompanyCrmContactUpdateWithWhereUniqueWithoutCompanyInput | CompanyCrmContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyCrmContactUpdateManyWithWhereWithoutCompanyInput | CompanyCrmContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyCrmContactScalarWhereInput | CompanyCrmContactScalarWhereInput[]
  }

  export type CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput> | CompanyFinancialSpendCreateWithoutCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFinancialSpendUpsertWithWhereUniqueWithoutCompanyInput | CompanyFinancialSpendUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyCompanyInputEnvelope
    set?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    disconnect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    delete?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    update?: CompanyFinancialSpendUpdateWithWhereUniqueWithoutCompanyInput | CompanyFinancialSpendUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFinancialSpendUpdateManyWithWhereWithoutCompanyInput | CompanyFinancialSpendUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
  }

  export type CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput> | CompanyFinancialProjectionCreateWithoutCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFinancialProjectionUpsertWithWhereUniqueWithoutCompanyInput | CompanyFinancialProjectionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyCompanyInputEnvelope
    set?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    disconnect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    delete?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    update?: CompanyFinancialProjectionUpdateWithWhereUniqueWithoutCompanyInput | CompanyFinancialProjectionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFinancialProjectionUpdateManyWithWhereWithoutCompanyInput | CompanyFinancialProjectionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
  }

  export type CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput> | CompanyFounderCreateWithoutCompanyInput[] | CompanyFounderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFounderCreateOrConnectWithoutCompanyInput | CompanyFounderCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFounderUpsertWithWhereUniqueWithoutCompanyInput | CompanyFounderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFounderCreateManyCompanyInputEnvelope
    set?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    disconnect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    delete?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    connect?: CompanyFounderWhereUniqueInput | CompanyFounderWhereUniqueInput[]
    update?: CompanyFounderUpdateWithWhereUniqueWithoutCompanyInput | CompanyFounderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFounderUpdateManyWithWhereWithoutCompanyInput | CompanyFounderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput | CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput> | CompanyRoadmapItemCreateWithoutCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyRoadmapItemUpsertWithWhereUniqueWithoutCompanyInput | CompanyRoadmapItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyCompanyInputEnvelope
    set?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    disconnect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    delete?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    update?: CompanyRoadmapItemUpdateWithWhereUniqueWithoutCompanyInput | CompanyRoadmapItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyRoadmapItemUpdateManyWithWhereWithoutCompanyInput | CompanyRoadmapItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput> | TaskCreateWithoutCompanyInput[] | TaskUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCompanyInput | TaskCreateOrConnectWithoutCompanyInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCompanyInput | TaskUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TaskCreateManyCompanyInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCompanyInput | TaskUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCompanyInput | TaskUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput> | CompanyCrmContactCreateWithoutCompanyInput[] | CompanyCrmContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyCrmContactCreateOrConnectWithoutCompanyInput | CompanyCrmContactCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyCrmContactUpsertWithWhereUniqueWithoutCompanyInput | CompanyCrmContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyCrmContactCreateManyCompanyInputEnvelope
    set?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    disconnect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    delete?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    connect?: CompanyCrmContactWhereUniqueInput | CompanyCrmContactWhereUniqueInput[]
    update?: CompanyCrmContactUpdateWithWhereUniqueWithoutCompanyInput | CompanyCrmContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyCrmContactUpdateManyWithWhereWithoutCompanyInput | CompanyCrmContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyCrmContactScalarWhereInput | CompanyCrmContactScalarWhereInput[]
  }

  export type CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput> | CompanyFinancialSpendCreateWithoutCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFinancialSpendUpsertWithWhereUniqueWithoutCompanyInput | CompanyFinancialSpendUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyCompanyInputEnvelope
    set?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    disconnect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    delete?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    update?: CompanyFinancialSpendUpdateWithWhereUniqueWithoutCompanyInput | CompanyFinancialSpendUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFinancialSpendUpdateManyWithWhereWithoutCompanyInput | CompanyFinancialSpendUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
  }

  export type CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput> | CompanyFinancialProjectionCreateWithoutCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyFinancialProjectionUpsertWithWhereUniqueWithoutCompanyInput | CompanyFinancialProjectionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyCompanyInputEnvelope
    set?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    disconnect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    delete?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    update?: CompanyFinancialProjectionUpdateWithWhereUniqueWithoutCompanyInput | CompanyFinancialProjectionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyFinancialProjectionUpdateManyWithWhereWithoutCompanyInput | CompanyFinancialProjectionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutFoundersInput = {
    create?: XOR<CompanyCreateWithoutFoundersInput, CompanyUncheckedCreateWithoutFoundersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFoundersInput
    connect?: CompanyWhereUniqueInput
  }

  export type FounderCreateNestedOneWithoutCompanyFoundersInput = {
    create?: XOR<FounderCreateWithoutCompanyFoundersInput, FounderUncheckedCreateWithoutCompanyFoundersInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCompanyFoundersInput
    connect?: FounderWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutFoundersNestedInput = {
    create?: XOR<CompanyCreateWithoutFoundersInput, CompanyUncheckedCreateWithoutFoundersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFoundersInput
    upsert?: CompanyUpsertWithoutFoundersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFoundersInput, CompanyUpdateWithoutFoundersInput>, CompanyUncheckedUpdateWithoutFoundersInput>
  }

  export type FounderUpdateOneRequiredWithoutCompanyFoundersNestedInput = {
    create?: XOR<FounderCreateWithoutCompanyFoundersInput, FounderUncheckedCreateWithoutCompanyFoundersInput>
    connectOrCreate?: FounderCreateOrConnectWithoutCompanyFoundersInput
    upsert?: FounderUpsertWithoutCompanyFoundersInput
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutCompanyFoundersInput, FounderUpdateWithoutCompanyFoundersInput>, FounderUncheckedUpdateWithoutCompanyFoundersInput>
  }

  export type CompanyCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    upsert?: CompanyUpsertWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEmployeesInput, CompanyUpdateWithoutEmployeesInput>, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type CompanyCreateNestedOneWithoutRoadmapItemsInput = {
    create?: XOR<CompanyCreateWithoutRoadmapItemsInput, CompanyUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRoadmapItemsInput
    connect?: CompanyWhereUniqueInput
  }

  export type GoFastCompanyCreateNestedOneWithoutRoadmapItemsInput = {
    create?: XOR<GoFastCompanyCreateWithoutRoadmapItemsInput, GoFastCompanyUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutRoadmapItemsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutRoadmapItemsNestedInput = {
    create?: XOR<CompanyCreateWithoutRoadmapItemsInput, CompanyUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRoadmapItemsInput
    upsert?: CompanyUpsertWithoutRoadmapItemsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRoadmapItemsInput, CompanyUpdateWithoutRoadmapItemsInput>, CompanyUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type GoFastCompanyUpdateOneWithoutRoadmapItemsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutRoadmapItemsInput, GoFastCompanyUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutRoadmapItemsInput
    upsert?: GoFastCompanyUpsertWithoutRoadmapItemsInput
    disconnect?: GoFastCompanyWhereInput | boolean
    delete?: GoFastCompanyWhereInput | boolean
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutRoadmapItemsInput, GoFastCompanyUpdateWithoutRoadmapItemsInput>, GoFastCompanyUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type CompanyCreateNestedOneWithoutCrmContactsInput = {
    create?: XOR<CompanyCreateWithoutCrmContactsInput, CompanyUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCrmContactsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCrmContactsNestedInput = {
    create?: XOR<CompanyCreateWithoutCrmContactsInput, CompanyUncheckedCreateWithoutCrmContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCrmContactsInput
    upsert?: CompanyUpsertWithoutCrmContactsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCrmContactsInput, CompanyUpdateWithoutCrmContactsInput>, CompanyUncheckedUpdateWithoutCrmContactsInput>
  }

  export type CompanyCreateNestedOneWithoutFinancialSpendsInput = {
    create?: XOR<CompanyCreateWithoutFinancialSpendsInput, CompanyUncheckedCreateWithoutFinancialSpendsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialSpendsInput
    connect?: CompanyWhereUniqueInput
  }

  export type GoFastCompanyCreateNestedOneWithoutFinancialSpendsInput = {
    create?: XOR<GoFastCompanyCreateWithoutFinancialSpendsInput, GoFastCompanyUncheckedCreateWithoutFinancialSpendsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutFinancialSpendsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutFinancialSpendsNestedInput = {
    create?: XOR<CompanyCreateWithoutFinancialSpendsInput, CompanyUncheckedCreateWithoutFinancialSpendsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialSpendsInput
    upsert?: CompanyUpsertWithoutFinancialSpendsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFinancialSpendsInput, CompanyUpdateWithoutFinancialSpendsInput>, CompanyUncheckedUpdateWithoutFinancialSpendsInput>
  }

  export type GoFastCompanyUpdateOneWithoutFinancialSpendsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutFinancialSpendsInput, GoFastCompanyUncheckedCreateWithoutFinancialSpendsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutFinancialSpendsInput
    upsert?: GoFastCompanyUpsertWithoutFinancialSpendsInput
    disconnect?: GoFastCompanyWhereInput | boolean
    delete?: GoFastCompanyWhereInput | boolean
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutFinancialSpendsInput, GoFastCompanyUpdateWithoutFinancialSpendsInput>, GoFastCompanyUncheckedUpdateWithoutFinancialSpendsInput>
  }

  export type CompanyCreateNestedOneWithoutFinancialProjectionsInput = {
    create?: XOR<CompanyCreateWithoutFinancialProjectionsInput, CompanyUncheckedCreateWithoutFinancialProjectionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialProjectionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type GoFastCompanyCreateNestedOneWithoutFinancialProjectionsInput = {
    create?: XOR<GoFastCompanyCreateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedCreateWithoutFinancialProjectionsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutFinancialProjectionsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutFinancialProjectionsNestedInput = {
    create?: XOR<CompanyCreateWithoutFinancialProjectionsInput, CompanyUncheckedCreateWithoutFinancialProjectionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialProjectionsInput
    upsert?: CompanyUpsertWithoutFinancialProjectionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFinancialProjectionsInput, CompanyUpdateWithoutFinancialProjectionsInput>, CompanyUncheckedUpdateWithoutFinancialProjectionsInput>
  }

  export type GoFastCompanyUpdateOneWithoutFinancialProjectionsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedCreateWithoutFinancialProjectionsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutFinancialProjectionsInput
    upsert?: GoFastCompanyUpsertWithoutFinancialProjectionsInput
    disconnect?: GoFastCompanyWhereInput | boolean
    delete?: GoFastCompanyWhereInput | boolean
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutFinancialProjectionsInput, GoFastCompanyUpdateWithoutFinancialProjectionsInput>, GoFastCompanyUncheckedUpdateWithoutFinancialProjectionsInput>
  }

  export type FounderCreateNestedOneWithoutUnifiedTasksInput = {
    create?: XOR<FounderCreateWithoutUnifiedTasksInput, FounderUncheckedCreateWithoutUnifiedTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutUnifiedTasksInput
    connect?: FounderWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTasksInput = {
    create?: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTasksInput
    connect?: CompanyWhereUniqueInput
  }

  export type GoFastCompanyCreateNestedOneWithoutTasksInput = {
    create?: XOR<GoFastCompanyCreateWithoutTasksInput, GoFastCompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutTasksInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type FounderUpdateOneWithoutUnifiedTasksNestedInput = {
    create?: XOR<FounderCreateWithoutUnifiedTasksInput, FounderUncheckedCreateWithoutUnifiedTasksInput>
    connectOrCreate?: FounderCreateOrConnectWithoutUnifiedTasksInput
    upsert?: FounderUpsertWithoutUnifiedTasksInput
    disconnect?: FounderWhereInput | boolean
    delete?: FounderWhereInput | boolean
    connect?: FounderWhereUniqueInput
    update?: XOR<XOR<FounderUpdateToOneWithWhereWithoutUnifiedTasksInput, FounderUpdateWithoutUnifiedTasksInput>, FounderUncheckedUpdateWithoutUnifiedTasksInput>
  }

  export type CompanyUpdateOneWithoutTasksNestedInput = {
    create?: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTasksInput
    upsert?: CompanyUpsertWithoutTasksInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTasksInput, CompanyUpdateWithoutTasksInput>, CompanyUncheckedUpdateWithoutTasksInput>
  }

  export type GoFastCompanyUpdateOneWithoutTasksNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutTasksInput, GoFastCompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutTasksInput
    upsert?: GoFastCompanyUpsertWithoutTasksInput
    disconnect?: GoFastCompanyWhereInput | boolean
    delete?: GoFastCompanyWhereInput | boolean
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutTasksInput, GoFastCompanyUpdateWithoutTasksInput>, GoFastCompanyUncheckedUpdateWithoutTasksInput>
  }

  export type CompanyStaffCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput> | CompanyStaffCreateWithoutCompanyInput[] | CompanyStaffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStaffCreateOrConnectWithoutCompanyInput | CompanyStaffCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyStaffCreateManyCompanyInputEnvelope
    connect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type PipelineCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput> | PipelineCreateWithoutCompanyInput[] | PipelineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput | PipelineCreateOrConnectWithoutCompanyInput[]
    createMany?: PipelineCreateManyCompanyInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type PipelineConfigCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput> | PipelineConfigCreateWithoutCompanyInput[] | PipelineConfigUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutCompanyInput | PipelineConfigCreateOrConnectWithoutCompanyInput[]
    createMany?: PipelineConfigCreateManyCompanyInputEnvelope
    connect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
  }

  export type ProductPipelineItemCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput> | ProductPipelineItemCreateWithoutCompanyInput[] | ProductPipelineItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductPipelineItemCreateOrConnectWithoutCompanyInput | ProductPipelineItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductPipelineItemCreateManyCompanyInputEnvelope
    connect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
  }

  export type CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialSpendCreateWithoutGoFastCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
  }

  export type CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialProjectionCreateWithoutGoFastCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
  }

  export type CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput> | CompanyRoadmapItemCreateWithoutGoFastCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput> | TaskCreateWithoutGoFastCompanyInput[] | TaskUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoFastCompanyInput | TaskCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: TaskCreateManyGoFastCompanyInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput> | CompanyStaffCreateWithoutCompanyInput[] | CompanyStaffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStaffCreateOrConnectWithoutCompanyInput | CompanyStaffCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyStaffCreateManyCompanyInputEnvelope
    connect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput> | PipelineCreateWithoutCompanyInput[] | PipelineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput | PipelineCreateOrConnectWithoutCompanyInput[]
    createMany?: PipelineCreateManyCompanyInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput> | PipelineConfigCreateWithoutCompanyInput[] | PipelineConfigUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutCompanyInput | PipelineConfigCreateOrConnectWithoutCompanyInput[]
    createMany?: PipelineConfigCreateManyCompanyInputEnvelope
    connect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
  }

  export type ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput> | ProductPipelineItemCreateWithoutCompanyInput[] | ProductPipelineItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductPipelineItemCreateOrConnectWithoutCompanyInput | ProductPipelineItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ProductPipelineItemCreateManyCompanyInputEnvelope
    connect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
  }

  export type CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialSpendCreateWithoutGoFastCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
  }

  export type CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialProjectionCreateWithoutGoFastCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
  }

  export type CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput> | CompanyRoadmapItemCreateWithoutGoFastCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyGoFastCompanyInputEnvelope
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput = {
    create?: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput> | TaskCreateWithoutGoFastCompanyInput[] | TaskUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoFastCompanyInput | TaskCreateOrConnectWithoutGoFastCompanyInput[]
    createMany?: TaskCreateManyGoFastCompanyInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CompanyStaffUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput> | CompanyStaffCreateWithoutCompanyInput[] | CompanyStaffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStaffCreateOrConnectWithoutCompanyInput | CompanyStaffCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyStaffUpsertWithWhereUniqueWithoutCompanyInput | CompanyStaffUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyStaffCreateManyCompanyInputEnvelope
    set?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    disconnect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    delete?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    connect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    update?: CompanyStaffUpdateWithWhereUniqueWithoutCompanyInput | CompanyStaffUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyStaffUpdateManyWithWhereWithoutCompanyInput | CompanyStaffUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyStaffScalarWhereInput | CompanyStaffScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type PipelineUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput> | PipelineCreateWithoutCompanyInput[] | PipelineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput | PipelineCreateOrConnectWithoutCompanyInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutCompanyInput | PipelineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PipelineCreateManyCompanyInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutCompanyInput | PipelineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutCompanyInput | PipelineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type PipelineConfigUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput> | PipelineConfigCreateWithoutCompanyInput[] | PipelineConfigUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutCompanyInput | PipelineConfigCreateOrConnectWithoutCompanyInput[]
    upsert?: PipelineConfigUpsertWithWhereUniqueWithoutCompanyInput | PipelineConfigUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PipelineConfigCreateManyCompanyInputEnvelope
    set?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    disconnect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    delete?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    connect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    update?: PipelineConfigUpdateWithWhereUniqueWithoutCompanyInput | PipelineConfigUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PipelineConfigUpdateManyWithWhereWithoutCompanyInput | PipelineConfigUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PipelineConfigScalarWhereInput | PipelineConfigScalarWhereInput[]
  }

  export type ProductPipelineItemUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput> | ProductPipelineItemCreateWithoutCompanyInput[] | ProductPipelineItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductPipelineItemCreateOrConnectWithoutCompanyInput | ProductPipelineItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductPipelineItemUpsertWithWhereUniqueWithoutCompanyInput | ProductPipelineItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductPipelineItemCreateManyCompanyInputEnvelope
    set?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    disconnect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    delete?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    connect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    update?: ProductPipelineItemUpdateWithWhereUniqueWithoutCompanyInput | ProductPipelineItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductPipelineItemUpdateManyWithWhereWithoutCompanyInput | ProductPipelineItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductPipelineItemScalarWhereInput | ProductPipelineItemScalarWhereInput[]
  }

  export type CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialSpendCreateWithoutGoFastCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyFinancialSpendUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialSpendUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyGoFastCompanyInputEnvelope
    set?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    disconnect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    delete?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    update?: CompanyFinancialSpendUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialSpendUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyFinancialSpendUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyFinancialSpendUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
  }

  export type CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialProjectionCreateWithoutGoFastCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyFinancialProjectionUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialProjectionUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyGoFastCompanyInputEnvelope
    set?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    disconnect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    delete?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    update?: CompanyFinancialProjectionUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialProjectionUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyFinancialProjectionUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyFinancialProjectionUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
  }

  export type CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput> | CompanyRoadmapItemCreateWithoutGoFastCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyRoadmapItemUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyRoadmapItemUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyGoFastCompanyInputEnvelope
    set?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    disconnect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    delete?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    update?: CompanyRoadmapItemUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyRoadmapItemUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyRoadmapItemUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyRoadmapItemUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput> | TaskCreateWithoutGoFastCompanyInput[] | TaskUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoFastCompanyInput | TaskCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoFastCompanyInput | TaskUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: TaskCreateManyGoFastCompanyInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoFastCompanyInput | TaskUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoFastCompanyInput | TaskUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput> | CompanyStaffCreateWithoutCompanyInput[] | CompanyStaffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStaffCreateOrConnectWithoutCompanyInput | CompanyStaffCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyStaffUpsertWithWhereUniqueWithoutCompanyInput | CompanyStaffUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyStaffCreateManyCompanyInputEnvelope
    set?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    disconnect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    delete?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    connect?: CompanyStaffWhereUniqueInput | CompanyStaffWhereUniqueInput[]
    update?: CompanyStaffUpdateWithWhereUniqueWithoutCompanyInput | CompanyStaffUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyStaffUpdateManyWithWhereWithoutCompanyInput | CompanyStaffUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyStaffScalarWhereInput | CompanyStaffScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput> | PipelineCreateWithoutCompanyInput[] | PipelineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutCompanyInput | PipelineCreateOrConnectWithoutCompanyInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutCompanyInput | PipelineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PipelineCreateManyCompanyInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutCompanyInput | PipelineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutCompanyInput | PipelineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput> | PipelineConfigCreateWithoutCompanyInput[] | PipelineConfigUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutCompanyInput | PipelineConfigCreateOrConnectWithoutCompanyInput[]
    upsert?: PipelineConfigUpsertWithWhereUniqueWithoutCompanyInput | PipelineConfigUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PipelineConfigCreateManyCompanyInputEnvelope
    set?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    disconnect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    delete?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    connect?: PipelineConfigWhereUniqueInput | PipelineConfigWhereUniqueInput[]
    update?: PipelineConfigUpdateWithWhereUniqueWithoutCompanyInput | PipelineConfigUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PipelineConfigUpdateManyWithWhereWithoutCompanyInput | PipelineConfigUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PipelineConfigScalarWhereInput | PipelineConfigScalarWhereInput[]
  }

  export type ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput> | ProductPipelineItemCreateWithoutCompanyInput[] | ProductPipelineItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProductPipelineItemCreateOrConnectWithoutCompanyInput | ProductPipelineItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ProductPipelineItemUpsertWithWhereUniqueWithoutCompanyInput | ProductPipelineItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProductPipelineItemCreateManyCompanyInputEnvelope
    set?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    disconnect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    delete?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    connect?: ProductPipelineItemWhereUniqueInput | ProductPipelineItemWhereUniqueInput[]
    update?: ProductPipelineItemUpdateWithWhereUniqueWithoutCompanyInput | ProductPipelineItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProductPipelineItemUpdateManyWithWhereWithoutCompanyInput | ProductPipelineItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProductPipelineItemScalarWhereInput | ProductPipelineItemScalarWhereInput[]
  }

  export type CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialSpendCreateWithoutGoFastCompanyInput[] | CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyFinancialSpendUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialSpendUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialSpendCreateManyGoFastCompanyInputEnvelope
    set?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    disconnect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    delete?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    connect?: CompanyFinancialSpendWhereUniqueInput | CompanyFinancialSpendWhereUniqueInput[]
    update?: CompanyFinancialSpendUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialSpendUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyFinancialSpendUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyFinancialSpendUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
  }

  export type CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput> | CompanyFinancialProjectionCreateWithoutGoFastCompanyInput[] | CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput | CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyFinancialProjectionUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialProjectionUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyFinancialProjectionCreateManyGoFastCompanyInputEnvelope
    set?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    disconnect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    delete?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    connect?: CompanyFinancialProjectionWhereUniqueInput | CompanyFinancialProjectionWhereUniqueInput[]
    update?: CompanyFinancialProjectionUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyFinancialProjectionUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyFinancialProjectionUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyFinancialProjectionUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
  }

  export type CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput> | CompanyRoadmapItemCreateWithoutGoFastCompanyInput[] | CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput | CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: CompanyRoadmapItemUpsertWithWhereUniqueWithoutGoFastCompanyInput | CompanyRoadmapItemUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: CompanyRoadmapItemCreateManyGoFastCompanyInputEnvelope
    set?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    disconnect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    delete?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    connect?: CompanyRoadmapItemWhereUniqueInput | CompanyRoadmapItemWhereUniqueInput[]
    update?: CompanyRoadmapItemUpdateWithWhereUniqueWithoutGoFastCompanyInput | CompanyRoadmapItemUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: CompanyRoadmapItemUpdateManyWithWhereWithoutGoFastCompanyInput | CompanyRoadmapItemUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput = {
    create?: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput> | TaskCreateWithoutGoFastCompanyInput[] | TaskUncheckedCreateWithoutGoFastCompanyInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoFastCompanyInput | TaskCreateOrConnectWithoutGoFastCompanyInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoFastCompanyInput | TaskUpsertWithWhereUniqueWithoutGoFastCompanyInput[]
    createMany?: TaskCreateManyGoFastCompanyInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoFastCompanyInput | TaskUpdateWithWhereUniqueWithoutGoFastCompanyInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoFastCompanyInput | TaskUpdateManyWithWhereWithoutGoFastCompanyInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type GoFastCompanyCreateNestedOneWithoutStaffInput = {
    create?: XOR<GoFastCompanyCreateWithoutStaffInput, GoFastCompanyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutStaffInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type GoFastCompanyUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutStaffInput, GoFastCompanyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutStaffInput
    upsert?: GoFastCompanyUpsertWithoutStaffInput
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutStaffInput, GoFastCompanyUpdateWithoutStaffInput>, GoFastCompanyUncheckedUpdateWithoutStaffInput>
  }

  export type GoFastCompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<GoFastCompanyCreateWithoutContactsInput, GoFastCompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutContactsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type PipelineCreateNestedManyWithoutContactInput = {
    create?: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput> | PipelineCreateWithoutContactInput[] | PipelineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutContactInput | PipelineCreateOrConnectWithoutContactInput[]
    createMany?: PipelineCreateManyContactInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput> | PipelineCreateWithoutContactInput[] | PipelineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutContactInput | PipelineCreateOrConnectWithoutContactInput[]
    createMany?: PipelineCreateManyContactInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type GoFastCompanyUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutContactsInput, GoFastCompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutContactsInput
    upsert?: GoFastCompanyUpsertWithoutContactsInput
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutContactsInput, GoFastCompanyUpdateWithoutContactsInput>, GoFastCompanyUncheckedUpdateWithoutContactsInput>
  }

  export type PipelineUpdateManyWithoutContactNestedInput = {
    create?: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput> | PipelineCreateWithoutContactInput[] | PipelineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutContactInput | PipelineCreateOrConnectWithoutContactInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutContactInput | PipelineUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PipelineCreateManyContactInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutContactInput | PipelineUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutContactInput | PipelineUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput> | PipelineCreateWithoutContactInput[] | PipelineUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutContactInput | PipelineCreateOrConnectWithoutContactInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutContactInput | PipelineUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PipelineCreateManyContactInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutContactInput | PipelineUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutContactInput | PipelineUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type GoFastCompanyCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<GoFastCompanyCreateWithoutPipelinesInput, GoFastCompanyUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutPipelinesInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<ContactCreateWithoutPipelinesInput, ContactUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPipelinesInput
    connect?: ContactWhereUniqueInput
  }

  export type PipelineConfigCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<PipelineConfigCreateWithoutPipelinesInput, PipelineConfigUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutPipelinesInput
    connect?: PipelineConfigWhereUniqueInput
  }

  export type GoFastCompanyUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutPipelinesInput, GoFastCompanyUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutPipelinesInput
    upsert?: GoFastCompanyUpsertWithoutPipelinesInput
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutPipelinesInput, GoFastCompanyUpdateWithoutPipelinesInput>, GoFastCompanyUncheckedUpdateWithoutPipelinesInput>
  }

  export type ContactUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<ContactCreateWithoutPipelinesInput, ContactUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPipelinesInput
    upsert?: ContactUpsertWithoutPipelinesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPipelinesInput, ContactUpdateWithoutPipelinesInput>, ContactUncheckedUpdateWithoutPipelinesInput>
  }

  export type PipelineConfigUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<PipelineConfigCreateWithoutPipelinesInput, PipelineConfigUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: PipelineConfigCreateOrConnectWithoutPipelinesInput
    upsert?: PipelineConfigUpsertWithoutPipelinesInput
    connect?: PipelineConfigWhereUniqueInput
    update?: XOR<XOR<PipelineConfigUpdateToOneWithWhereWithoutPipelinesInput, PipelineConfigUpdateWithoutPipelinesInput>, PipelineConfigUncheckedUpdateWithoutPipelinesInput>
  }

  export type GoFastCompanyCreateNestedOneWithoutPipelineConfigsInput = {
    create?: XOR<GoFastCompanyCreateWithoutPipelineConfigsInput, GoFastCompanyUncheckedCreateWithoutPipelineConfigsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutPipelineConfigsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type PipelineCreateNestedManyWithoutConfigInput = {
    create?: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput> | PipelineCreateWithoutConfigInput[] | PipelineUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutConfigInput | PipelineCreateOrConnectWithoutConfigInput[]
    createMany?: PipelineCreateManyConfigInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput> | PipelineCreateWithoutConfigInput[] | PipelineUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutConfigInput | PipelineCreateOrConnectWithoutConfigInput[]
    createMany?: PipelineCreateManyConfigInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type GoFastCompanyUpdateOneRequiredWithoutPipelineConfigsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutPipelineConfigsInput, GoFastCompanyUncheckedCreateWithoutPipelineConfigsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutPipelineConfigsInput
    upsert?: GoFastCompanyUpsertWithoutPipelineConfigsInput
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutPipelineConfigsInput, GoFastCompanyUpdateWithoutPipelineConfigsInput>, GoFastCompanyUncheckedUpdateWithoutPipelineConfigsInput>
  }

  export type PipelineUpdateManyWithoutConfigNestedInput = {
    create?: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput> | PipelineCreateWithoutConfigInput[] | PipelineUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutConfigInput | PipelineCreateOrConnectWithoutConfigInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutConfigInput | PipelineUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: PipelineCreateManyConfigInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutConfigInput | PipelineUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutConfigInput | PipelineUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput> | PipelineCreateWithoutConfigInput[] | PipelineUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutConfigInput | PipelineCreateOrConnectWithoutConfigInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutConfigInput | PipelineUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: PipelineCreateManyConfigInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutConfigInput | PipelineUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutConfigInput | PipelineUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type GoFastCompanyCreateNestedOneWithoutProductPipelineItemsInput = {
    create?: XOR<GoFastCompanyCreateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedCreateWithoutProductPipelineItemsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutProductPipelineItemsInput
    connect?: GoFastCompanyWhereUniqueInput
  }

  export type GoFastCompanyUpdateOneRequiredWithoutProductPipelineItemsNestedInput = {
    create?: XOR<GoFastCompanyCreateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedCreateWithoutProductPipelineItemsInput>
    connectOrCreate?: GoFastCompanyCreateOrConnectWithoutProductPipelineItemsInput
    upsert?: GoFastCompanyUpsertWithoutProductPipelineItemsInput
    connect?: GoFastCompanyWhereUniqueInput
    update?: XOR<XOR<GoFastCompanyUpdateToOneWithWhereWithoutProductPipelineItemsInput, GoFastCompanyUpdateWithoutProductPipelineItemsInput>, GoFastCompanyUncheckedUpdateWithoutProductPipelineItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AthleteActivityCreateWithoutAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUncheckedCreateWithoutAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityCreateOrConnectWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    create: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityCreateManyAthleteInputEnvelope = {
    data: AthleteActivityCreateManyAthleteInput | AthleteActivityCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewCreateWithoutAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput>
  }

  export type RunCrewCreateManyAdminInputEnvelope = {
    data: RunCrewCreateManyAdminInput | RunCrewCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewMembershipCreateWithoutAthleteInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateOrConnectWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    create: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMembershipCreateManyAthleteInputEnvelope = {
    data: RunCrewMembershipCreateManyAthleteInput | RunCrewMembershipCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewMessageCreateWithoutAthleteInput = {
    id?: string
    content: string
    createdAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutMessagesInput
  }

  export type RunCrewMessageUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewMessageCreateOrConnectWithoutAthleteInput = {
    where: RunCrewMessageWhereUniqueInput
    create: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMessageCreateManyAthleteInputEnvelope = {
    data: RunCrewMessageCreateManyAthleteInput | RunCrewMessageCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewAnnouncementCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutAnnouncementsInput
  }

  export type RunCrewAnnouncementUncheckedCreateWithoutAuthorInput = {
    id?: string
    runCrewId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewAnnouncementCreateOrConnectWithoutAuthorInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    create: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type RunCrewAnnouncementCreateManyAuthorInputEnvelope = {
    data: RunCrewAnnouncementCreateManyAuthorInput | RunCrewAnnouncementCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewLeaderboardCreateWithoutAthleteInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type RunCrewLeaderboardUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateOrConnectWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    create: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardCreateManyAthleteInputEnvelope = {
    data: RunCrewLeaderboardCreateManyAthleteInput | RunCrewLeaderboardCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewRunCreateWithoutCreatedByInput = {
    id?: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutRunsInput
    rsvps?: RunCrewRunRSVPCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunUncheckedCreateWithoutCreatedByInput = {
    id?: string
    runCrewId: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunCreateOrConnectWithoutCreatedByInput = {
    where: RunCrewRunWhereUniqueInput
    create: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput>
  }

  export type RunCrewRunCreateManyCreatedByInputEnvelope = {
    data: RunCrewRunCreateManyCreatedByInput | RunCrewRunCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewRunRSVPCreateWithoutAthleteInput = {
    id?: string
    status: string
    createdAt?: Date | string
    run: RunCrewRunCreateNestedOneWithoutRsvpsInput
  }

  export type RunCrewRunRSVPUncheckedCreateWithoutAthleteInput = {
    id?: string
    runId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewRunRSVPCreateOrConnectWithoutAthleteInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    create: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewRunRSVPCreateManyAthleteInputEnvelope = {
    data: RunCrewRunRSVPCreateManyAthleteInput | RunCrewRunRSVPCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewEventCreateWithoutOrganizerInput = {
    id?: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutEventsInput
    rsvps?: RunCrewEventRSVPCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventUncheckedCreateWithoutOrganizerInput = {
    id?: string
    runCrewId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventCreateOrConnectWithoutOrganizerInput = {
    where: RunCrewEventWhereUniqueInput
    create: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput>
  }

  export type RunCrewEventCreateManyOrganizerInputEnvelope = {
    data: RunCrewEventCreateManyOrganizerInput | RunCrewEventCreateManyOrganizerInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewEventRSVPCreateWithoutAthleteInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: RunCrewEventCreateNestedOneWithoutRsvpsInput
  }

  export type RunCrewEventRSVPUncheckedCreateWithoutAthleteInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventRSVPCreateOrConnectWithoutAthleteInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    create: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewEventRSVPCreateManyAthleteInputEnvelope = {
    data: RunCrewEventRSVPCreateManyAthleteInput | RunCrewEventRSVPCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewManagerCreateWithoutAthleteInput = {
    id?: string
    role: string
    createdAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutManagersInput
  }

  export type RunCrewManagerUncheckedCreateWithoutAthleteInput = {
    id?: string
    runCrewId: string
    role: string
    createdAt?: Date | string
  }

  export type RunCrewManagerCreateOrConnectWithoutAthleteInput = {
    where: RunCrewManagerWhereUniqueInput
    create: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewManagerCreateManyAthleteInputEnvelope = {
    data: RunCrewManagerCreateManyAthleteInput | RunCrewManagerCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type RaceCreateWithoutCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput>
  }

  export type RaceCreateManyCreatedByAthleteInputEnvelope = {
    data: RaceCreateManyCreatedByAthleteInput | RaceCreateManyCreatedByAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanCreateWithoutAthleteInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutAthleteInput = {
    id?: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingPlanCreateManyAthleteInputEnvelope = {
    data: TrainingPlanCreateManyAthleteInput | TrainingPlanCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDayPlannedCreateWithoutAthleteInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateWithoutAthleteInput = {
    id?: string
    trainingPlanId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateOrConnectWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    create: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayPlannedCreateManyAthleteInputEnvelope = {
    data: TrainingDayPlannedCreateManyAthleteInput | TrainingDayPlannedCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDayExecutedCreateWithoutAthleteInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: TrainingPlanExecutionCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateWithoutAthleteInput = {
    id?: string
    executionId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateOrConnectWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    create: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayExecutedCreateManyAthleteInputEnvelope = {
    data: TrainingDayExecutedCreateManyAthleteInput | TrainingDayExecutedCreateManyAthleteInput[]
    skipDuplicates?: boolean
  }

  export type FounderCreateWithoutAthleteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutAthleteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutAthleteInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityUpsertWithWhereUniqueWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    update: XOR<AthleteActivityUpdateWithoutAthleteInput, AthleteActivityUncheckedUpdateWithoutAthleteInput>
    create: XOR<AthleteActivityCreateWithoutAthleteInput, AthleteActivityUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteActivityUpdateWithWhereUniqueWithoutAthleteInput = {
    where: AthleteActivityWhereUniqueInput
    data: XOR<AthleteActivityUpdateWithoutAthleteInput, AthleteActivityUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteActivityUpdateManyWithWhereWithoutAthleteInput = {
    where: AthleteActivityScalarWhereInput
    data: XOR<AthleteActivityUpdateManyMutationInput, AthleteActivityUncheckedUpdateManyWithoutAthleteInput>
  }

  export type AthleteActivityScalarWhereInput = {
    AND?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
    OR?: AthleteActivityScalarWhereInput[]
    NOT?: AthleteActivityScalarWhereInput | AthleteActivityScalarWhereInput[]
    id?: StringFilter<"AthleteActivity"> | string
    athleteId?: StringFilter<"AthleteActivity"> | string
    sourceActivityId?: StringFilter<"AthleteActivity"> | string
    source?: StringFilter<"AthleteActivity"> | string
    activityType?: StringNullableFilter<"AthleteActivity"> | string | null
    activityName?: StringNullableFilter<"AthleteActivity"> | string | null
    startTime?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    duration?: IntNullableFilter<"AthleteActivity"> | number | null
    distance?: FloatNullableFilter<"AthleteActivity"> | number | null
    averageSpeed?: FloatNullableFilter<"AthleteActivity"> | number | null
    calories?: IntNullableFilter<"AthleteActivity"> | number | null
    averageHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    maxHeartRate?: IntNullableFilter<"AthleteActivity"> | number | null
    elevationGain?: FloatNullableFilter<"AthleteActivity"> | number | null
    steps?: IntNullableFilter<"AthleteActivity"> | number | null
    startLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    startLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLatitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    endLongitude?: FloatNullableFilter<"AthleteActivity"> | number | null
    summaryPolyline?: StringNullableFilter<"AthleteActivity"> | string | null
    deviceName?: StringNullableFilter<"AthleteActivity"> | string | null
    garminUserId?: StringNullableFilter<"AthleteActivity"> | string | null
    summaryData?: JsonNullableFilter<"AthleteActivity">
    detailData?: JsonNullableFilter<"AthleteActivity">
    hydratedAt?: DateTimeNullableFilter<"AthleteActivity"> | Date | string | null
    syncedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    lastUpdatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    createdAt?: DateTimeFilter<"AthleteActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AthleteActivity"> | Date | string
  }

  export type RunCrewUpsertWithWhereUniqueWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    update: XOR<RunCrewUpdateWithoutAdminInput, RunCrewUncheckedUpdateWithoutAdminInput>
    create: XOR<RunCrewCreateWithoutAdminInput, RunCrewUncheckedCreateWithoutAdminInput>
  }

  export type RunCrewUpdateWithWhereUniqueWithoutAdminInput = {
    where: RunCrewWhereUniqueInput
    data: XOR<RunCrewUpdateWithoutAdminInput, RunCrewUncheckedUpdateWithoutAdminInput>
  }

  export type RunCrewUpdateManyWithWhereWithoutAdminInput = {
    where: RunCrewScalarWhereInput
    data: XOR<RunCrewUpdateManyMutationInput, RunCrewUncheckedUpdateManyWithoutAdminInput>
  }

  export type RunCrewScalarWhereInput = {
    AND?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
    OR?: RunCrewScalarWhereInput[]
    NOT?: RunCrewScalarWhereInput | RunCrewScalarWhereInput[]
    id?: StringFilter<"RunCrew"> | string
    name?: StringFilter<"RunCrew"> | string
    description?: StringNullableFilter<"RunCrew"> | string | null
    joinCode?: StringFilter<"RunCrew"> | string
    logo?: StringNullableFilter<"RunCrew"> | string | null
    icon?: StringNullableFilter<"RunCrew"> | string | null
    runcrewAdminId?: StringNullableFilter<"RunCrew"> | string | null
    isArchived?: BoolFilter<"RunCrew"> | boolean
    archivedAt?: DateTimeNullableFilter<"RunCrew"> | Date | string | null
    createdAt?: DateTimeFilter<"RunCrew"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrew"> | Date | string
  }

  export type RunCrewMembershipUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    update: XOR<RunCrewMembershipUpdateWithoutAthleteInput, RunCrewMembershipUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewMembershipCreateWithoutAthleteInput, RunCrewMembershipUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMembershipUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMembershipWhereUniqueInput
    data: XOR<RunCrewMembershipUpdateWithoutAthleteInput, RunCrewMembershipUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewMembershipUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewMembershipScalarWhereInput
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewMembershipScalarWhereInput = {
    AND?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
    OR?: RunCrewMembershipScalarWhereInput[]
    NOT?: RunCrewMembershipScalarWhereInput | RunCrewMembershipScalarWhereInput[]
    id?: StringFilter<"RunCrewMembership"> | string
    runCrewId?: StringFilter<"RunCrewMembership"> | string
    athleteId?: StringFilter<"RunCrewMembership"> | string
    joinedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewMembership"> | Date | string
  }

  export type RunCrewMessageUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMessageWhereUniqueInput
    update: XOR<RunCrewMessageUpdateWithoutAthleteInput, RunCrewMessageUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewMessageCreateWithoutAthleteInput, RunCrewMessageUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewMessageUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewMessageWhereUniqueInput
    data: XOR<RunCrewMessageUpdateWithoutAthleteInput, RunCrewMessageUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewMessageUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewMessageScalarWhereInput
    data: XOR<RunCrewMessageUpdateManyMutationInput, RunCrewMessageUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewMessageScalarWhereInput = {
    AND?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
    OR?: RunCrewMessageScalarWhereInput[]
    NOT?: RunCrewMessageScalarWhereInput | RunCrewMessageScalarWhereInput[]
    id?: StringFilter<"RunCrewMessage"> | string
    runCrewId?: StringFilter<"RunCrewMessage"> | string
    athleteId?: StringFilter<"RunCrewMessage"> | string
    content?: StringFilter<"RunCrewMessage"> | string
    createdAt?: DateTimeFilter<"RunCrewMessage"> | Date | string
  }

  export type RunCrewAnnouncementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    update: XOR<RunCrewAnnouncementUpdateWithoutAuthorInput, RunCrewAnnouncementUncheckedUpdateWithoutAuthorInput>
    create: XOR<RunCrewAnnouncementCreateWithoutAuthorInput, RunCrewAnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type RunCrewAnnouncementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    data: XOR<RunCrewAnnouncementUpdateWithoutAuthorInput, RunCrewAnnouncementUncheckedUpdateWithoutAuthorInput>
  }

  export type RunCrewAnnouncementUpdateManyWithWhereWithoutAuthorInput = {
    where: RunCrewAnnouncementScalarWhereInput
    data: XOR<RunCrewAnnouncementUpdateManyMutationInput, RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorInput>
  }

  export type RunCrewAnnouncementScalarWhereInput = {
    AND?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
    OR?: RunCrewAnnouncementScalarWhereInput[]
    NOT?: RunCrewAnnouncementScalarWhereInput | RunCrewAnnouncementScalarWhereInput[]
    id?: StringFilter<"RunCrewAnnouncement"> | string
    runCrewId?: StringFilter<"RunCrewAnnouncement"> | string
    authorId?: StringFilter<"RunCrewAnnouncement"> | string
    title?: StringFilter<"RunCrewAnnouncement"> | string
    content?: StringFilter<"RunCrewAnnouncement"> | string
    createdAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewAnnouncement"> | Date | string
  }

  export type RunCrewLeaderboardUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    update: XOR<RunCrewLeaderboardUpdateWithoutAthleteInput, RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewLeaderboardCreateWithoutAthleteInput, RunCrewLeaderboardUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    data: XOR<RunCrewLeaderboardUpdateWithoutAthleteInput, RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewLeaderboardUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewLeaderboardScalarWhereInput
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewLeaderboardScalarWhereInput = {
    AND?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
    OR?: RunCrewLeaderboardScalarWhereInput[]
    NOT?: RunCrewLeaderboardScalarWhereInput | RunCrewLeaderboardScalarWhereInput[]
    id?: StringFilter<"RunCrewLeaderboard"> | string
    runCrewId?: StringFilter<"RunCrewLeaderboard"> | string
    athleteId?: StringFilter<"RunCrewLeaderboard"> | string
    period?: StringFilter<"RunCrewLeaderboard"> | string
    periodStart?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    periodEnd?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    totalMiles?: FloatFilter<"RunCrewLeaderboard"> | number
    totalRuns?: IntFilter<"RunCrewLeaderboard"> | number
    bestPace?: StringNullableFilter<"RunCrewLeaderboard"> | string | null
    totalCalories?: IntFilter<"RunCrewLeaderboard"> | number
    totalElevation?: FloatFilter<"RunCrewLeaderboard"> | number
    calculatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    createdAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewLeaderboard"> | Date | string
  }

  export type RunCrewRunUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RunCrewRunWhereUniqueInput
    update: XOR<RunCrewRunUpdateWithoutCreatedByInput, RunCrewRunUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RunCrewRunCreateWithoutCreatedByInput, RunCrewRunUncheckedCreateWithoutCreatedByInput>
  }

  export type RunCrewRunUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RunCrewRunWhereUniqueInput
    data: XOR<RunCrewRunUpdateWithoutCreatedByInput, RunCrewRunUncheckedUpdateWithoutCreatedByInput>
  }

  export type RunCrewRunUpdateManyWithWhereWithoutCreatedByInput = {
    where: RunCrewRunScalarWhereInput
    data: XOR<RunCrewRunUpdateManyMutationInput, RunCrewRunUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RunCrewRunScalarWhereInput = {
    AND?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
    OR?: RunCrewRunScalarWhereInput[]
    NOT?: RunCrewRunScalarWhereInput | RunCrewRunScalarWhereInput[]
    id?: StringFilter<"RunCrewRun"> | string
    runCrewId?: StringFilter<"RunCrewRun"> | string
    createdById?: StringFilter<"RunCrewRun"> | string
    title?: StringFilter<"RunCrewRun"> | string
    date?: DateTimeFilter<"RunCrewRun"> | Date | string
    startTime?: StringFilter<"RunCrewRun"> | string
    location?: StringFilter<"RunCrewRun"> | string
    address?: StringNullableFilter<"RunCrewRun"> | string | null
    totalMiles?: FloatNullableFilter<"RunCrewRun"> | number | null
    pace?: StringNullableFilter<"RunCrewRun"> | string | null
    stravaMapUrl?: StringNullableFilter<"RunCrewRun"> | string | null
    description?: StringNullableFilter<"RunCrewRun"> | string | null
    createdAt?: DateTimeFilter<"RunCrewRun"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewRun"> | Date | string
  }

  export type RunCrewRunRSVPUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    update: XOR<RunCrewRunRSVPUpdateWithoutAthleteInput, RunCrewRunRSVPUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewRunRSVPCreateWithoutAthleteInput, RunCrewRunRSVPUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewRunRSVPUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    data: XOR<RunCrewRunRSVPUpdateWithoutAthleteInput, RunCrewRunRSVPUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewRunRSVPUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewRunRSVPScalarWhereInput
    data: XOR<RunCrewRunRSVPUpdateManyMutationInput, RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewRunRSVPScalarWhereInput = {
    AND?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
    OR?: RunCrewRunRSVPScalarWhereInput[]
    NOT?: RunCrewRunRSVPScalarWhereInput | RunCrewRunRSVPScalarWhereInput[]
    id?: StringFilter<"RunCrewRunRSVP"> | string
    runId?: StringFilter<"RunCrewRunRSVP"> | string
    athleteId?: StringFilter<"RunCrewRunRSVP"> | string
    status?: StringFilter<"RunCrewRunRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewRunRSVP"> | Date | string
  }

  export type RunCrewEventUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: RunCrewEventWhereUniqueInput
    update: XOR<RunCrewEventUpdateWithoutOrganizerInput, RunCrewEventUncheckedUpdateWithoutOrganizerInput>
    create: XOR<RunCrewEventCreateWithoutOrganizerInput, RunCrewEventUncheckedCreateWithoutOrganizerInput>
  }

  export type RunCrewEventUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: RunCrewEventWhereUniqueInput
    data: XOR<RunCrewEventUpdateWithoutOrganizerInput, RunCrewEventUncheckedUpdateWithoutOrganizerInput>
  }

  export type RunCrewEventUpdateManyWithWhereWithoutOrganizerInput = {
    where: RunCrewEventScalarWhereInput
    data: XOR<RunCrewEventUpdateManyMutationInput, RunCrewEventUncheckedUpdateManyWithoutOrganizerInput>
  }

  export type RunCrewEventScalarWhereInput = {
    AND?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
    OR?: RunCrewEventScalarWhereInput[]
    NOT?: RunCrewEventScalarWhereInput | RunCrewEventScalarWhereInput[]
    id?: StringFilter<"RunCrewEvent"> | string
    runCrewId?: StringFilter<"RunCrewEvent"> | string
    organizerId?: StringFilter<"RunCrewEvent"> | string
    title?: StringFilter<"RunCrewEvent"> | string
    date?: DateTimeFilter<"RunCrewEvent"> | Date | string
    time?: StringFilter<"RunCrewEvent"> | string
    location?: StringFilter<"RunCrewEvent"> | string
    address?: StringNullableFilter<"RunCrewEvent"> | string | null
    description?: StringNullableFilter<"RunCrewEvent"> | string | null
    eventType?: StringNullableFilter<"RunCrewEvent"> | string | null
    createdAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
    updatedAt?: DateTimeFilter<"RunCrewEvent"> | Date | string
  }

  export type RunCrewEventRSVPUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    update: XOR<RunCrewEventRSVPUpdateWithoutAthleteInput, RunCrewEventRSVPUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewEventRSVPCreateWithoutAthleteInput, RunCrewEventRSVPUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewEventRSVPUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    data: XOR<RunCrewEventRSVPUpdateWithoutAthleteInput, RunCrewEventRSVPUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewEventRSVPUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewEventRSVPScalarWhereInput
    data: XOR<RunCrewEventRSVPUpdateManyMutationInput, RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewEventRSVPScalarWhereInput = {
    AND?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
    OR?: RunCrewEventRSVPScalarWhereInput[]
    NOT?: RunCrewEventRSVPScalarWhereInput | RunCrewEventRSVPScalarWhereInput[]
    id?: StringFilter<"RunCrewEventRSVP"> | string
    eventId?: StringFilter<"RunCrewEventRSVP"> | string
    athleteId?: StringFilter<"RunCrewEventRSVP"> | string
    status?: StringFilter<"RunCrewEventRSVP"> | string
    createdAt?: DateTimeFilter<"RunCrewEventRSVP"> | Date | string
  }

  export type RunCrewManagerUpsertWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewManagerWhereUniqueInput
    update: XOR<RunCrewManagerUpdateWithoutAthleteInput, RunCrewManagerUncheckedUpdateWithoutAthleteInput>
    create: XOR<RunCrewManagerCreateWithoutAthleteInput, RunCrewManagerUncheckedCreateWithoutAthleteInput>
  }

  export type RunCrewManagerUpdateWithWhereUniqueWithoutAthleteInput = {
    where: RunCrewManagerWhereUniqueInput
    data: XOR<RunCrewManagerUpdateWithoutAthleteInput, RunCrewManagerUncheckedUpdateWithoutAthleteInput>
  }

  export type RunCrewManagerUpdateManyWithWhereWithoutAthleteInput = {
    where: RunCrewManagerScalarWhereInput
    data: XOR<RunCrewManagerUpdateManyMutationInput, RunCrewManagerUncheckedUpdateManyWithoutAthleteInput>
  }

  export type RunCrewManagerScalarWhereInput = {
    AND?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
    OR?: RunCrewManagerScalarWhereInput[]
    NOT?: RunCrewManagerScalarWhereInput | RunCrewManagerScalarWhereInput[]
    id?: StringFilter<"RunCrewManager"> | string
    runCrewId?: StringFilter<"RunCrewManager"> | string
    athleteId?: StringFilter<"RunCrewManager"> | string
    role?: StringFilter<"RunCrewManager"> | string
    createdAt?: DateTimeFilter<"RunCrewManager"> | Date | string
  }

  export type RaceUpsertWithWhereUniqueWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    update: XOR<RaceUpdateWithoutCreatedByAthleteInput, RaceUncheckedUpdateWithoutCreatedByAthleteInput>
    create: XOR<RaceCreateWithoutCreatedByAthleteInput, RaceUncheckedCreateWithoutCreatedByAthleteInput>
  }

  export type RaceUpdateWithWhereUniqueWithoutCreatedByAthleteInput = {
    where: RaceWhereUniqueInput
    data: XOR<RaceUpdateWithoutCreatedByAthleteInput, RaceUncheckedUpdateWithoutCreatedByAthleteInput>
  }

  export type RaceUpdateManyWithWhereWithoutCreatedByAthleteInput = {
    where: RaceScalarWhereInput
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyWithoutCreatedByAthleteInput>
  }

  export type RaceScalarWhereInput = {
    AND?: RaceScalarWhereInput | RaceScalarWhereInput[]
    OR?: RaceScalarWhereInput[]
    NOT?: RaceScalarWhereInput | RaceScalarWhereInput[]
    id?: StringFilter<"Race"> | string
    raceName?: StringFilter<"Race"> | string
    raceType?: StringFilter<"Race"> | string
    raceDate?: DateTimeFilter<"Race"> | Date | string
    location?: StringNullableFilter<"Race"> | string | null
    distanceMiles?: FloatFilter<"Race"> | number
    registrationUrl?: StringNullableFilter<"Race"> | string | null
    description?: StringNullableFilter<"Race"> | string | null
    courseProfile?: JsonNullableFilter<"Race">
    createdByAthleteId?: StringNullableFilter<"Race"> | string | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
  }

  export type TrainingPlanUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    update: XOR<TrainingPlanUpdateWithoutAthleteInput, TrainingPlanUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingPlanCreateWithoutAthleteInput, TrainingPlanUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingPlanUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingPlanWhereUniqueInput
    data: XOR<TrainingPlanUpdateWithoutAthleteInput, TrainingPlanUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingPlanUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingPlanScalarWhereInput
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingPlanScalarWhereInput = {
    AND?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
    OR?: TrainingPlanScalarWhereInput[]
    NOT?: TrainingPlanScalarWhereInput | TrainingPlanScalarWhereInput[]
    id?: StringFilter<"TrainingPlan"> | string
    athleteId?: StringFilter<"TrainingPlan"> | string
    raceId?: StringFilter<"TrainingPlan"> | string
    goalTime?: StringFilter<"TrainingPlan"> | string
    goalPace?: StringNullableFilter<"TrainingPlan"> | string | null
    baseline5k?: StringFilter<"TrainingPlan"> | string
    baselineWeeklyMileage?: IntNullableFilter<"TrainingPlan"> | number | null
    startDate?: DateTimeFilter<"TrainingPlan"> | Date | string
    totalWeeks?: IntFilter<"TrainingPlan"> | number
    phaseOverview?: JsonNullableFilter<"TrainingPlan">
    weeklyMileagePlan?: JsonNullableFilter<"TrainingPlan">
    weeks?: JsonNullableFilter<"TrainingPlan">
    adaptive5kTime?: StringNullableFilter<"TrainingPlan"> | string | null
    createdAt?: DateTimeFilter<"TrainingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlan"> | Date | string
  }

  export type TrainingDayPlannedUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    update: XOR<TrainingDayPlannedUpdateWithoutAthleteInput, TrainingDayPlannedUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingDayPlannedCreateWithoutAthleteInput, TrainingDayPlannedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayPlannedUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayPlannedWhereUniqueInput
    data: XOR<TrainingDayPlannedUpdateWithoutAthleteInput, TrainingDayPlannedUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingDayPlannedUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingDayPlannedScalarWhereInput
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingDayPlannedScalarWhereInput = {
    AND?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
    OR?: TrainingDayPlannedScalarWhereInput[]
    NOT?: TrainingDayPlannedScalarWhereInput | TrainingDayPlannedScalarWhereInput[]
    id?: StringFilter<"TrainingDayPlanned"> | string
    trainingPlanId?: StringFilter<"TrainingDayPlanned"> | string
    athleteId?: StringFilter<"TrainingDayPlanned"> | string
    date?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    weekIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayIndex?: IntFilter<"TrainingDayPlanned"> | number
    dayName?: StringNullableFilter<"TrainingDayPlanned"> | string | null
    phase?: StringFilter<"TrainingDayPlanned"> | string
    plannedData?: JsonFilter<"TrainingDayPlanned">
    createdAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayPlanned"> | Date | string
  }

  export type TrainingDayExecutedUpsertWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    update: XOR<TrainingDayExecutedUpdateWithoutAthleteInput, TrainingDayExecutedUncheckedUpdateWithoutAthleteInput>
    create: XOR<TrainingDayExecutedCreateWithoutAthleteInput, TrainingDayExecutedUncheckedCreateWithoutAthleteInput>
  }

  export type TrainingDayExecutedUpdateWithWhereUniqueWithoutAthleteInput = {
    where: TrainingDayExecutedWhereUniqueInput
    data: XOR<TrainingDayExecutedUpdateWithoutAthleteInput, TrainingDayExecutedUncheckedUpdateWithoutAthleteInput>
  }

  export type TrainingDayExecutedUpdateManyWithWhereWithoutAthleteInput = {
    where: TrainingDayExecutedScalarWhereInput
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyWithoutAthleteInput>
  }

  export type TrainingDayExecutedScalarWhereInput = {
    AND?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
    OR?: TrainingDayExecutedScalarWhereInput[]
    NOT?: TrainingDayExecutedScalarWhereInput | TrainingDayExecutedScalarWhereInput[]
    id?: StringFilter<"TrainingDayExecuted"> | string
    executionId?: StringFilter<"TrainingDayExecuted"> | string
    athleteId?: StringFilter<"TrainingDayExecuted"> | string
    activityId?: StringNullableFilter<"TrainingDayExecuted"> | string | null
    weekIndex?: IntFilter<"TrainingDayExecuted"> | number
    dayIndex?: IntFilter<"TrainingDayExecuted"> | number
    date?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    plannedData?: JsonNullableFilter<"TrainingDayExecuted">
    analysis?: JsonNullableFilter<"TrainingDayExecuted">
    feedback?: JsonNullableFilter<"TrainingDayExecuted">
    createdAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDayExecuted"> | Date | string
  }

  export type FounderUpsertWithoutAthleteInput = {
    update: XOR<FounderUpdateWithoutAthleteInput, FounderUncheckedUpdateWithoutAthleteInput>
    create: XOR<FounderCreateWithoutAthleteInput, FounderUncheckedCreateWithoutAthleteInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutAthleteInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutAthleteInput, FounderUncheckedUpdateWithoutAthleteInput>
  }

  export type FounderUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type AthleteCreateWithoutActivitiesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutActivitiesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutActivitiesInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
  }

  export type AthleteUpsertWithoutActivitiesInput = {
    update: XOR<AthleteUpdateWithoutActivitiesInput, AthleteUncheckedUpdateWithoutActivitiesInput>
    create: XOR<AthleteCreateWithoutActivitiesInput, AthleteUncheckedCreateWithoutActivitiesInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutActivitiesInput, AthleteUncheckedUpdateWithoutActivitiesInput>
  }

  export type AthleteUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutAdminRunCrewsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutAdminRunCrewsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutAdminRunCrewsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
  }

  export type RunCrewMembershipCreateWithoutRunCrewInput = {
    id?: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewMembershipsInput
  }

  export type RunCrewMembershipUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    create: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMembershipCreateManyRunCrewInputEnvelope = {
    data: RunCrewMembershipCreateManyRunCrewInput | RunCrewMembershipCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewMessageCreateWithoutRunCrewInput = {
    id?: string
    content: string
    createdAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewMessagesInput
  }

  export type RunCrewMessageUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewMessageCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewMessageWhereUniqueInput
    create: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMessageCreateManyRunCrewInputEnvelope = {
    data: RunCrewMessageCreateManyRunCrewInput | RunCrewMessageCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewAnnouncementCreateWithoutRunCrewInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AthleteCreateNestedOneWithoutRunCrewAnnouncementsInput
  }

  export type RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput = {
    id?: string
    authorId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewAnnouncementCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    create: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewAnnouncementCreateManyRunCrewInputEnvelope = {
    data: RunCrewAnnouncementCreateManyRunCrewInput | RunCrewAnnouncementCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewLeaderboardCreateWithoutRunCrewInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewLeaderboardsInput
  }

  export type RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    create: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardCreateManyRunCrewInputEnvelope = {
    data: RunCrewLeaderboardCreateManyRunCrewInput | RunCrewLeaderboardCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewRunCreateWithoutRunCrewInput = {
    id?: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: AthleteCreateNestedOneWithoutRunCrewRunsInput
    rsvps?: RunCrewRunRSVPCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunUncheckedCreateWithoutRunCrewInput = {
    id?: string
    createdById: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutRunInput
  }

  export type RunCrewRunCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewRunWhereUniqueInput
    create: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewRunCreateManyRunCrewInputEnvelope = {
    data: RunCrewRunCreateManyRunCrewInput | RunCrewRunCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewEventCreateWithoutRunCrewInput = {
    id?: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: AthleteCreateNestedOneWithoutRunCrewEventsInput
    rsvps?: RunCrewEventRSVPCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventUncheckedCreateWithoutRunCrewInput = {
    id?: string
    organizerId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutEventInput
  }

  export type RunCrewEventCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewEventWhereUniqueInput
    create: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewEventCreateManyRunCrewInputEnvelope = {
    data: RunCrewEventCreateManyRunCrewInput | RunCrewEventCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewManagerCreateWithoutRunCrewInput = {
    id?: string
    role: string
    createdAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewManagersInput
  }

  export type RunCrewManagerUncheckedCreateWithoutRunCrewInput = {
    id?: string
    athleteId: string
    role: string
    createdAt?: Date | string
  }

  export type RunCrewManagerCreateOrConnectWithoutRunCrewInput = {
    where: RunCrewManagerWhereUniqueInput
    create: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewManagerCreateManyRunCrewInputEnvelope = {
    data: RunCrewManagerCreateManyRunCrewInput | RunCrewManagerCreateManyRunCrewInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutAdminRunCrewsInput = {
    update: XOR<AthleteUpdateWithoutAdminRunCrewsInput, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
    create: XOR<AthleteCreateWithoutAdminRunCrewsInput, AthleteUncheckedCreateWithoutAdminRunCrewsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutAdminRunCrewsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutAdminRunCrewsInput, AthleteUncheckedUpdateWithoutAdminRunCrewsInput>
  }

  export type AthleteUpdateWithoutAdminRunCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutAdminRunCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewMembershipUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    update: XOR<RunCrewMembershipUpdateWithoutRunCrewInput, RunCrewMembershipUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewMembershipCreateWithoutRunCrewInput, RunCrewMembershipUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMembershipUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMembershipWhereUniqueInput
    data: XOR<RunCrewMembershipUpdateWithoutRunCrewInput, RunCrewMembershipUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewMembershipUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewMembershipScalarWhereInput
    data: XOR<RunCrewMembershipUpdateManyMutationInput, RunCrewMembershipUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewMessageUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMessageWhereUniqueInput
    update: XOR<RunCrewMessageUpdateWithoutRunCrewInput, RunCrewMessageUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewMessageCreateWithoutRunCrewInput, RunCrewMessageUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewMessageUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewMessageWhereUniqueInput
    data: XOR<RunCrewMessageUpdateWithoutRunCrewInput, RunCrewMessageUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewMessageUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewMessageScalarWhereInput
    data: XOR<RunCrewMessageUpdateManyMutationInput, RunCrewMessageUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewAnnouncementUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    update: XOR<RunCrewAnnouncementUpdateWithoutRunCrewInput, RunCrewAnnouncementUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewAnnouncementCreateWithoutRunCrewInput, RunCrewAnnouncementUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewAnnouncementUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewAnnouncementWhereUniqueInput
    data: XOR<RunCrewAnnouncementUpdateWithoutRunCrewInput, RunCrewAnnouncementUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewAnnouncementUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewAnnouncementScalarWhereInput
    data: XOR<RunCrewAnnouncementUpdateManyMutationInput, RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    update: XOR<RunCrewLeaderboardUpdateWithoutRunCrewInput, RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewLeaderboardCreateWithoutRunCrewInput, RunCrewLeaderboardUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewLeaderboardWhereUniqueInput
    data: XOR<RunCrewLeaderboardUpdateWithoutRunCrewInput, RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewLeaderboardUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewLeaderboardScalarWhereInput
    data: XOR<RunCrewLeaderboardUpdateManyMutationInput, RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewRunUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewRunWhereUniqueInput
    update: XOR<RunCrewRunUpdateWithoutRunCrewInput, RunCrewRunUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewRunCreateWithoutRunCrewInput, RunCrewRunUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewRunUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewRunWhereUniqueInput
    data: XOR<RunCrewRunUpdateWithoutRunCrewInput, RunCrewRunUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewRunUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewRunScalarWhereInput
    data: XOR<RunCrewRunUpdateManyMutationInput, RunCrewRunUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewEventUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewEventWhereUniqueInput
    update: XOR<RunCrewEventUpdateWithoutRunCrewInput, RunCrewEventUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewEventCreateWithoutRunCrewInput, RunCrewEventUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewEventUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewEventWhereUniqueInput
    data: XOR<RunCrewEventUpdateWithoutRunCrewInput, RunCrewEventUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewEventUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewEventScalarWhereInput
    data: XOR<RunCrewEventUpdateManyMutationInput, RunCrewEventUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewManagerUpsertWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewManagerWhereUniqueInput
    update: XOR<RunCrewManagerUpdateWithoutRunCrewInput, RunCrewManagerUncheckedUpdateWithoutRunCrewInput>
    create: XOR<RunCrewManagerCreateWithoutRunCrewInput, RunCrewManagerUncheckedCreateWithoutRunCrewInput>
  }

  export type RunCrewManagerUpdateWithWhereUniqueWithoutRunCrewInput = {
    where: RunCrewManagerWhereUniqueInput
    data: XOR<RunCrewManagerUpdateWithoutRunCrewInput, RunCrewManagerUncheckedUpdateWithoutRunCrewInput>
  }

  export type RunCrewManagerUpdateManyWithWhereWithoutRunCrewInput = {
    where: RunCrewManagerScalarWhereInput
    data: XOR<RunCrewManagerUpdateManyMutationInput, RunCrewManagerUncheckedUpdateManyWithoutRunCrewInput>
  }

  export type RunCrewCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutMembershipsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
  }

  export type AthleteCreateWithoutRunCrewMembershipsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewMembershipsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewMembershipsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
  }

  export type RunCrewUpsertWithoutMembershipsInput = {
    update: XOR<RunCrewUpdateWithoutMembershipsInput, RunCrewUncheckedUpdateWithoutMembershipsInput>
    create: XOR<RunCrewCreateWithoutMembershipsInput, RunCrewUncheckedCreateWithoutMembershipsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutMembershipsInput, RunCrewUncheckedUpdateWithoutMembershipsInput>
  }

  export type RunCrewUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewMembershipsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewMembershipsInput, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
    create: XOR<AthleteCreateWithoutRunCrewMembershipsInput, AthleteUncheckedCreateWithoutRunCrewMembershipsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewMembershipsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewMembershipsInput, AthleteUncheckedUpdateWithoutRunCrewMembershipsInput>
  }

  export type AthleteUpdateWithoutRunCrewMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutMessagesInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutMessagesInput, RunCrewUncheckedCreateWithoutMessagesInput>
  }

  export type AthleteCreateWithoutRunCrewMessagesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewMessagesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewMessagesInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewMessagesInput, AthleteUncheckedCreateWithoutRunCrewMessagesInput>
  }

  export type RunCrewUpsertWithoutMessagesInput = {
    update: XOR<RunCrewUpdateWithoutMessagesInput, RunCrewUncheckedUpdateWithoutMessagesInput>
    create: XOR<RunCrewCreateWithoutMessagesInput, RunCrewUncheckedCreateWithoutMessagesInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutMessagesInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutMessagesInput, RunCrewUncheckedUpdateWithoutMessagesInput>
  }

  export type RunCrewUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewMessagesInput = {
    update: XOR<AthleteUpdateWithoutRunCrewMessagesInput, AthleteUncheckedUpdateWithoutRunCrewMessagesInput>
    create: XOR<AthleteCreateWithoutRunCrewMessagesInput, AthleteUncheckedCreateWithoutRunCrewMessagesInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewMessagesInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewMessagesInput, AthleteUncheckedUpdateWithoutRunCrewMessagesInput>
  }

  export type AthleteUpdateWithoutRunCrewMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutAnnouncementsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutAnnouncementsInput, RunCrewUncheckedCreateWithoutAnnouncementsInput>
  }

  export type AthleteCreateWithoutRunCrewAnnouncementsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewAnnouncementsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewAnnouncementsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewAnnouncementsInput, AthleteUncheckedCreateWithoutRunCrewAnnouncementsInput>
  }

  export type RunCrewUpsertWithoutAnnouncementsInput = {
    update: XOR<RunCrewUpdateWithoutAnnouncementsInput, RunCrewUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<RunCrewCreateWithoutAnnouncementsInput, RunCrewUncheckedCreateWithoutAnnouncementsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutAnnouncementsInput, RunCrewUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type RunCrewUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewAnnouncementsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewAnnouncementsInput, AthleteUncheckedUpdateWithoutRunCrewAnnouncementsInput>
    create: XOR<AthleteCreateWithoutRunCrewAnnouncementsInput, AthleteUncheckedCreateWithoutRunCrewAnnouncementsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewAnnouncementsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewAnnouncementsInput, AthleteUncheckedUpdateWithoutRunCrewAnnouncementsInput>
  }

  export type AthleteUpdateWithoutRunCrewAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type AthleteCreateWithoutRunCrewLeaderboardsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewLeaderboardsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
  }

  export type RunCrewUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<RunCrewUpdateWithoutLeaderboardEntriesInput, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<RunCrewCreateWithoutLeaderboardEntriesInput, RunCrewUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutLeaderboardEntriesInput, RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type RunCrewUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewLeaderboardsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewLeaderboardsInput, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
    create: XOR<AthleteCreateWithoutRunCrewLeaderboardsInput, AthleteUncheckedCreateWithoutRunCrewLeaderboardsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewLeaderboardsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewLeaderboardsInput, AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput>
  }

  export type AthleteUpdateWithoutRunCrewLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewLeaderboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutRunsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutRunsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutRunsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutRunsInput, RunCrewUncheckedCreateWithoutRunsInput>
  }

  export type AthleteCreateWithoutRunCrewRunsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewRunsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewRunsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewRunsInput, AthleteUncheckedCreateWithoutRunCrewRunsInput>
  }

  export type RunCrewRunRSVPCreateWithoutRunInput = {
    id?: string
    status: string
    createdAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewRunRSVPsInput
  }

  export type RunCrewRunRSVPUncheckedCreateWithoutRunInput = {
    id?: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewRunRSVPCreateOrConnectWithoutRunInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    create: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput>
  }

  export type RunCrewRunRSVPCreateManyRunInputEnvelope = {
    data: RunCrewRunRSVPCreateManyRunInput | RunCrewRunRSVPCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewUpsertWithoutRunsInput = {
    update: XOR<RunCrewUpdateWithoutRunsInput, RunCrewUncheckedUpdateWithoutRunsInput>
    create: XOR<RunCrewCreateWithoutRunsInput, RunCrewUncheckedCreateWithoutRunsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutRunsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutRunsInput, RunCrewUncheckedUpdateWithoutRunsInput>
  }

  export type RunCrewUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewRunsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewRunsInput, AthleteUncheckedUpdateWithoutRunCrewRunsInput>
    create: XOR<AthleteCreateWithoutRunCrewRunsInput, AthleteUncheckedCreateWithoutRunCrewRunsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewRunsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewRunsInput, AthleteUncheckedUpdateWithoutRunCrewRunsInput>
  }

  export type AthleteUpdateWithoutRunCrewRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewRunRSVPUpsertWithWhereUniqueWithoutRunInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    update: XOR<RunCrewRunRSVPUpdateWithoutRunInput, RunCrewRunRSVPUncheckedUpdateWithoutRunInput>
    create: XOR<RunCrewRunRSVPCreateWithoutRunInput, RunCrewRunRSVPUncheckedCreateWithoutRunInput>
  }

  export type RunCrewRunRSVPUpdateWithWhereUniqueWithoutRunInput = {
    where: RunCrewRunRSVPWhereUniqueInput
    data: XOR<RunCrewRunRSVPUpdateWithoutRunInput, RunCrewRunRSVPUncheckedUpdateWithoutRunInput>
  }

  export type RunCrewRunRSVPUpdateManyWithWhereWithoutRunInput = {
    where: RunCrewRunRSVPScalarWhereInput
    data: XOR<RunCrewRunRSVPUpdateManyMutationInput, RunCrewRunRSVPUncheckedUpdateManyWithoutRunInput>
  }

  export type RunCrewRunCreateWithoutRsvpsInput = {
    id?: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutRunsInput
    createdBy: AthleteCreateNestedOneWithoutRunCrewRunsInput
  }

  export type RunCrewRunUncheckedCreateWithoutRsvpsInput = {
    id?: string
    runCrewId: string
    createdById: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewRunCreateOrConnectWithoutRsvpsInput = {
    where: RunCrewRunWhereUniqueInput
    create: XOR<RunCrewRunCreateWithoutRsvpsInput, RunCrewRunUncheckedCreateWithoutRsvpsInput>
  }

  export type AthleteCreateWithoutRunCrewRunRSVPsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewRunRSVPsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewRunRSVPsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewRunRSVPsInput, AthleteUncheckedCreateWithoutRunCrewRunRSVPsInput>
  }

  export type RunCrewRunUpsertWithoutRsvpsInput = {
    update: XOR<RunCrewRunUpdateWithoutRsvpsInput, RunCrewRunUncheckedUpdateWithoutRsvpsInput>
    create: XOR<RunCrewRunCreateWithoutRsvpsInput, RunCrewRunUncheckedCreateWithoutRsvpsInput>
    where?: RunCrewRunWhereInput
  }

  export type RunCrewRunUpdateToOneWithWhereWithoutRsvpsInput = {
    where?: RunCrewRunWhereInput
    data: XOR<RunCrewRunUpdateWithoutRsvpsInput, RunCrewRunUncheckedUpdateWithoutRsvpsInput>
  }

  export type RunCrewRunUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutRunsNestedInput
    createdBy?: AthleteUpdateOneRequiredWithoutRunCrewRunsNestedInput
  }

  export type RunCrewRunUncheckedUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteUpsertWithoutRunCrewRunRSVPsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewRunRSVPsInput, AthleteUncheckedUpdateWithoutRunCrewRunRSVPsInput>
    create: XOR<AthleteCreateWithoutRunCrewRunRSVPsInput, AthleteUncheckedCreateWithoutRunCrewRunRSVPsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewRunRSVPsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewRunRSVPsInput, AthleteUncheckedUpdateWithoutRunCrewRunRSVPsInput>
  }

  export type AthleteUpdateWithoutRunCrewRunRSVPsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewRunRSVPsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    managers?: RunCrewManagerUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutEventsInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutEventsInput, RunCrewUncheckedCreateWithoutEventsInput>
  }

  export type AthleteCreateWithoutRunCrewEventsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewEventsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewEventsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewEventsInput, AthleteUncheckedCreateWithoutRunCrewEventsInput>
  }

  export type RunCrewEventRSVPCreateWithoutEventInput = {
    id?: string
    status: string
    createdAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutRunCrewEventRSVPsInput
  }

  export type RunCrewEventRSVPUncheckedCreateWithoutEventInput = {
    id?: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventRSVPCreateOrConnectWithoutEventInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    create: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput>
  }

  export type RunCrewEventRSVPCreateManyEventInputEnvelope = {
    data: RunCrewEventRSVPCreateManyEventInput | RunCrewEventRSVPCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type RunCrewUpsertWithoutEventsInput = {
    update: XOR<RunCrewUpdateWithoutEventsInput, RunCrewUncheckedUpdateWithoutEventsInput>
    create: XOR<RunCrewCreateWithoutEventsInput, RunCrewUncheckedCreateWithoutEventsInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutEventsInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutEventsInput, RunCrewUncheckedUpdateWithoutEventsInput>
  }

  export type RunCrewUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewEventsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewEventsInput, AthleteUncheckedUpdateWithoutRunCrewEventsInput>
    create: XOR<AthleteCreateWithoutRunCrewEventsInput, AthleteUncheckedCreateWithoutRunCrewEventsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewEventsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewEventsInput, AthleteUncheckedUpdateWithoutRunCrewEventsInput>
  }

  export type AthleteUpdateWithoutRunCrewEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewEventRSVPUpsertWithWhereUniqueWithoutEventInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    update: XOR<RunCrewEventRSVPUpdateWithoutEventInput, RunCrewEventRSVPUncheckedUpdateWithoutEventInput>
    create: XOR<RunCrewEventRSVPCreateWithoutEventInput, RunCrewEventRSVPUncheckedCreateWithoutEventInput>
  }

  export type RunCrewEventRSVPUpdateWithWhereUniqueWithoutEventInput = {
    where: RunCrewEventRSVPWhereUniqueInput
    data: XOR<RunCrewEventRSVPUpdateWithoutEventInput, RunCrewEventRSVPUncheckedUpdateWithoutEventInput>
  }

  export type RunCrewEventRSVPUpdateManyWithWhereWithoutEventInput = {
    where: RunCrewEventRSVPScalarWhereInput
    data: XOR<RunCrewEventRSVPUpdateManyMutationInput, RunCrewEventRSVPUncheckedUpdateManyWithoutEventInput>
  }

  export type RunCrewEventCreateWithoutRsvpsInput = {
    id?: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    runCrew: RunCrewCreateNestedOneWithoutEventsInput
    organizer: AthleteCreateNestedOneWithoutRunCrewEventsInput
  }

  export type RunCrewEventUncheckedCreateWithoutRsvpsInput = {
    id?: string
    runCrewId: string
    organizerId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewEventCreateOrConnectWithoutRsvpsInput = {
    where: RunCrewEventWhereUniqueInput
    create: XOR<RunCrewEventCreateWithoutRsvpsInput, RunCrewEventUncheckedCreateWithoutRsvpsInput>
  }

  export type AthleteCreateWithoutRunCrewEventRSVPsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewEventRSVPsInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewEventRSVPsInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewEventRSVPsInput, AthleteUncheckedCreateWithoutRunCrewEventRSVPsInput>
  }

  export type RunCrewEventUpsertWithoutRsvpsInput = {
    update: XOR<RunCrewEventUpdateWithoutRsvpsInput, RunCrewEventUncheckedUpdateWithoutRsvpsInput>
    create: XOR<RunCrewEventCreateWithoutRsvpsInput, RunCrewEventUncheckedCreateWithoutRsvpsInput>
    where?: RunCrewEventWhereInput
  }

  export type RunCrewEventUpdateToOneWithWhereWithoutRsvpsInput = {
    where?: RunCrewEventWhereInput
    data: XOR<RunCrewEventUpdateWithoutRsvpsInput, RunCrewEventUncheckedUpdateWithoutRsvpsInput>
  }

  export type RunCrewEventUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutEventsNestedInput
    organizer?: AthleteUpdateOneRequiredWithoutRunCrewEventsNestedInput
  }

  export type RunCrewEventUncheckedUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    organizerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteUpsertWithoutRunCrewEventRSVPsInput = {
    update: XOR<AthleteUpdateWithoutRunCrewEventRSVPsInput, AthleteUncheckedUpdateWithoutRunCrewEventRSVPsInput>
    create: XOR<AthleteCreateWithoutRunCrewEventRSVPsInput, AthleteUncheckedCreateWithoutRunCrewEventRSVPsInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewEventRSVPsInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewEventRSVPsInput, AthleteUncheckedUpdateWithoutRunCrewEventRSVPsInput>
  }

  export type AthleteUpdateWithoutRunCrewEventRSVPsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewEventRSVPsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RunCrewCreateWithoutManagersInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AthleteCreateNestedOneWithoutAdminRunCrewsInput
    memberships?: RunCrewMembershipCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewUncheckedCreateWithoutManagersInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    runcrewAdminId?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutRunCrewInput
    messages?: RunCrewMessageUncheckedCreateNestedManyWithoutRunCrewInput
    announcements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutRunCrewInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutRunCrewInput
    runs?: RunCrewRunUncheckedCreateNestedManyWithoutRunCrewInput
    events?: RunCrewEventUncheckedCreateNestedManyWithoutRunCrewInput
  }

  export type RunCrewCreateOrConnectWithoutManagersInput = {
    where: RunCrewWhereUniqueInput
    create: XOR<RunCrewCreateWithoutManagersInput, RunCrewUncheckedCreateWithoutManagersInput>
  }

  export type AthleteCreateWithoutRunCrewManagersInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutRunCrewManagersInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutRunCrewManagersInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutRunCrewManagersInput, AthleteUncheckedCreateWithoutRunCrewManagersInput>
  }

  export type RunCrewUpsertWithoutManagersInput = {
    update: XOR<RunCrewUpdateWithoutManagersInput, RunCrewUncheckedUpdateWithoutManagersInput>
    create: XOR<RunCrewCreateWithoutManagersInput, RunCrewUncheckedCreateWithoutManagersInput>
    where?: RunCrewWhereInput
  }

  export type RunCrewUpdateToOneWithWhereWithoutManagersInput = {
    where?: RunCrewWhereInput
    data: XOR<RunCrewUpdateWithoutManagersInput, RunCrewUncheckedUpdateWithoutManagersInput>
  }

  export type RunCrewUpdateWithoutManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AthleteUpdateOneWithoutAdminRunCrewsNestedInput
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    runcrewAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type AthleteUpsertWithoutRunCrewManagersInput = {
    update: XOR<AthleteUpdateWithoutRunCrewManagersInput, AthleteUncheckedUpdateWithoutRunCrewManagersInput>
    create: XOR<AthleteCreateWithoutRunCrewManagersInput, AthleteUncheckedCreateWithoutRunCrewManagersInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutRunCrewManagersInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutRunCrewManagersInput, AthleteUncheckedUpdateWithoutRunCrewManagersInput>
  }

  export type AthleteUpdateWithoutRunCrewManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutRunCrewManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutCreatedRacesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutCreatedRacesInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutCreatedRacesInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
  }

  export type TrainingPlanCreateWithoutRaceInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutRaceInput = {
    id?: string
    athleteId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput>
  }

  export type TrainingPlanCreateManyRaceInputEnvelope = {
    data: TrainingPlanCreateManyRaceInput | TrainingPlanCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutCreatedRacesInput = {
    update: XOR<AthleteUpdateWithoutCreatedRacesInput, AthleteUncheckedUpdateWithoutCreatedRacesInput>
    create: XOR<AthleteCreateWithoutCreatedRacesInput, AthleteUncheckedCreateWithoutCreatedRacesInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutCreatedRacesInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutCreatedRacesInput, AthleteUncheckedUpdateWithoutCreatedRacesInput>
  }

  export type AthleteUpdateWithoutCreatedRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutCreatedRacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type TrainingPlanUpsertWithWhereUniqueWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    update: XOR<TrainingPlanUpdateWithoutRaceInput, TrainingPlanUncheckedUpdateWithoutRaceInput>
    create: XOR<TrainingPlanCreateWithoutRaceInput, TrainingPlanUncheckedCreateWithoutRaceInput>
  }

  export type TrainingPlanUpdateWithWhereUniqueWithoutRaceInput = {
    where: TrainingPlanWhereUniqueInput
    data: XOR<TrainingPlanUpdateWithoutRaceInput, TrainingPlanUncheckedUpdateWithoutRaceInput>
  }

  export type TrainingPlanUpdateManyWithWhereWithoutRaceInput = {
    where: TrainingPlanScalarWhereInput
    data: XOR<TrainingPlanUpdateManyMutationInput, TrainingPlanUncheckedUpdateManyWithoutRaceInput>
  }

  export type AthleteCreateWithoutTrainingPlansInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutTrainingPlansInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutTrainingPlansInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
  }

  export type RaceCreateWithoutTrainingPlansInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAthlete?: AthleteCreateNestedOneWithoutCreatedRacesInput
  }

  export type RaceUncheckedCreateWithoutTrainingPlansInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceCreateOrConnectWithoutTrainingPlansInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
  }

  export type TrainingDayPlannedCreateWithoutTrainingPlanInput = {
    id?: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutPlannedDaysInput
  }

  export type TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput = {
    id?: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateOrConnectWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    create: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedCreateManyTrainingPlanInputEnvelope = {
    data: TrainingDayPlannedCreateManyTrainingPlanInput | TrainingDayPlannedCreateManyTrainingPlanInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanExecutionCreateWithoutTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type TrainingPlanExecutionCreateOrConnectWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    create: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionCreateManyTrainingPlanInputEnvelope = {
    data: TrainingPlanExecutionCreateManyTrainingPlanInput | TrainingPlanExecutionCreateManyTrainingPlanInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutTrainingPlansInput = {
    update: XOR<AthleteUpdateWithoutTrainingPlansInput, AthleteUncheckedUpdateWithoutTrainingPlansInput>
    create: XOR<AthleteCreateWithoutTrainingPlansInput, AthleteUncheckedCreateWithoutTrainingPlansInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutTrainingPlansInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutTrainingPlansInput, AthleteUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type AthleteUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type RaceUpsertWithoutTrainingPlansInput = {
    update: XOR<RaceUpdateWithoutTrainingPlansInput, RaceUncheckedUpdateWithoutTrainingPlansInput>
    create: XOR<RaceCreateWithoutTrainingPlansInput, RaceUncheckedCreateWithoutTrainingPlansInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutTrainingPlansInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutTrainingPlansInput, RaceUncheckedUpdateWithoutTrainingPlansInput>
  }

  export type RaceUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAthlete?: AthleteUpdateOneWithoutCreatedRacesNestedInput
  }

  export type RaceUncheckedUpdateWithoutTrainingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdByAthleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUpsertWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    update: XOR<TrainingDayPlannedUpdateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput>
    create: XOR<TrainingDayPlannedCreateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedUpdateWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingDayPlannedWhereUniqueInput
    data: XOR<TrainingDayPlannedUpdateWithoutTrainingPlanInput, TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput>
  }

  export type TrainingDayPlannedUpdateManyWithWhereWithoutTrainingPlanInput = {
    where: TrainingDayPlannedScalarWhereInput
    data: XOR<TrainingDayPlannedUpdateManyMutationInput, TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpsertWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    update: XOR<TrainingPlanExecutionUpdateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput>
    create: XOR<TrainingPlanExecutionCreateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedCreateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpdateWithWhereUniqueWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    data: XOR<TrainingPlanExecutionUpdateWithoutTrainingPlanInput, TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionUpdateManyWithWhereWithoutTrainingPlanInput = {
    where: TrainingPlanExecutionScalarWhereInput
    data: XOR<TrainingPlanExecutionUpdateManyMutationInput, TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanInput>
  }

  export type TrainingPlanExecutionScalarWhereInput = {
    AND?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
    OR?: TrainingPlanExecutionScalarWhereInput[]
    NOT?: TrainingPlanExecutionScalarWhereInput | TrainingPlanExecutionScalarWhereInput[]
    id?: StringFilter<"TrainingPlanExecution"> | string
    trainingPlanId?: StringFilter<"TrainingPlanExecution"> | string
    startedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    status?: StringFilter<"TrainingPlanExecution"> | string
    createdAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingPlanExecution"> | Date | string
  }

  export type TrainingPlanCreateWithoutPlannedDaysInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    executions?: TrainingPlanExecutionCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutPlannedDaysInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: TrainingPlanExecutionUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutPlannedDaysInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
  }

  export type AthleteCreateWithoutPlannedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutPlannedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutPlannedDaysInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
  }

  export type TrainingPlanUpsertWithoutPlannedDaysInput = {
    update: XOR<TrainingPlanUpdateWithoutPlannedDaysInput, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
    create: XOR<TrainingPlanCreateWithoutPlannedDaysInput, TrainingPlanUncheckedCreateWithoutPlannedDaysInput>
    where?: TrainingPlanWhereInput
  }

  export type TrainingPlanUpdateToOneWithWhereWithoutPlannedDaysInput = {
    where?: TrainingPlanWhereInput
    data: XOR<TrainingPlanUpdateWithoutPlannedDaysInput, TrainingPlanUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type TrainingPlanUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type AthleteUpsertWithoutPlannedDaysInput = {
    update: XOR<AthleteUpdateWithoutPlannedDaysInput, AthleteUncheckedUpdateWithoutPlannedDaysInput>
    create: XOR<AthleteCreateWithoutPlannedDaysInput, AthleteUncheckedCreateWithoutPlannedDaysInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutPlannedDaysInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutPlannedDaysInput, AthleteUncheckedUpdateWithoutPlannedDaysInput>
  }

  export type AthleteUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutPlannedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type TrainingPlanCreateWithoutExecutionsInput = {
    id?: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutTrainingPlansInput
    race: RaceCreateNestedOneWithoutTrainingPlansInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanUncheckedCreateWithoutExecutionsInput = {
    id?: string
    athleteId: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutTrainingPlanInput
  }

  export type TrainingPlanCreateOrConnectWithoutExecutionsInput = {
    where: TrainingPlanWhereUniqueInput
    create: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
  }

  export type TrainingDayExecutedCreateWithoutExecutionInput = {
    id?: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutExecutedDaysInput
  }

  export type TrainingDayExecutedUncheckedCreateWithoutExecutionInput = {
    id?: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateOrConnectWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    create: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput>
  }

  export type TrainingDayExecutedCreateManyExecutionInputEnvelope = {
    data: TrainingDayExecutedCreateManyExecutionInput | TrainingDayExecutedCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPlanUpsertWithoutExecutionsInput = {
    update: XOR<TrainingPlanUpdateWithoutExecutionsInput, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TrainingPlanCreateWithoutExecutionsInput, TrainingPlanUncheckedCreateWithoutExecutionsInput>
    where?: TrainingPlanWhereInput
  }

  export type TrainingPlanUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TrainingPlanWhereInput
    data: XOR<TrainingPlanUpdateWithoutExecutionsInput, TrainingPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type TrainingPlanUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingDayExecutedUpsertWithWhereUniqueWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    update: XOR<TrainingDayExecutedUpdateWithoutExecutionInput, TrainingDayExecutedUncheckedUpdateWithoutExecutionInput>
    create: XOR<TrainingDayExecutedCreateWithoutExecutionInput, TrainingDayExecutedUncheckedCreateWithoutExecutionInput>
  }

  export type TrainingDayExecutedUpdateWithWhereUniqueWithoutExecutionInput = {
    where: TrainingDayExecutedWhereUniqueInput
    data: XOR<TrainingDayExecutedUpdateWithoutExecutionInput, TrainingDayExecutedUncheckedUpdateWithoutExecutionInput>
  }

  export type TrainingDayExecutedUpdateManyWithWhereWithoutExecutionInput = {
    where: TrainingDayExecutedScalarWhereInput
    data: XOR<TrainingDayExecutedUpdateManyMutationInput, TrainingDayExecutedUncheckedUpdateManyWithoutExecutionInput>
  }

  export type TrainingPlanExecutionCreateWithoutExecutedDaysInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingPlan: TrainingPlanCreateNestedOneWithoutExecutionsInput
  }

  export type TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput = {
    id?: string
    trainingPlanId: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionCreateOrConnectWithoutExecutedDaysInput = {
    where: TrainingPlanExecutionWhereUniqueInput
    create: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
  }

  export type AthleteCreateWithoutExecutedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    founder?: FounderCreateNestedOneWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutExecutedDaysInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    founder?: FounderUncheckedCreateNestedOneWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutExecutedDaysInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
  }

  export type TrainingPlanExecutionUpsertWithoutExecutedDaysInput = {
    update: XOR<TrainingPlanExecutionUpdateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
    create: XOR<TrainingPlanExecutionCreateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedCreateWithoutExecutedDaysInput>
    where?: TrainingPlanExecutionWhereInput
  }

  export type TrainingPlanExecutionUpdateToOneWithWhereWithoutExecutedDaysInput = {
    where?: TrainingPlanExecutionWhereInput
    data: XOR<TrainingPlanExecutionUpdateWithoutExecutedDaysInput, TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type TrainingPlanExecutionUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteUpsertWithoutExecutedDaysInput = {
    update: XOR<AthleteUpdateWithoutExecutedDaysInput, AthleteUncheckedUpdateWithoutExecutedDaysInput>
    create: XOR<AthleteCreateWithoutExecutedDaysInput, AthleteUncheckedCreateWithoutExecutedDaysInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutExecutedDaysInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutExecutedDaysInput, AthleteUncheckedUpdateWithoutExecutedDaysInput>
  }

  export type AthleteUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutExecutedDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    founder?: FounderUncheckedUpdateOneWithoutAthleteNestedInput
  }

  export type AthleteCreateWithoutFounderInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedCreateNestedManyWithoutAthleteInput
  }

  export type AthleteUncheckedCreateWithoutFounderInput = {
    id?: string
    firebaseId: string
    firstName?: string | null
    lastName?: string | null
    email: string
    phoneNumber?: string | null
    gofastHandle?: string | null
    birthday?: Date | string | null
    gender?: string | null
    city?: string | null
    state?: string | null
    primarySport?: string | null
    photoURL?: string | null
    bio?: string | null
    instagram?: string | null
    currentPace?: string | null
    weeklyMileage?: number | null
    trainingGoal?: string | null
    targetRace?: string | null
    trainingStartDate?: Date | string | null
    preferredDistance?: string | null
    timePreference?: string | null
    paceRange?: string | null
    runningGoals?: string | null
    garmin_user_id?: string | null
    garmin_access_token?: string | null
    garmin_refresh_token?: string | null
    garmin_expires_in?: number | null
    garmin_scope?: string | null
    garmin_connected_at?: Date | string | null
    garmin_last_sync_at?: Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: boolean
    garmin_disconnected_at?: Date | string | null
    strava_id?: number | null
    strava_access_token?: string | null
    strava_refresh_token?: string | null
    strava_expires_at?: number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string | null
    activities?: AthleteActivityUncheckedCreateNestedManyWithoutAthleteInput
    adminRunCrews?: RunCrewUncheckedCreateNestedManyWithoutAdminInput
    runCrewMemberships?: RunCrewMembershipUncheckedCreateNestedManyWithoutAthleteInput
    runCrewMessages?: RunCrewMessageUncheckedCreateNestedManyWithoutAthleteInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedCreateNestedManyWithoutAthleteInput
    runCrewRuns?: RunCrewRunUncheckedCreateNestedManyWithoutCreatedByInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewEvents?: RunCrewEventUncheckedCreateNestedManyWithoutOrganizerInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedCreateNestedManyWithoutAthleteInput
    runCrewManagers?: RunCrewManagerUncheckedCreateNestedManyWithoutAthleteInput
    createdRaces?: RaceUncheckedCreateNestedManyWithoutCreatedByAthleteInput
    trainingPlans?: TrainingPlanUncheckedCreateNestedManyWithoutAthleteInput
    plannedDays?: TrainingDayPlannedUncheckedCreateNestedManyWithoutAthleteInput
    executedDays?: TrainingDayExecutedUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type AthleteCreateOrConnectWithoutFounderInput = {
    where: AthleteWhereUniqueInput
    create: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskCreateWithoutFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskUncheckedCreateWithoutFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderTaskCreateOrConnectWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    create: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskCreateManyFounderInputEnvelope = {
    data: FounderTaskCreateManyFounderInput | FounderTaskCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type CrmContactCreateWithoutFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUncheckedCreateWithoutFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactCreateOrConnectWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    create: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput>
  }

  export type CrmContactCreateManyFounderInputEnvelope = {
    data: CrmContactCreateManyFounderInput | CrmContactCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapItemCreateWithoutFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUncheckedCreateWithoutFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateOrConnectWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    create: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput>
  }

  export type RoadmapItemCreateManyFounderInputEnvelope = {
    data: RoadmapItemCreateManyFounderInput | RoadmapItemCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFounderCreateWithoutFounderInput = {
    id?: string
    role?: string | null
    joinedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFoundersInput
  }

  export type CompanyFounderUncheckedCreateWithoutFounderInput = {
    id?: string
    companyId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type CompanyFounderCreateOrConnectWithoutFounderInput = {
    where: CompanyFounderWhereUniqueInput
    create: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput>
  }

  export type CompanyFounderCreateManyFounderInputEnvelope = {
    data: CompanyFounderCreateManyFounderInput | CompanyFounderCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutTasksInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutFounderInput = {
    id?: string
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type TaskCreateOrConnectWithoutFounderInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput>
  }

  export type TaskCreateManyFounderInputEnvelope = {
    data: TaskCreateManyFounderInput | TaskCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type AthleteUpsertWithoutFounderInput = {
    update: XOR<AthleteUpdateWithoutFounderInput, AthleteUncheckedUpdateWithoutFounderInput>
    create: XOR<AthleteCreateWithoutFounderInput, AthleteUncheckedCreateWithoutFounderInput>
    where?: AthleteWhereInput
  }

  export type AthleteUpdateToOneWithWhereWithoutFounderInput = {
    where?: AthleteWhereInput
    data: XOR<AthleteUpdateWithoutFounderInput, AthleteUncheckedUpdateWithoutFounderInput>
  }

  export type AthleteUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUpdateManyWithoutAthleteNestedInput
  }

  export type AthleteUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gofastHandle?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    primarySport?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    currentPace?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    trainingGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetRace?: NullableStringFieldUpdateOperationsInput | string | null
    trainingStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredDistance?: NullableStringFieldUpdateOperationsInput | string | null
    timePreference?: NullableStringFieldUpdateOperationsInput | string | null
    paceRange?: NullableStringFieldUpdateOperationsInput | string | null
    runningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_scope?: NullableStringFieldUpdateOperationsInput | string | null
    garmin_connected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_last_sync_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garmin_permissions?: NullableJsonNullValueInput | InputJsonValue
    garmin_is_connected?: BoolFieldUpdateOperationsInput | boolean
    garmin_disconnected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    strava_id?: NullableIntFieldUpdateOperationsInput | number | null
    strava_access_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    strava_expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    garmin_user_profile?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_sleep?: NullableJsonNullValueInput | InputJsonValue
    garmin_user_preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: AthleteActivityUncheckedUpdateManyWithoutAthleteNestedInput
    adminRunCrews?: RunCrewUncheckedUpdateManyWithoutAdminNestedInput
    runCrewMemberships?: RunCrewMembershipUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewMessages?: RunCrewMessageUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewAnnouncements?: RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    runCrewLeaderboards?: RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewRuns?: RunCrewRunUncheckedUpdateManyWithoutCreatedByNestedInput
    runCrewRunRSVPs?: RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewEvents?: RunCrewEventUncheckedUpdateManyWithoutOrganizerNestedInput
    runCrewEventRSVPs?: RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteNestedInput
    runCrewManagers?: RunCrewManagerUncheckedUpdateManyWithoutAthleteNestedInput
    createdRaces?: RaceUncheckedUpdateManyWithoutCreatedByAthleteNestedInput
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutAthleteNestedInput
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutAthleteNestedInput
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutAthleteNestedInput
  }

  export type FounderTaskUpsertWithWhereUniqueWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    update: XOR<FounderTaskUpdateWithoutFounderInput, FounderTaskUncheckedUpdateWithoutFounderInput>
    create: XOR<FounderTaskCreateWithoutFounderInput, FounderTaskUncheckedCreateWithoutFounderInput>
  }

  export type FounderTaskUpdateWithWhereUniqueWithoutFounderInput = {
    where: FounderTaskWhereUniqueInput
    data: XOR<FounderTaskUpdateWithoutFounderInput, FounderTaskUncheckedUpdateWithoutFounderInput>
  }

  export type FounderTaskUpdateManyWithWhereWithoutFounderInput = {
    where: FounderTaskScalarWhereInput
    data: XOR<FounderTaskUpdateManyMutationInput, FounderTaskUncheckedUpdateManyWithoutFounderInput>
  }

  export type FounderTaskScalarWhereInput = {
    AND?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
    OR?: FounderTaskScalarWhereInput[]
    NOT?: FounderTaskScalarWhereInput | FounderTaskScalarWhereInput[]
    id?: StringFilter<"FounderTask"> | string
    founderId?: StringFilter<"FounderTask"> | string
    title?: StringFilter<"FounderTask"> | string
    description?: StringNullableFilter<"FounderTask"> | string | null
    status?: StringFilter<"FounderTask"> | string
    priority?: StringFilter<"FounderTask"> | string
    dueDate?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FounderTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FounderTask"> | Date | string
    updatedAt?: DateTimeFilter<"FounderTask"> | Date | string
  }

  export type CrmContactUpsertWithWhereUniqueWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    update: XOR<CrmContactUpdateWithoutFounderInput, CrmContactUncheckedUpdateWithoutFounderInput>
    create: XOR<CrmContactCreateWithoutFounderInput, CrmContactUncheckedCreateWithoutFounderInput>
  }

  export type CrmContactUpdateWithWhereUniqueWithoutFounderInput = {
    where: CrmContactWhereUniqueInput
    data: XOR<CrmContactUpdateWithoutFounderInput, CrmContactUncheckedUpdateWithoutFounderInput>
  }

  export type CrmContactUpdateManyWithWhereWithoutFounderInput = {
    where: CrmContactScalarWhereInput
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyWithoutFounderInput>
  }

  export type CrmContactScalarWhereInput = {
    AND?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
    OR?: CrmContactScalarWhereInput[]
    NOT?: CrmContactScalarWhereInput | CrmContactScalarWhereInput[]
    id?: StringFilter<"CrmContact"> | string
    founderId?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    role?: StringNullableFilter<"CrmContact"> | string | null
    email?: StringNullableFilter<"CrmContact"> | string | null
    company?: StringNullableFilter<"CrmContact"> | string | null
    pipeline?: StringFilter<"CrmContact"> | string
    status?: StringFilter<"CrmContact"> | string
    nextStep?: StringNullableFilter<"CrmContact"> | string | null
    notes?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
  }

  export type RoadmapItemUpsertWithWhereUniqueWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    update: XOR<RoadmapItemUpdateWithoutFounderInput, RoadmapItemUncheckedUpdateWithoutFounderInput>
    create: XOR<RoadmapItemCreateWithoutFounderInput, RoadmapItemUncheckedCreateWithoutFounderInput>
  }

  export type RoadmapItemUpdateWithWhereUniqueWithoutFounderInput = {
    where: RoadmapItemWhereUniqueInput
    data: XOR<RoadmapItemUpdateWithoutFounderInput, RoadmapItemUncheckedUpdateWithoutFounderInput>
  }

  export type RoadmapItemUpdateManyWithWhereWithoutFounderInput = {
    where: RoadmapItemScalarWhereInput
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyWithoutFounderInput>
  }

  export type RoadmapItemScalarWhereInput = {
    AND?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    OR?: RoadmapItemScalarWhereInput[]
    NOT?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    founderId?: StringFilter<"RoadmapItem"> | string
    roadmapType?: StringFilter<"RoadmapItem"> | string
    quarter?: StringNullableFilter<"RoadmapItem"> | string | null
    category?: StringNullableFilter<"RoadmapItem"> | string | null
    title?: StringFilter<"RoadmapItem"> | string
    description?: StringNullableFilter<"RoadmapItem"> | string | null
    status?: StringFilter<"RoadmapItem"> | string
    dueDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
  }

  export type CompanyFounderUpsertWithWhereUniqueWithoutFounderInput = {
    where: CompanyFounderWhereUniqueInput
    update: XOR<CompanyFounderUpdateWithoutFounderInput, CompanyFounderUncheckedUpdateWithoutFounderInput>
    create: XOR<CompanyFounderCreateWithoutFounderInput, CompanyFounderUncheckedCreateWithoutFounderInput>
  }

  export type CompanyFounderUpdateWithWhereUniqueWithoutFounderInput = {
    where: CompanyFounderWhereUniqueInput
    data: XOR<CompanyFounderUpdateWithoutFounderInput, CompanyFounderUncheckedUpdateWithoutFounderInput>
  }

  export type CompanyFounderUpdateManyWithWhereWithoutFounderInput = {
    where: CompanyFounderScalarWhereInput
    data: XOR<CompanyFounderUpdateManyMutationInput, CompanyFounderUncheckedUpdateManyWithoutFounderInput>
  }

  export type CompanyFounderScalarWhereInput = {
    AND?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
    OR?: CompanyFounderScalarWhereInput[]
    NOT?: CompanyFounderScalarWhereInput | CompanyFounderScalarWhereInput[]
    id?: StringFilter<"CompanyFounder"> | string
    companyId?: StringFilter<"CompanyFounder"> | string
    founderId?: StringFilter<"CompanyFounder"> | string
    role?: StringNullableFilter<"CompanyFounder"> | string | null
    joinedAt?: DateTimeFilter<"CompanyFounder"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutFounderInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutFounderInput, TaskUncheckedUpdateWithoutFounderInput>
    create: XOR<TaskCreateWithoutFounderInput, TaskUncheckedCreateWithoutFounderInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutFounderInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutFounderInput, TaskUncheckedUpdateWithoutFounderInput>
  }

  export type TaskUpdateManyWithWhereWithoutFounderInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutFounderInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    founderId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    department?: StringNullableFilter<"Task"> | string | null
    isTopPriority?: BoolFilter<"Task"> | boolean
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    goFastCompanyId?: StringNullableFilter<"Task"> | string | null
  }

  export type FounderCreateWithoutTasksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutTasksInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutTasksInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
  }

  export type FounderUpsertWithoutTasksInput = {
    update: XOR<FounderUpdateWithoutTasksInput, FounderUncheckedUpdateWithoutTasksInput>
    create: XOR<FounderCreateWithoutTasksInput, FounderUncheckedCreateWithoutTasksInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutTasksInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutTasksInput, FounderUncheckedUpdateWithoutTasksInput>
  }

  export type FounderUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateWithoutCrmContactsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutCrmContactsInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutCrmContactsInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
  }

  export type FounderUpsertWithoutCrmContactsInput = {
    update: XOR<FounderUpdateWithoutCrmContactsInput, FounderUncheckedUpdateWithoutCrmContactsInput>
    create: XOR<FounderCreateWithoutCrmContactsInput, FounderUncheckedCreateWithoutCrmContactsInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutCrmContactsInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutCrmContactsInput, FounderUncheckedUpdateWithoutCrmContactsInput>
  }

  export type FounderUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type FounderCreateWithoutRoadmapItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutRoadmapItemsInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutRoadmapItemsInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
  }

  export type FounderUpsertWithoutRoadmapItemsInput = {
    update: XOR<FounderUpdateWithoutRoadmapItemsInput, FounderUncheckedUpdateWithoutRoadmapItemsInput>
    create: XOR<FounderCreateWithoutRoadmapItemsInput, FounderUncheckedCreateWithoutRoadmapItemsInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutRoadmapItemsInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutRoadmapItemsInput, FounderUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type FounderUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type CompanyFounderCreateWithoutCompanyInput = {
    id?: string
    role?: string | null
    joinedAt?: Date | string
    founder: FounderCreateNestedOneWithoutCompanyFoundersInput
  }

  export type CompanyFounderUncheckedCreateWithoutCompanyInput = {
    id?: string
    founderId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type CompanyFounderCreateOrConnectWithoutCompanyInput = {
    where: CompanyFounderWhereUniqueInput
    create: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFounderCreateManyCompanyInputEnvelope = {
    data: CompanyFounderCreateManyCompanyInput | CompanyFounderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyEmployeeCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
  }

  export type CompanyEmployeeUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
  }

  export type CompanyEmployeeCreateOrConnectWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    create: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyEmployeeCreateManyCompanyInputEnvelope = {
    data: CompanyEmployeeCreateManyCompanyInput | CompanyEmployeeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyRoadmapItemCreateWithoutCompanyInput = {
    id?: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutRoadmapItemsInput
  }

  export type CompanyRoadmapItemUncheckedCreateWithoutCompanyInput = {
    id?: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyRoadmapItemCreateOrConnectWithoutCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    create: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyRoadmapItemCreateManyCompanyInputEnvelope = {
    data: CompanyRoadmapItemCreateManyCompanyInput | CompanyRoadmapItemCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder?: FounderCreateNestedOneWithoutUnifiedTasksInput
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCompanyInput = {
    id?: string
    founderId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type TaskCreateOrConnectWithoutCompanyInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput>
  }

  export type TaskCreateManyCompanyInputEnvelope = {
    data: TaskCreateManyCompanyInput | TaskCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCrmContactCreateWithoutCompanyInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCrmContactUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCrmContactCreateOrConnectWithoutCompanyInput = {
    where: CompanyCrmContactWhereUniqueInput
    create: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyCrmContactCreateManyCompanyInputEnvelope = {
    data: CompanyCrmContactCreateManyCompanyInput | CompanyCrmContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFinancialSpendCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutFinancialSpendsInput
  }

  export type CompanyFinancialSpendUncheckedCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialSpendCreateOrConnectWithoutCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    create: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFinancialSpendCreateManyCompanyInputEnvelope = {
    data: CompanyFinancialSpendCreateManyCompanyInput | CompanyFinancialSpendCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFinancialProjectionCreateWithoutCompanyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    GoFastCompany?: GoFastCompanyCreateNestedOneWithoutFinancialProjectionsInput
  }

  export type CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialProjectionCreateOrConnectWithoutCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    create: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFinancialProjectionCreateManyCompanyInputEnvelope = {
    data: CompanyFinancialProjectionCreateManyCompanyInput | CompanyFinancialProjectionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFounderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFounderWhereUniqueInput
    update: XOR<CompanyFounderUpdateWithoutCompanyInput, CompanyFounderUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyFounderCreateWithoutCompanyInput, CompanyFounderUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFounderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFounderWhereUniqueInput
    data: XOR<CompanyFounderUpdateWithoutCompanyInput, CompanyFounderUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyFounderUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyFounderScalarWhereInput
    data: XOR<CompanyFounderUpdateManyMutationInput, CompanyFounderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    update: XOR<CompanyEmployeeUpdateWithoutCompanyInput, CompanyEmployeeUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    data: XOR<CompanyEmployeeUpdateWithoutCompanyInput, CompanyEmployeeUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyEmployeeScalarWhereInput
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyEmployeeScalarWhereInput = {
    AND?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
    OR?: CompanyEmployeeScalarWhereInput[]
    NOT?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
    id?: StringFilter<"CompanyEmployee"> | string
    companyId?: StringFilter<"CompanyEmployee"> | string
    email?: StringFilter<"CompanyEmployee"> | string
    name?: StringFilter<"CompanyEmployee"> | string
    role?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    phoneNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    joinedAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
  }

  export type CompanyRoadmapItemUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    update: XOR<CompanyRoadmapItemUpdateWithoutCompanyInput, CompanyRoadmapItemUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyRoadmapItemCreateWithoutCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyRoadmapItemUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    data: XOR<CompanyRoadmapItemUpdateWithoutCompanyInput, CompanyRoadmapItemUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyRoadmapItemUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyRoadmapItemScalarWhereInput
    data: XOR<CompanyRoadmapItemUpdateManyMutationInput, CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyRoadmapItemScalarWhereInput = {
    AND?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
    OR?: CompanyRoadmapItemScalarWhereInput[]
    NOT?: CompanyRoadmapItemScalarWhereInput | CompanyRoadmapItemScalarWhereInput[]
    id?: StringFilter<"CompanyRoadmapItem"> | string
    companyId?: StringFilter<"CompanyRoadmapItem"> | string
    itemType?: StringFilter<"CompanyRoadmapItem"> | string
    parentArchitecture?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    roadmapType?: StringFilter<"CompanyRoadmapItem"> | string
    category?: StringFilter<"CompanyRoadmapItem"> | string
    title?: StringFilter<"CompanyRoadmapItem"> | string
    whatItDoes?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howItHelps?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    fieldsData?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    howToGet?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    prerequisites?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
    visual?: StringFilter<"CompanyRoadmapItem"> | string
    orderNumber?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursEstimated?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    hoursSpent?: IntNullableFilter<"CompanyRoadmapItem"> | number | null
    targetDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    status?: StringFilter<"CompanyRoadmapItem"> | string
    priority?: StringFilter<"CompanyRoadmapItem"> | string
    completedAt?: DateTimeNullableFilter<"CompanyRoadmapItem"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRoadmapItem"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyRoadmapItem"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCompanyInput, TaskUncheckedUpdateWithoutCompanyInput>
    create: XOR<TaskCreateWithoutCompanyInput, TaskUncheckedCreateWithoutCompanyInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCompanyInput, TaskUncheckedUpdateWithoutCompanyInput>
  }

  export type TaskUpdateManyWithWhereWithoutCompanyInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCrmContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyCrmContactWhereUniqueInput
    update: XOR<CompanyCrmContactUpdateWithoutCompanyInput, CompanyCrmContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyCrmContactCreateWithoutCompanyInput, CompanyCrmContactUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyCrmContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyCrmContactWhereUniqueInput
    data: XOR<CompanyCrmContactUpdateWithoutCompanyInput, CompanyCrmContactUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyCrmContactUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyCrmContactScalarWhereInput
    data: XOR<CompanyCrmContactUpdateManyMutationInput, CompanyCrmContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCrmContactScalarWhereInput = {
    AND?: CompanyCrmContactScalarWhereInput | CompanyCrmContactScalarWhereInput[]
    OR?: CompanyCrmContactScalarWhereInput[]
    NOT?: CompanyCrmContactScalarWhereInput | CompanyCrmContactScalarWhereInput[]
    id?: StringFilter<"CompanyCrmContact"> | string
    companyId?: StringFilter<"CompanyCrmContact"> | string
    name?: StringFilter<"CompanyCrmContact"> | string
    role?: StringNullableFilter<"CompanyCrmContact"> | string | null
    email?: StringNullableFilter<"CompanyCrmContact"> | string | null
    companyName?: StringNullableFilter<"CompanyCrmContact"> | string | null
    pipeline?: StringFilter<"CompanyCrmContact"> | string
    status?: StringFilter<"CompanyCrmContact"> | string
    nextStep?: StringNullableFilter<"CompanyCrmContact"> | string | null
    notes?: StringNullableFilter<"CompanyCrmContact"> | string | null
    createdAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyCrmContact"> | Date | string
  }

  export type CompanyFinancialSpendUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    update: XOR<CompanyFinancialSpendUpdateWithoutCompanyInput, CompanyFinancialSpendUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyFinancialSpendCreateWithoutCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFinancialSpendUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    data: XOR<CompanyFinancialSpendUpdateWithoutCompanyInput, CompanyFinancialSpendUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyFinancialSpendUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyFinancialSpendScalarWhereInput
    data: XOR<CompanyFinancialSpendUpdateManyMutationInput, CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyFinancialSpendScalarWhereInput = {
    AND?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
    OR?: CompanyFinancialSpendScalarWhereInput[]
    NOT?: CompanyFinancialSpendScalarWhereInput | CompanyFinancialSpendScalarWhereInput[]
    id?: StringFilter<"CompanyFinancialSpend"> | string
    companyId?: StringFilter<"CompanyFinancialSpend"> | string
    date?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    amount?: FloatFilter<"CompanyFinancialSpend"> | number
    category?: StringFilter<"CompanyFinancialSpend"> | string
    description?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    vendor?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    department?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    project?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    receiptUrl?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
    createdAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialSpend"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialSpend"> | string | null
  }

  export type CompanyFinancialProjectionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    update: XOR<CompanyFinancialProjectionUpdateWithoutCompanyInput, CompanyFinancialProjectionUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyFinancialProjectionCreateWithoutCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyFinancialProjectionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    data: XOR<CompanyFinancialProjectionUpdateWithoutCompanyInput, CompanyFinancialProjectionUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyFinancialProjectionUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyFinancialProjectionScalarWhereInput
    data: XOR<CompanyFinancialProjectionUpdateManyMutationInput, CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyFinancialProjectionScalarWhereInput = {
    AND?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
    OR?: CompanyFinancialProjectionScalarWhereInput[]
    NOT?: CompanyFinancialProjectionScalarWhereInput | CompanyFinancialProjectionScalarWhereInput[]
    id?: StringFilter<"CompanyFinancialProjection"> | string
    companyId?: StringFilter<"CompanyFinancialProjection"> | string
    period?: StringFilter<"CompanyFinancialProjection"> | string
    periodStart?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    periodEnd?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    projectedRevenue?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    projectedExpenses?: FloatFilter<"CompanyFinancialProjection"> | number
    projectedNet?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    categoryBreakdown?: JsonNullableFilter<"CompanyFinancialProjection">
    currentCash?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    monthlyBurnRate?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    runwayMonths?: FloatNullableFilter<"CompanyFinancialProjection"> | number | null
    assumptions?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
    status?: StringFilter<"CompanyFinancialProjection"> | string
    createdAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyFinancialProjection"> | Date | string
    goFastCompanyId?: StringNullableFilter<"CompanyFinancialProjection"> | string | null
  }

  export type CompanyCreateWithoutFoundersInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFoundersInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFoundersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFoundersInput, CompanyUncheckedCreateWithoutFoundersInput>
  }

  export type FounderCreateWithoutCompanyFoundersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutCompanyFoundersInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    unifiedTasks?: TaskUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutCompanyFoundersInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutCompanyFoundersInput, FounderUncheckedCreateWithoutCompanyFoundersInput>
  }

  export type CompanyUpsertWithoutFoundersInput = {
    update: XOR<CompanyUpdateWithoutFoundersInput, CompanyUncheckedUpdateWithoutFoundersInput>
    create: XOR<CompanyCreateWithoutFoundersInput, CompanyUncheckedCreateWithoutFoundersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFoundersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFoundersInput, CompanyUncheckedUpdateWithoutFoundersInput>
  }

  export type CompanyUpdateWithoutFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FounderUpsertWithoutCompanyFoundersInput = {
    update: XOR<FounderUpdateWithoutCompanyFoundersInput, FounderUncheckedUpdateWithoutCompanyFoundersInput>
    create: XOR<FounderCreateWithoutCompanyFoundersInput, FounderUncheckedCreateWithoutCompanyFoundersInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutCompanyFoundersInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutCompanyFoundersInput, FounderUncheckedUpdateWithoutCompanyFoundersInput>
  }

  export type FounderUpdateWithoutCompanyFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutCompanyFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    unifiedTasks?: TaskUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type CompanyCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEmployeesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
  }

  export type CompanyUpsertWithoutEmployeesInput = {
    update: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type CompanyUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutRoadmapItemsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRoadmapItemsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRoadmapItemsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRoadmapItemsInput, CompanyUncheckedCreateWithoutRoadmapItemsInput>
  }

  export type GoFastCompanyCreateWithoutRoadmapItemsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutRoadmapItemsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutRoadmapItemsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutRoadmapItemsInput, GoFastCompanyUncheckedCreateWithoutRoadmapItemsInput>
  }

  export type CompanyUpsertWithoutRoadmapItemsInput = {
    update: XOR<CompanyUpdateWithoutRoadmapItemsInput, CompanyUncheckedUpdateWithoutRoadmapItemsInput>
    create: XOR<CompanyCreateWithoutRoadmapItemsInput, CompanyUncheckedCreateWithoutRoadmapItemsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRoadmapItemsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRoadmapItemsInput, CompanyUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type CompanyUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GoFastCompanyUpsertWithoutRoadmapItemsInput = {
    update: XOR<GoFastCompanyUpdateWithoutRoadmapItemsInput, GoFastCompanyUncheckedUpdateWithoutRoadmapItemsInput>
    create: XOR<GoFastCompanyCreateWithoutRoadmapItemsInput, GoFastCompanyUncheckedCreateWithoutRoadmapItemsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutRoadmapItemsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutRoadmapItemsInput, GoFastCompanyUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type GoFastCompanyUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutRoadmapItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type CompanyCreateWithoutCrmContactsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCrmContactsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCrmContactsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCrmContactsInput, CompanyUncheckedCreateWithoutCrmContactsInput>
  }

  export type CompanyUpsertWithoutCrmContactsInput = {
    update: XOR<CompanyUpdateWithoutCrmContactsInput, CompanyUncheckedUpdateWithoutCrmContactsInput>
    create: XOR<CompanyCreateWithoutCrmContactsInput, CompanyUncheckedCreateWithoutCrmContactsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCrmContactsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCrmContactsInput, CompanyUncheckedUpdateWithoutCrmContactsInput>
  }

  export type CompanyUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCrmContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutFinancialSpendsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFinancialSpendsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFinancialSpendsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFinancialSpendsInput, CompanyUncheckedCreateWithoutFinancialSpendsInput>
  }

  export type GoFastCompanyCreateWithoutFinancialSpendsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutFinancialSpendsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutFinancialSpendsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutFinancialSpendsInput, GoFastCompanyUncheckedCreateWithoutFinancialSpendsInput>
  }

  export type CompanyUpsertWithoutFinancialSpendsInput = {
    update: XOR<CompanyUpdateWithoutFinancialSpendsInput, CompanyUncheckedUpdateWithoutFinancialSpendsInput>
    create: XOR<CompanyCreateWithoutFinancialSpendsInput, CompanyUncheckedCreateWithoutFinancialSpendsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFinancialSpendsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFinancialSpendsInput, CompanyUncheckedUpdateWithoutFinancialSpendsInput>
  }

  export type CompanyUpdateWithoutFinancialSpendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFinancialSpendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GoFastCompanyUpsertWithoutFinancialSpendsInput = {
    update: XOR<GoFastCompanyUpdateWithoutFinancialSpendsInput, GoFastCompanyUncheckedUpdateWithoutFinancialSpendsInput>
    create: XOR<GoFastCompanyCreateWithoutFinancialSpendsInput, GoFastCompanyUncheckedCreateWithoutFinancialSpendsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutFinancialSpendsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutFinancialSpendsInput, GoFastCompanyUncheckedUpdateWithoutFinancialSpendsInput>
  }

  export type GoFastCompanyUpdateWithoutFinancialSpendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutFinancialSpendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type CompanyCreateWithoutFinancialProjectionsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    tasks?: TaskCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFinancialProjectionsInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFinancialProjectionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFinancialProjectionsInput, CompanyUncheckedCreateWithoutFinancialProjectionsInput>
  }

  export type GoFastCompanyCreateWithoutFinancialProjectionsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutFinancialProjectionsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutFinancialProjectionsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedCreateWithoutFinancialProjectionsInput>
  }

  export type CompanyUpsertWithoutFinancialProjectionsInput = {
    update: XOR<CompanyUpdateWithoutFinancialProjectionsInput, CompanyUncheckedUpdateWithoutFinancialProjectionsInput>
    create: XOR<CompanyCreateWithoutFinancialProjectionsInput, CompanyUncheckedCreateWithoutFinancialProjectionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFinancialProjectionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFinancialProjectionsInput, CompanyUncheckedUpdateWithoutFinancialProjectionsInput>
  }

  export type CompanyUpdateWithoutFinancialProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFinancialProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GoFastCompanyUpsertWithoutFinancialProjectionsInput = {
    update: XOR<GoFastCompanyUpdateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedUpdateWithoutFinancialProjectionsInput>
    create: XOR<GoFastCompanyCreateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedCreateWithoutFinancialProjectionsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutFinancialProjectionsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutFinancialProjectionsInput, GoFastCompanyUncheckedUpdateWithoutFinancialProjectionsInput>
  }

  export type GoFastCompanyUpdateWithoutFinancialProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutFinancialProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type FounderCreateWithoutUnifiedTasksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    athlete: AthleteCreateNestedOneWithoutFounderInput
    tasks?: FounderTaskCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderCreateNestedManyWithoutFounderInput
  }

  export type FounderUncheckedCreateWithoutUnifiedTasksInput = {
    id?: string
    athleteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: FounderTaskUncheckedCreateNestedManyWithoutFounderInput
    crmContacts?: CrmContactUncheckedCreateNestedManyWithoutFounderInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutFounderInput
    companyFounders?: CompanyFounderUncheckedCreateNestedManyWithoutFounderInput
  }

  export type FounderCreateOrConnectWithoutUnifiedTasksInput = {
    where: FounderWhereUniqueInput
    create: XOR<FounderCreateWithoutUnifiedTasksInput, FounderUncheckedCreateWithoutUnifiedTasksInput>
  }

  export type CompanyCreateWithoutTasksInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    address?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: CompanyFounderUncheckedCreateNestedManyWithoutCompanyInput
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutCompanyInput
    crmContacts?: CompanyCrmContactUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTasksInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
  }

  export type GoFastCompanyCreateWithoutTasksInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutTasksInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutTasksInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutTasksInput, GoFastCompanyUncheckedCreateWithoutTasksInput>
  }

  export type FounderUpsertWithoutUnifiedTasksInput = {
    update: XOR<FounderUpdateWithoutUnifiedTasksInput, FounderUncheckedUpdateWithoutUnifiedTasksInput>
    create: XOR<FounderCreateWithoutUnifiedTasksInput, FounderUncheckedCreateWithoutUnifiedTasksInput>
    where?: FounderWhereInput
  }

  export type FounderUpdateToOneWithWhereWithoutUnifiedTasksInput = {
    where?: FounderWhereInput
    data: XOR<FounderUpdateWithoutUnifiedTasksInput, FounderUncheckedUpdateWithoutUnifiedTasksInput>
  }

  export type FounderUpdateWithoutUnifiedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutFounderNestedInput
    tasks?: FounderTaskUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUpdateManyWithoutFounderNestedInput
  }

  export type FounderUncheckedUpdateWithoutUnifiedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: FounderTaskUncheckedUpdateManyWithoutFounderNestedInput
    crmContacts?: CrmContactUncheckedUpdateManyWithoutFounderNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutFounderNestedInput
    companyFounders?: CompanyFounderUncheckedUpdateManyWithoutFounderNestedInput
  }

  export type CompanyUpsertWithoutTasksInput = {
    update: XOR<CompanyUpdateWithoutTasksInput, CompanyUncheckedUpdateWithoutTasksInput>
    create: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTasksInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTasksInput, CompanyUncheckedUpdateWithoutTasksInput>
  }

  export type CompanyUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: CompanyFounderUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyNestedInput
    crmContacts?: CompanyCrmContactUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GoFastCompanyUpsertWithoutTasksInput = {
    update: XOR<GoFastCompanyUpdateWithoutTasksInput, GoFastCompanyUncheckedUpdateWithoutTasksInput>
    create: XOR<GoFastCompanyCreateWithoutTasksInput, GoFastCompanyUncheckedCreateWithoutTasksInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutTasksInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutTasksInput, GoFastCompanyUncheckedUpdateWithoutTasksInput>
  }

  export type GoFastCompanyUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type CompanyStaffCreateWithoutCompanyInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyStaffUncheckedCreateWithoutCompanyInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyStaffCreateOrConnectWithoutCompanyInput = {
    where: CompanyStaffWhereUniqueInput
    create: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyStaffCreateManyCompanyInputEnvelope = {
    data: CompanyStaffCreateManyCompanyInput | CompanyStaffCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCompanyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutCompanyInput = {
    id?: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutPipelinesInput
    config: PipelineConfigCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateWithoutCompanyInput = {
    id?: string
    contactId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineCreateOrConnectWithoutCompanyInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
  }

  export type PipelineCreateManyCompanyInputEnvelope = {
    data: PipelineCreateManyCompanyInput | PipelineCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PipelineConfigCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineCreateNestedManyWithoutConfigInput
  }

  export type PipelineConfigUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelines?: PipelineUncheckedCreateNestedManyWithoutConfigInput
  }

  export type PipelineConfigCreateOrConnectWithoutCompanyInput = {
    where: PipelineConfigWhereUniqueInput
    create: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput>
  }

  export type PipelineConfigCreateManyCompanyInputEnvelope = {
    data: PipelineConfigCreateManyCompanyInput | PipelineConfigCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProductPipelineItemCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPipelineItemUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPipelineItemCreateOrConnectWithoutCompanyInput = {
    where: ProductPipelineItemWhereUniqueInput
    create: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput>
  }

  export type ProductPipelineItemCreateManyCompanyInputEnvelope = {
    data: ProductPipelineItemCreateManyCompanyInput | ProductPipelineItemCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFinancialSpendCreateWithoutGoFastCompanyInput = {
    id?: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFinancialSpendsInput
  }

  export type CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput = {
    id?: string
    companyId: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFinancialSpendCreateOrConnectWithoutGoFastCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    create: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialSpendCreateManyGoFastCompanyInputEnvelope = {
    data: CompanyFinancialSpendCreateManyGoFastCompanyInput | CompanyFinancialSpendCreateManyGoFastCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFinancialProjectionCreateWithoutGoFastCompanyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFinancialProjectionsInput
  }

  export type CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput = {
    id?: string
    companyId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFinancialProjectionCreateOrConnectWithoutGoFastCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    create: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialProjectionCreateManyGoFastCompanyInputEnvelope = {
    data: CompanyFinancialProjectionCreateManyGoFastCompanyInput | CompanyFinancialProjectionCreateManyGoFastCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyRoadmapItemCreateWithoutGoFastCompanyInput = {
    id?: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutRoadmapItemsInput
  }

  export type CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput = {
    id?: string
    companyId: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRoadmapItemCreateOrConnectWithoutGoFastCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    create: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyRoadmapItemCreateManyGoFastCompanyInputEnvelope = {
    data: CompanyRoadmapItemCreateManyGoFastCompanyInput | CompanyRoadmapItemCreateManyGoFastCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutGoFastCompanyInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder?: FounderCreateNestedOneWithoutUnifiedTasksInput
    company?: CompanyCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutGoFastCompanyInput = {
    id?: string
    founderId?: string | null
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutGoFastCompanyInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type TaskCreateManyGoFastCompanyInputEnvelope = {
    data: TaskCreateManyGoFastCompanyInput | TaskCreateManyGoFastCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyStaffUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyStaffWhereUniqueInput
    update: XOR<CompanyStaffUpdateWithoutCompanyInput, CompanyStaffUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyStaffCreateWithoutCompanyInput, CompanyStaffUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyStaffUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyStaffWhereUniqueInput
    data: XOR<CompanyStaffUpdateWithoutCompanyInput, CompanyStaffUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyStaffUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyStaffScalarWhereInput
    data: XOR<CompanyStaffUpdateManyMutationInput, CompanyStaffUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyStaffScalarWhereInput = {
    AND?: CompanyStaffScalarWhereInput | CompanyStaffScalarWhereInput[]
    OR?: CompanyStaffScalarWhereInput[]
    NOT?: CompanyStaffScalarWhereInput | CompanyStaffScalarWhereInput[]
    id?: StringFilter<"CompanyStaff"> | string
    firebaseId?: StringFilter<"CompanyStaff"> | string
    name?: StringNullableFilter<"CompanyStaff"> | string | null
    email?: StringNullableFilter<"CompanyStaff"> | string | null
    photoURL?: StringNullableFilter<"CompanyStaff"> | string | null
    companyId?: StringFilter<"CompanyStaff"> | string
    role?: StringFilter<"CompanyStaff"> | string
    department?: StringNullableFilter<"CompanyStaff"> | string | null
    verificationCode?: StringNullableFilter<"CompanyStaff"> | string | null
    joinedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    createdAt?: DateTimeFilter<"CompanyStaff"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyStaff"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    companyId?: StringFilter<"Contact"> | string
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringNullableFilter<"Contact"> | string | null
    goesBy?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    athleteId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type PipelineUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutCompanyInput, PipelineUncheckedUpdateWithoutCompanyInput>
    create: XOR<PipelineCreateWithoutCompanyInput, PipelineUncheckedCreateWithoutCompanyInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutCompanyInput, PipelineUncheckedUpdateWithoutCompanyInput>
  }

  export type PipelineUpdateManyWithWhereWithoutCompanyInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PipelineScalarWhereInput = {
    AND?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    OR?: PipelineScalarWhereInput[]
    NOT?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    companyId?: StringFilter<"Pipeline"> | string
    contactId?: StringFilter<"Pipeline"> | string
    configId?: StringFilter<"Pipeline"> | string
    stageId?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
  }

  export type PipelineConfigUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PipelineConfigWhereUniqueInput
    update: XOR<PipelineConfigUpdateWithoutCompanyInput, PipelineConfigUncheckedUpdateWithoutCompanyInput>
    create: XOR<PipelineConfigCreateWithoutCompanyInput, PipelineConfigUncheckedCreateWithoutCompanyInput>
  }

  export type PipelineConfigUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PipelineConfigWhereUniqueInput
    data: XOR<PipelineConfigUpdateWithoutCompanyInput, PipelineConfigUncheckedUpdateWithoutCompanyInput>
  }

  export type PipelineConfigUpdateManyWithWhereWithoutCompanyInput = {
    where: PipelineConfigScalarWhereInput
    data: XOR<PipelineConfigUpdateManyMutationInput, PipelineConfigUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PipelineConfigScalarWhereInput = {
    AND?: PipelineConfigScalarWhereInput | PipelineConfigScalarWhereInput[]
    OR?: PipelineConfigScalarWhereInput[]
    NOT?: PipelineConfigScalarWhereInput | PipelineConfigScalarWhereInput[]
    id?: StringFilter<"PipelineConfig"> | string
    companyId?: StringFilter<"PipelineConfig"> | string
    name?: StringFilter<"PipelineConfig"> | string
    description?: StringNullableFilter<"PipelineConfig"> | string | null
    stages?: JsonFilter<"PipelineConfig">
    isActive?: BoolFilter<"PipelineConfig"> | boolean
    createdAt?: DateTimeFilter<"PipelineConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineConfig"> | Date | string
  }

  export type ProductPipelineItemUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProductPipelineItemWhereUniqueInput
    update: XOR<ProductPipelineItemUpdateWithoutCompanyInput, ProductPipelineItemUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProductPipelineItemCreateWithoutCompanyInput, ProductPipelineItemUncheckedCreateWithoutCompanyInput>
  }

  export type ProductPipelineItemUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProductPipelineItemWhereUniqueInput
    data: XOR<ProductPipelineItemUpdateWithoutCompanyInput, ProductPipelineItemUncheckedUpdateWithoutCompanyInput>
  }

  export type ProductPipelineItemUpdateManyWithWhereWithoutCompanyInput = {
    where: ProductPipelineItemScalarWhereInput
    data: XOR<ProductPipelineItemUpdateManyMutationInput, ProductPipelineItemUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProductPipelineItemScalarWhereInput = {
    AND?: ProductPipelineItemScalarWhereInput | ProductPipelineItemScalarWhereInput[]
    OR?: ProductPipelineItemScalarWhereInput[]
    NOT?: ProductPipelineItemScalarWhereInput | ProductPipelineItemScalarWhereInput[]
    id?: StringFilter<"ProductPipelineItem"> | string
    companyId?: StringFilter<"ProductPipelineItem"> | string
    name?: StringFilter<"ProductPipelineItem"> | string
    description?: StringNullableFilter<"ProductPipelineItem"> | string | null
    timeItTakes?: StringNullableFilter<"ProductPipelineItem"> | string | null
    status?: StringFilter<"ProductPipelineItem"> | string
    priority?: StringFilter<"ProductPipelineItem"> | string
    startedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProductPipelineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPipelineItem"> | Date | string
  }

  export type CompanyFinancialSpendUpsertWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    update: XOR<CompanyFinancialSpendUpdateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedUpdateWithoutGoFastCompanyInput>
    create: XOR<CompanyFinancialSpendCreateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialSpendUpdateWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyFinancialSpendWhereUniqueInput
    data: XOR<CompanyFinancialSpendUpdateWithoutGoFastCompanyInput, CompanyFinancialSpendUncheckedUpdateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialSpendUpdateManyWithWhereWithoutGoFastCompanyInput = {
    where: CompanyFinancialSpendScalarWhereInput
    data: XOR<CompanyFinancialSpendUpdateManyMutationInput, CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialProjectionUpsertWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    update: XOR<CompanyFinancialProjectionUpdateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedUpdateWithoutGoFastCompanyInput>
    create: XOR<CompanyFinancialProjectionCreateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialProjectionUpdateWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyFinancialProjectionWhereUniqueInput
    data: XOR<CompanyFinancialProjectionUpdateWithoutGoFastCompanyInput, CompanyFinancialProjectionUncheckedUpdateWithoutGoFastCompanyInput>
  }

  export type CompanyFinancialProjectionUpdateManyWithWhereWithoutGoFastCompanyInput = {
    where: CompanyFinancialProjectionScalarWhereInput
    data: XOR<CompanyFinancialProjectionUpdateManyMutationInput, CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyInput>
  }

  export type CompanyRoadmapItemUpsertWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    update: XOR<CompanyRoadmapItemUpdateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedUpdateWithoutGoFastCompanyInput>
    create: XOR<CompanyRoadmapItemCreateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type CompanyRoadmapItemUpdateWithWhereUniqueWithoutGoFastCompanyInput = {
    where: CompanyRoadmapItemWhereUniqueInput
    data: XOR<CompanyRoadmapItemUpdateWithoutGoFastCompanyInput, CompanyRoadmapItemUncheckedUpdateWithoutGoFastCompanyInput>
  }

  export type CompanyRoadmapItemUpdateManyWithWhereWithoutGoFastCompanyInput = {
    where: CompanyRoadmapItemScalarWhereInput
    data: XOR<CompanyRoadmapItemUpdateManyMutationInput, CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutGoFastCompanyInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutGoFastCompanyInput, TaskUncheckedUpdateWithoutGoFastCompanyInput>
    create: XOR<TaskCreateWithoutGoFastCompanyInput, TaskUncheckedCreateWithoutGoFastCompanyInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutGoFastCompanyInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutGoFastCompanyInput, TaskUncheckedUpdateWithoutGoFastCompanyInput>
  }

  export type TaskUpdateManyWithWhereWithoutGoFastCompanyInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutGoFastCompanyInput>
  }

  export type GoFastCompanyCreateWithoutStaffInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutStaffInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutStaffInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutStaffInput, GoFastCompanyUncheckedCreateWithoutStaffInput>
  }

  export type GoFastCompanyUpsertWithoutStaffInput = {
    update: XOR<GoFastCompanyUpdateWithoutStaffInput, GoFastCompanyUncheckedUpdateWithoutStaffInput>
    create: XOR<GoFastCompanyCreateWithoutStaffInput, GoFastCompanyUncheckedCreateWithoutStaffInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutStaffInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutStaffInput, GoFastCompanyUncheckedUpdateWithoutStaffInput>
  }

  export type GoFastCompanyUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyCreateWithoutContactsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutContactsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutContactsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutContactsInput, GoFastCompanyUncheckedCreateWithoutContactsInput>
  }

  export type PipelineCreateWithoutContactInput = {
    id?: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutPipelinesInput
    config: PipelineConfigCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateWithoutContactInput = {
    id?: string
    companyId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineCreateOrConnectWithoutContactInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput>
  }

  export type PipelineCreateManyContactInputEnvelope = {
    data: PipelineCreateManyContactInput | PipelineCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type GoFastCompanyUpsertWithoutContactsInput = {
    update: XOR<GoFastCompanyUpdateWithoutContactsInput, GoFastCompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<GoFastCompanyCreateWithoutContactsInput, GoFastCompanyUncheckedCreateWithoutContactsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutContactsInput, GoFastCompanyUncheckedUpdateWithoutContactsInput>
  }

  export type GoFastCompanyUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type PipelineUpsertWithWhereUniqueWithoutContactInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutContactInput, PipelineUncheckedUpdateWithoutContactInput>
    create: XOR<PipelineCreateWithoutContactInput, PipelineUncheckedCreateWithoutContactInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutContactInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutContactInput, PipelineUncheckedUpdateWithoutContactInput>
  }

  export type PipelineUpdateManyWithWhereWithoutContactInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutContactInput>
  }

  export type GoFastCompanyCreateWithoutPipelinesInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutPipelinesInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutPipelinesInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutPipelinesInput, GoFastCompanyUncheckedCreateWithoutPipelinesInput>
  }

  export type ContactCreateWithoutPipelinesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutPipelinesInput = {
    id?: string
    companyId: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutPipelinesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPipelinesInput, ContactUncheckedCreateWithoutPipelinesInput>
  }

  export type PipelineConfigCreateWithoutPipelinesInput = {
    id?: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutPipelineConfigsInput
  }

  export type PipelineConfigUncheckedCreateWithoutPipelinesInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineConfigCreateOrConnectWithoutPipelinesInput = {
    where: PipelineConfigWhereUniqueInput
    create: XOR<PipelineConfigCreateWithoutPipelinesInput, PipelineConfigUncheckedCreateWithoutPipelinesInput>
  }

  export type GoFastCompanyUpsertWithoutPipelinesInput = {
    update: XOR<GoFastCompanyUpdateWithoutPipelinesInput, GoFastCompanyUncheckedUpdateWithoutPipelinesInput>
    create: XOR<GoFastCompanyCreateWithoutPipelinesInput, GoFastCompanyUncheckedCreateWithoutPipelinesInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutPipelinesInput, GoFastCompanyUncheckedUpdateWithoutPipelinesInput>
  }

  export type GoFastCompanyUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type ContactUpsertWithoutPipelinesInput = {
    update: XOR<ContactUpdateWithoutPipelinesInput, ContactUncheckedUpdateWithoutPipelinesInput>
    create: XOR<ContactCreateWithoutPipelinesInput, ContactUncheckedCreateWithoutPipelinesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPipelinesInput, ContactUncheckedUpdateWithoutPipelinesInput>
  }

  export type ContactUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineConfigUpsertWithoutPipelinesInput = {
    update: XOR<PipelineConfigUpdateWithoutPipelinesInput, PipelineConfigUncheckedUpdateWithoutPipelinesInput>
    create: XOR<PipelineConfigCreateWithoutPipelinesInput, PipelineConfigUncheckedCreateWithoutPipelinesInput>
    where?: PipelineConfigWhereInput
  }

  export type PipelineConfigUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: PipelineConfigWhereInput
    data: XOR<PipelineConfigUpdateWithoutPipelinesInput, PipelineConfigUncheckedUpdateWithoutPipelinesInput>
  }

  export type PipelineConfigUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutPipelineConfigsNestedInput
  }

  export type PipelineConfigUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoFastCompanyCreateWithoutPipelineConfigsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutPipelineConfigsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    productPipelineItems?: ProductPipelineItemUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutPipelineConfigsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutPipelineConfigsInput, GoFastCompanyUncheckedCreateWithoutPipelineConfigsInput>
  }

  export type PipelineCreateWithoutConfigInput = {
    id?: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: GoFastCompanyCreateNestedOneWithoutPipelinesInput
    contact: ContactCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateWithoutConfigInput = {
    id?: string
    companyId: string
    contactId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineCreateOrConnectWithoutConfigInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput>
  }

  export type PipelineCreateManyConfigInputEnvelope = {
    data: PipelineCreateManyConfigInput | PipelineCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type GoFastCompanyUpsertWithoutPipelineConfigsInput = {
    update: XOR<GoFastCompanyUpdateWithoutPipelineConfigsInput, GoFastCompanyUncheckedUpdateWithoutPipelineConfigsInput>
    create: XOR<GoFastCompanyCreateWithoutPipelineConfigsInput, GoFastCompanyUncheckedCreateWithoutPipelineConfigsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutPipelineConfigsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutPipelineConfigsInput, GoFastCompanyUncheckedUpdateWithoutPipelineConfigsInput>
  }

  export type GoFastCompanyUpdateWithoutPipelineConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutPipelineConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    productPipelineItems?: ProductPipelineItemUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type PipelineUpsertWithWhereUniqueWithoutConfigInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutConfigInput, PipelineUncheckedUpdateWithoutConfigInput>
    create: XOR<PipelineCreateWithoutConfigInput, PipelineUncheckedCreateWithoutConfigInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutConfigInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutConfigInput, PipelineUncheckedUpdateWithoutConfigInput>
  }

  export type PipelineUpdateManyWithWhereWithoutConfigInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutConfigInput>
  }

  export type GoFastCompanyCreateWithoutProductPipelineItemsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyUncheckedCreateWithoutProductPipelineItemsInput = {
    id?: string
    containerId: string
    companyName: string
    address?: string | null
    city?: string | null
    state?: string | null
    website?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: CompanyStaffUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutCompanyInput
    pipelineConfigs?: PipelineConfigUncheckedCreateNestedManyWithoutCompanyInput
    financialSpends?: CompanyFinancialSpendUncheckedCreateNestedManyWithoutGoFastCompanyInput
    financialProjections?: CompanyFinancialProjectionUncheckedCreateNestedManyWithoutGoFastCompanyInput
    roadmapItems?: CompanyRoadmapItemUncheckedCreateNestedManyWithoutGoFastCompanyInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoFastCompanyInput
  }

  export type GoFastCompanyCreateOrConnectWithoutProductPipelineItemsInput = {
    where: GoFastCompanyWhereUniqueInput
    create: XOR<GoFastCompanyCreateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedCreateWithoutProductPipelineItemsInput>
  }

  export type GoFastCompanyUpsertWithoutProductPipelineItemsInput = {
    update: XOR<GoFastCompanyUpdateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedUpdateWithoutProductPipelineItemsInput>
    create: XOR<GoFastCompanyCreateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedCreateWithoutProductPipelineItemsInput>
    where?: GoFastCompanyWhereInput
  }

  export type GoFastCompanyUpdateToOneWithWhereWithoutProductPipelineItemsInput = {
    where?: GoFastCompanyWhereInput
    data: XOR<GoFastCompanyUpdateWithoutProductPipelineItemsInput, GoFastCompanyUncheckedUpdateWithoutProductPipelineItemsInput>
  }

  export type GoFastCompanyUpdateWithoutProductPipelineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type GoFastCompanyUncheckedUpdateWithoutProductPipelineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: CompanyStaffUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutCompanyNestedInput
    pipelineConfigs?: PipelineConfigUncheckedUpdateManyWithoutCompanyNestedInput
    financialSpends?: CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    financialProjections?: CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    roadmapItems?: CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoFastCompanyNestedInput
  }

  export type AthleteActivityCreateManyAthleteInput = {
    id?: string
    sourceActivityId: string
    source?: string
    activityType?: string | null
    activityName?: string | null
    startTime?: Date | string | null
    duration?: number | null
    distance?: number | null
    averageSpeed?: number | null
    calories?: number | null
    averageHeartRate?: number | null
    maxHeartRate?: number | null
    elevationGain?: number | null
    steps?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    summaryPolyline?: string | null
    deviceName?: string | null
    garminUserId?: string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: Date | string | null
    syncedAt?: Date | string
    lastUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewCreateManyAdminInput = {
    id?: string
    name: string
    description?: string | null
    joinCode: string
    logo?: string | null
    icon?: string | null
    isArchived?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMembershipCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMessageCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewAnnouncementCreateManyAuthorInput = {
    id?: string
    runCrewId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewRunCreateManyCreatedByInput = {
    id?: string
    runCrewId: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewRunRSVPCreateManyAthleteInput = {
    id?: string
    runId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventCreateManyOrganizerInput = {
    id?: string
    runCrewId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewEventRSVPCreateManyAthleteInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewManagerCreateManyAthleteInput = {
    id?: string
    runCrewId: string
    role: string
    createdAt?: Date | string
  }

  export type RaceCreateManyCreatedByAthleteInput = {
    id?: string
    raceName: string
    raceType: string
    raceDate: Date | string
    location?: string | null
    distanceMiles: number
    registrationUrl?: string | null
    description?: string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanCreateManyAthleteInput = {
    id?: string
    raceId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedCreateManyAthleteInput = {
    id?: string
    trainingPlanId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedCreateManyAthleteInput = {
    id?: string
    executionId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AthleteActivityUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteActivityUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceActivityId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    activityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    averageHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    elevationGain?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    summaryPolyline?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    garminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    summaryData?: NullableJsonNullValueInput | InputJsonValue
    detailData?: NullableJsonNullValueInput | InputJsonValue
    hydratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RunCrewMembershipUncheckedUpdateManyWithoutRunCrewNestedInput
    messages?: RunCrewMessageUncheckedUpdateManyWithoutRunCrewNestedInput
    announcements?: RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewNestedInput
    leaderboardEntries?: RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewNestedInput
    runs?: RunCrewRunUncheckedUpdateManyWithoutRunCrewNestedInput
    events?: RunCrewEventUncheckedUpdateManyWithoutRunCrewNestedInput
    managers?: RunCrewManagerUncheckedUpdateManyWithoutRunCrewNestedInput
  }

  export type RunCrewUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    joinCode?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type RunCrewMessageUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type RunCrewAnnouncementUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutRunsNestedInput
    rsvps?: RunCrewRunRSVPUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewRunRSVPUncheckedUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: RunCrewRunUpdateOneRequiredWithoutRsvpsNestedInput
  }

  export type RunCrewRunRSVPUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: RunCrewEventRSVPUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventUncheckedUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewEventRSVPUncheckedUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventUncheckedUpdateManyWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: RunCrewEventUpdateOneRequiredWithoutRsvpsNestedInput
  }

  export type RunCrewEventRSVPUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runCrew?: RunCrewUpdateOneRequiredWithoutManagersNestedInput
  }

  export type RunCrewManagerUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    runCrewId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceUpdateWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlans?: TrainingPlanUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateManyWithoutCreatedByAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceName?: StringFieldUpdateOperationsInput | string
    raceType?: StringFieldUpdateOperationsInput | string
    raceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distanceMiles?: FloatFieldUpdateOperationsInput | number
    registrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseProfile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    race?: RaceUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raceId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingPlan?: TrainingPlanUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: TrainingPlanExecutionUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutAthleteInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewMessageCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    content: string
    createdAt?: Date | string
  }

  export type RunCrewAnnouncementCreateManyRunCrewInput = {
    id?: string
    authorId: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewLeaderboardCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    totalMiles?: number
    totalRuns?: number
    bestPace?: string | null
    totalCalories?: number
    totalElevation?: number
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewRunCreateManyRunCrewInput = {
    id?: string
    createdById: string
    title: string
    date: Date | string
    startTime: string
    location: string
    address?: string | null
    totalMiles?: number | null
    pace?: string | null
    stravaMapUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewEventCreateManyRunCrewInput = {
    id?: string
    organizerId: string
    title: string
    date: Date | string
    time: string
    location: string
    address?: string | null
    description?: string | null
    eventType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunCrewManagerCreateManyRunCrewInput = {
    id?: string
    athleteId: string
    role: string
    createdAt?: Date | string
  }

  export type RunCrewMembershipUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMembershipsNestedInput
  }

  export type RunCrewMembershipUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMembershipUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewMessagesNestedInput
  }

  export type RunCrewMessageUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewMessageUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AthleteUpdateOneRequiredWithoutRunCrewAnnouncementsNestedInput
  }

  export type RunCrewAnnouncementUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewAnnouncementUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewLeaderboardsNestedInput
  }

  export type RunCrewLeaderboardUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewLeaderboardUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMiles?: FloatFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    bestPace?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    totalElevation?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: AthleteUpdateOneRequiredWithoutRunCrewRunsNestedInput
    rsvps?: RunCrewRunRSVPUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewRunRSVPUncheckedUpdateManyWithoutRunNestedInput
  }

  export type RunCrewRunUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    totalMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    pace?: NullableStringFieldUpdateOperationsInput | string | null
    stravaMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: AthleteUpdateOneRequiredWithoutRunCrewEventsNestedInput
    rsvps?: RunCrewEventRSVPUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: RunCrewEventRSVPUncheckedUpdateManyWithoutEventNestedInput
  }

  export type RunCrewEventUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewManagersNestedInput
  }

  export type RunCrewManagerUncheckedUpdateWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewManagerUncheckedUpdateManyWithoutRunCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPCreateManyRunInput = {
    id?: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewRunRSVPUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewRunRSVPsNestedInput
  }

  export type RunCrewRunRSVPUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewRunRSVPUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPCreateManyEventInput = {
    id?: string
    athleteId: string
    status: string
    createdAt?: Date | string
  }

  export type RunCrewEventRSVPUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutRunCrewEventRSVPsNestedInput
  }

  export type RunCrewEventRSVPUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCrewEventRSVPUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanCreateManyRaceInput = {
    id?: string
    athleteId: string
    goalTime: string
    goalPace?: string | null
    baseline5k: string
    baselineWeeklyMileage?: number | null
    startDate: Date | string
    totalWeeks: number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutTrainingPlansNestedInput
    plannedDays?: TrainingDayPlannedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedDays?: TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanNestedInput
    executions?: TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanNestedInput
  }

  export type TrainingPlanUncheckedUpdateManyWithoutRaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    goalTime?: StringFieldUpdateOperationsInput | string
    goalPace?: NullableStringFieldUpdateOperationsInput | string | null
    baseline5k?: StringFieldUpdateOperationsInput | string
    baselineWeeklyMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalWeeks?: IntFieldUpdateOperationsInput | number
    phaseOverview?: NullableJsonNullValueInput | InputJsonValue
    weeklyMileagePlan?: NullableJsonNullValueInput | InputJsonValue
    weeks?: NullableJsonNullValueInput | InputJsonValue
    adaptive5kTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedCreateManyTrainingPlanInput = {
    id?: string
    athleteId: string
    date: Date | string
    weekIndex: number
    dayIndex: number
    dayName?: string | null
    phase: string
    plannedData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPlanExecutionCreateManyTrainingPlanInput = {
    id?: string
    startedAt: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayPlannedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutPlannedDaysNestedInput
  }

  export type TrainingDayPlannedUncheckedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayPlannedUncheckedUpdateManyWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    dayName?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    plannedData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPlanExecutionUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDays?: TrainingDayExecutedUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type TrainingPlanExecutionUncheckedUpdateManyWithoutTrainingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedCreateManyExecutionInput = {
    id?: string
    athleteId: string
    activityId?: string | null
    weekIndex: number
    dayIndex: number
    date: Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDayExecutedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: AthleteUpdateOneRequiredWithoutExecutedDaysNestedInput
  }

  export type TrainingDayExecutedUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDayExecutedUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    athleteId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    weekIndex?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedData?: NullableJsonNullValueInput | InputJsonValue
    analysis?: NullableJsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskCreateManyFounderInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactCreateManyFounderInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    company?: string | null
    pipeline: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateManyFounderInput = {
    id?: string
    roadmapType: string
    quarter?: string | null
    category?: string | null
    title: string
    description?: string | null
    status?: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFounderCreateManyFounderInput = {
    id?: string
    companyId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type TaskCreateManyFounderInput = {
    id?: string
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type FounderTaskUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderTaskUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapType?: StringFieldUpdateOperationsInput | string
    quarter?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFoundersNestedInput
  }

  export type CompanyFounderUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutTasksNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFounderCreateManyCompanyInput = {
    id?: string
    founderId: string
    role?: string | null
    joinedAt?: Date | string
  }

  export type CompanyEmployeeCreateManyCompanyInput = {
    id?: string
    email: string
    name: string
    role?: string | null
    department?: string | null
    phoneNumber?: string | null
    joinedAt?: Date | string
  }

  export type CompanyRoadmapItemCreateManyCompanyInput = {
    id?: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type TaskCreateManyCompanyInput = {
    id?: string
    founderId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyCrmContactCreateManyCompanyInput = {
    id?: string
    name: string
    role?: string | null
    email?: string | null
    companyName?: string | null
    pipeline?: string
    status?: string
    nextStep?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFinancialSpendCreateManyCompanyInput = {
    id?: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFinancialProjectionCreateManyCompanyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goFastCompanyId?: string | null
  }

  export type CompanyFounderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneRequiredWithoutCompanyFoundersNestedInput
  }

  export type CompanyFounderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFounderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRoadmapItemUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GoFastCompany?: GoFastCompanyUpdateOneWithoutRoadmapItemsNestedInput
  }

  export type CompanyRoadmapItemUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyRoadmapItemUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneWithoutUnifiedTasksNestedInput
    GoFastCompany?: GoFastCompanyUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCrmContactUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCrmContactUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCrmContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pipeline?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialSpendUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GoFastCompany?: GoFastCompanyUpdateOneWithoutFinancialSpendsNestedInput
  }

  export type CompanyFinancialSpendUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialSpendUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialProjectionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    GoFastCompany?: GoFastCompanyUpdateOneWithoutFinancialProjectionsNestedInput
  }

  export type CompanyFinancialProjectionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyFinancialProjectionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goFastCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyStaffCreateManyCompanyInput = {
    id?: string
    firebaseId: string
    name?: string | null
    email?: string | null
    photoURL?: string | null
    role: string
    department?: string | null
    verificationCode?: string | null
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyCompanyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    goesBy?: string | null
    email?: string | null
    phone?: string | null
    title?: string | null
    athleteId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineCreateManyCompanyInput = {
    id?: string
    contactId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineConfigCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    stages: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPipelineItemCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    timeItTakes?: string | null
    status?: string
    priority?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFinancialSpendCreateManyGoFastCompanyInput = {
    id?: string
    companyId: string
    date: Date | string
    amount: number
    category: string
    description?: string | null
    vendor?: string | null
    department?: string | null
    project?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFinancialProjectionCreateManyGoFastCompanyInput = {
    id?: string
    companyId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    projectedRevenue?: number | null
    projectedExpenses: number
    projectedNet?: number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: number | null
    monthlyBurnRate?: number | null
    runwayMonths?: number | null
    assumptions?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRoadmapItemCreateManyGoFastCompanyInput = {
    id?: string
    companyId: string
    itemType?: string
    parentArchitecture?: string | null
    roadmapType: string
    category?: string
    title: string
    whatItDoes?: string | null
    howItHelps?: string | null
    fieldsData?: string | null
    howToGet?: string | null
    prerequisites?: string | null
    visual?: string
    orderNumber?: number | null
    hoursEstimated?: number | null
    hoursSpent?: number | null
    targetDate?: Date | string | null
    dueDate?: Date | string | null
    status?: string
    priority?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyGoFastCompanyInput = {
    id?: string
    founderId?: string | null
    companyId?: string | null
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    department?: string | null
    isTopPriority?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyStaffUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStaffUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStaffUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photoURL?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    goesBy?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    athleteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutPipelinesNestedInput
    config?: PipelineConfigUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineConfigUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUpdateManyWithoutConfigNestedInput
  }

  export type PipelineConfigUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelines?: PipelineUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type PipelineConfigUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPipelineItemUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeItTakes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialSpendUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFinancialSpendsNestedInput
  }

  export type CompanyFinancialSpendUncheckedUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialSpendUncheckedUpdateManyWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialProjectionUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFinancialProjectionsNestedInput
  }

  export type CompanyFinancialProjectionUncheckedUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFinancialProjectionUncheckedUpdateManyWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedExpenses?: FloatFieldUpdateOperationsInput | number
    projectedNet?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryBreakdown?: NullableJsonNullValueInput | InputJsonValue
    currentCash?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyBurnRate?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayMonths?: NullableFloatFieldUpdateOperationsInput | number | null
    assumptions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRoadmapItemUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutRoadmapItemsNestedInput
  }

  export type CompanyRoadmapItemUncheckedUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRoadmapItemUncheckedUpdateManyWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    parentArchitecture?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    whatItDoes?: NullableStringFieldUpdateOperationsInput | string | null
    howItHelps?: NullableStringFieldUpdateOperationsInput | string | null
    fieldsData?: NullableStringFieldUpdateOperationsInput | string | null
    howToGet?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    visual?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    hoursEstimated?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableIntFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: FounderUpdateOneWithoutUnifiedTasksNestedInput
    company?: CompanyUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutGoFastCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isTopPriority?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateManyContactInput = {
    id?: string
    companyId: string
    configId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutPipelinesNestedInput
    config?: PipelineConfigUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateManyConfigInput = {
    id?: string
    companyId: string
    contactId: string
    stageId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: GoFastCompanyUpdateOneRequiredWithoutPipelinesNestedInput
    contact?: ContactUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}